/*
 * File: Scripts/AM/view/mapping/MappingTree.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('AM.view.mapping.MappingTree', {
    extend: 'Ext.tree.Panel',
    alias: 'widget.mappingtree',

    requires: [
    'AM.view.override.mapping.MappingTree'
  ],

    stateId: 'mapping-treestate',
    stateful: true,
    border: true,
    store: 'MappingStore',
    rootVisible: false,
    selType: 'rowmodel',

    initComponent: function () {
        var me = this;

        Ext.applyIf(me, {
            stateEvents: [
        'itemcollapse',
        'itemexpand'
      ],
            viewConfig: {
                plugins: [
          Ext.create('Ext.tree.plugin.TreeViewDragDrop', {
              ddGroup: 'refdataGroup',
              enableDrag: false
          })
        ],
                listeners: {
                    beforedrop: {
                        fn: me.onBeforeNodeDrop,
                        scope: me
                    }
                }
            },
            dockedItems: [
        {
            xtype: 'toolbar',
            dock: 'top',
            items: [
            {
                xtype: 'button',
                handler: function (button, event) {
                    var tree = button.up('toolbar').up('panel');
                    var node = tree.getRootNode();
                    tree.onReload(node);
                },
                icon: 'Content/img/16x16/view-refresh.png',
                text: 'Reload Tree'
            },
            {
                xtype: 'button',
                handler: function (button, event) {
                    me.onSave();
                },
                icon: 'Content/img/16x16/document-save.png',
                text: 'Save'
            }
          ]
        }
      ],
            listeners: {
                itemcontextmenu: {
                    fn: me.showContextMenu,
                    scope: me
                },
                beforeload: {
                    fn: me.onBeforeLoad,
                    scope: me
                }
            },
            selModel: Ext.create('Ext.selection.RowModel', {

            })
        });

        me.processMappingTree(me);
        me.callParent(arguments);
    },

    processMappingTree: function (config) {
        //var storeId = Ext.data.IdGenerator.get("uuid").generate();
        //config.store = Ext.create('AM.store.MappingStore', {
        //storeId: "Mapping_" + storeId
        //}); 
        //return config;


    },

    onBeforeNodeDrop: function (node, data, overModel, dropPosition, dropHandler, eOpts) {

        var me = this;
        var pan = me.up('mappingpanel');
        me.getParentClass(overModel);
        var nodetype, thistype, icn, txt, templateId, rec, parentId, context, classMapIndex;
        var tempArr = pan.graph.split('/'); //pan.graphName;
        var graphName = tempArr[tempArr.length - 1];
        var modelType = data.records[0].data.type;
        if (overModel.data.type == 'RoleMapNode') {

            reference = data.records[0].data.record.Uri;
            label = data.records[0].data.record.Label;
            roleId = overModel.data.record.id;
            roleName = overModel.data.record.name;
            rec = data.records[0].data.record;
            txt = data.records[0].data.record.Label;
            parentId = me.parentClass;
            f = false;
            var classIndex = me.parentClassIndex;
            var index = overModel.parentNode.parentNode.indexOf(overModel.parentNode);
            me.getEl().mask('Loading...');
            //this.getEl().mask('Loading...');
            Ext.Ajax.request({
                url: 'mapping/makereference', //'mapping/mapreference',
                method: 'POST',
                params: {
                    refClassId: reference,
                    classId: parentId,
                    refClassLabel: label,
                    roleId: roleId,
                    roleName: roleName,
                    scope: pan.contextName,
                    //ctx: pan.contextName,
                    app: pan.endpoint,
                    templateIndex: index,
                    graph: graphName,
                    classIndex: classIndex
                    //baseUrl: pan.baseUrl
                },
                success: function (result, request) {
                    me.getEl().unmask();
                    //this.getEl().unmask();
                    me.onReload();
                },
                failure: function (result, request) {
                    //don't drop it
                    return false;
                }
            });
        }
        if (modelType == 'TemplateNode') { //(data.records[0].data.type == 'TemplateNode') {
            ntype = overModel.data.type;
            parentid = overModel.data.identifier;
            classMapIndex = overModel.data.identifierIndex;
            thistype = data.records[0].data.type;
            icn = 'Content/img/template-map.png';
            txt = data.records[0].data.record.Label;
            templateId = data.records[0].data.identifier;
            rec = data.records[0].data.record;
            context = overModel.data.id + '/' + txt;
            lf = false;
            me.getEl().mask('Loading...');
            Ext.Ajax.request({
                url: 'mapping/addtemplatemap',
                timeout: 600000,
                method: 'POST',
                params: {
                    contextName: pan.contextName,
                    ctx: context, //overModel.internalId,
                    endpoint: pan.endpoint,
                    baseUrl: pan.baseUrl,
                    nodetype: thistype,
                    parentType: ntype,
                    parentId: parentid,
                    classMapIndex: classMapIndex,
                    id: templateId,
                    graphName: graphName
                },
                success: function (result, request) {
                    //alert('success...');
                    me.onReload();
                    me.getEl().unmask();
                    return false;
                },
                failure: function (result, request) {
                    //alert('failure..');
                    //me.onReload();
                    //me.getEl().unmask();
                    return false;

                }
            });
        }
        else {
            return false;
        }
        return false;

    },

    showContextMenu: function (dataview, record, item, index, e, eOpts) {
        var me = this;

        //e.stopEvent();
        //var obj = record.store.getAt(index).data;
        var obj = record.data;

        if (obj.type == "TemplateMapNode") {
            var templatemapMenu = Ext.widget('templatemapmenu');
            templatemapMenu.showAt(e.getXY());
        } else if (obj.type == "RoleMapNode") {
            var rolemapMenu = Ext.widget('rolemapmenu');
            rolemapMenu.showAt(e.getXY());
        } else if (obj.type == "ClassMapNode") {
            var classmapMenu = Ext.widget('classmapmenu');
            classmapMenu.showAt(e.getXY());
        }
    },

    onBeforeLoad: function (store, operation, eOpts) {
        //alert('onBeforeLoad of tree.....'+operation.node.data.type);

        /*var tempIdArr = operation.node.data.id.split('/');
        var tempId = tempIdArr[tempIdArr.length-1];
        var tempNode;
        if(store.tree.root.firstChild!=undefined)		
        tempNode = store.tree.root.firstChild.data.id+'/'+tempId;
        */

        //alert('this is beforeload...');
        store.proxy.extraParams.type = operation.node.data.type;
        store.proxy.extraParams.index = operation.node.data.index;
        if (store.proxy.extraParams !== undefined) {
            store.proxy.extraParams.id = operation.node.data.id;

            if (operation.node.data.type == 'ClassMapNode')
                store.proxy.extraParams.index = operation.node.data.identifierIndex;
            /*
            store.proxy.extraParams.id = operation.node.data.identifier;
            store.proxy.extraParams.tempNode = tempNode;
            */
        }
    },

    applyState: function (state) {
        var me = this;
        var nodes = state.expandedNodes || [],
      len = nodes.length;
        me.collapseAll();
        Ext.each(nodes, function (path) {
            me.expandPath(path, 'text');
        });
        me.callParent(arguments);
    },

    getState: function () {
        var me = this;
        var nodes = [], state = me.callParent();
        me.getRootNode().eachChild(function (child) {
            // function to store state of tree recursively 
            var storeTreeState = function (node, expandedNodes) {
                if (node.isExpanded() && node.childNodes.length > 0) {
                    expandedNodes.push(node.getPath('text'));
                    node.eachChild(function (child) {
                        storeTreeState(child, expandedNodes);
                    });
                }
            };
            storeTreeState(child, nodes);
        });
        Ext.apply(state, {
            expandedNodes: nodes
        });
        return state;
    },

    onReload: function () {

        var me = this;
        var mappingPanel = me.up('mappingpanel');
        var graphFullName = me.up('mappingpanel').graph; //me.up('mappingpanel').graphName;
        var graphNameArr = graphFullName.split('/');
        var graphName = graphNameArr[graphNameArr.length - 1];
        var path, graphNode, context, endpoint, id;
        var node = me.getSelectedNode();
        if (!node) {
            node = me.getRootNode();
            //context = node.firstChild.data.id.split('/')[0];
            //endpoint = node.firstChild.data.id.split('/')[1];
            //id = node.firstChild.data.id;
        } else {

            //context = node.data.id.split('/')[0];
            //endpoint = node.data.id.split('/')[1];
            //id = node.data.id;
        }


        var store = me.store;
        var params = store.getProxy().extraParams;
        /*var root = me.getRootNode();
        root.eachChild(function(child) {
        if(child.data.text == graphName)
        graphNode = child;
        });*/
        var state = me.getState();
        if (node) {
            //mappingPanel.body.mask('Loading...', 'x-mask-loading');
            /*path = node.getPath('text');
            store.load(node);
            if(node.isExpanded())
            node.collapse();
            */
            store.on('beforeload', function (store, operation, eopts) {
                //alert('before load of mapping tree..');
                //params.contextName = context;
                //params.endpoint = endpoint;
                //params.id = id;
                //params.tempNode = id;
                params.graph = graphName;
            }, me);

            /*store.load({
            node: node,
            callback: function(records, options, success){
            mappingPanel.body.unmask();

            }
            });
            */

            store.reload({
                callback: function (records, options, success) {
                    var nodes = state.expandedNodes || [];
                    var len = nodes.length;
                    if (len > 0)
                        me.collapseAll();
                    Ext.each(nodes, function (path) {
                        me.expandPath(path, 'text');
                    });
                    //me.expandPath('/OctGraph/IdentificationByTag', 'text');
                    // me.applyState(state);
                }

            });
        }

        /*if(path) {
        me.expandPath(path, 'text');
        me.getSelectionModel().select(node);
        }*/
    },

    onSave: function () {
        var me = this;
        var mapPanel = me.up('panel');
        Ext.Ajax.request({
            url: 'mapping/updateMapping',
            method: 'POST',
            params: {
                //contextName: mapPanel.context,
                //endpoint: mapPanel.endpoint,
                scope: mapPanel.contextName,
                application: mapPanel.endpoint,
                baseUrl: mapPanel.baseUrl
            },
            success: function (result, request) {
                me.onReload();
            },
            failure: function (result, request) {
                return false;
            }
        });
    },

    getParentClass: function (n) {
        if (n != undefined) {
            if (n.parentNode !== null && n.parentNode !== undefined) {
                if ((n.parentNode.data.type == 'ClassMapNode' ||
        n.parentNode.data.type == 'GraphMapNode') &&
        n.parentNode.data.identifier !== undefined) {
                    this.parentClass = n.parentNode.data.identifier;
                    this.parentClassIndex = n.parentNode.data.identifierIndex;
                    return this.parentClass;
                }
                else {
                    this.getParentClass(n.parentNode);
                }
            }
        }

    },

    getSelectedNode: function () {
        var me = this;
        var selected = me.getSelectionModel().getSelection();
        return selected[0];
    }

});