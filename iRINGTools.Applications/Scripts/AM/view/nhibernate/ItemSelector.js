/*
 * File: Scripts/AM/view/nhibernate/ItemSelector.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('AM.view.nhibernate.ItemSelector', {
  extend: 'Ext.panel.Panel',
  alias: 'widget.itemselector',

  requires: [
    'AM.view.override.nhibernate.ItemSelector'
  ],

  layout: {
    align: 'stretch',
    type: 'hbox'
  },
  bodyPadding: 3,

  initComponent: function() {
    var me = this;

    me.callParent(arguments);
  },

  getSelection: function(list) {
    var store = list.getStore();

    return Ext.Array.sort(list.getSelectionModel().getSelection(), function(a, b) {
      a = store.indexOf(a);
      b = store.indexOf(b);

      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      }
      return 0;
    });
  },

  createList: function(title) {
    var me = this;

    return Ext.create('AM.view.MultiSelectFieldContainer', {
      submitValue: false,
      flex: 1,
      dragGroup: me.ddGroup,
      dropGroup: me.ddGroup,
      title: title,
      store: {
        model: me.store.model,
        data: []
      },
      displayField: me.displayField,
      disabled: me.disabled,
      listeners: {
        boundList: {
          scope: me,
          itemdblclick: me.onItemDblClick,
          drop: me.syncValue
        }
      }
    });
  },

  setupItems: function() {
    var me = this;

    me.fromField = me.createList(me.fromTitle);
    me.toField = me.createList(me.toTitle);

    return {
      border: false,
      layout: {
        type: 'hbox',
        align: 'stretch'
      },
      items: [
      me.fromField,
      {
        xtype: 'container',
        margins: '0 4',
        width: 22,
        layout: {
          type: 'vbox',
          pack: 'center'
        },
        items: me.createButtons()
      },
      me.toField
      ]
    };
  },

  getSelections: function(list) {
    var store = list.getStore();

    return Ext.Array.sort(list.getSelectionModel().getSelection(), function(a, b) {
      a = store.indexOf(a);
      b = store.indexOf(b);

      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      }
      return 0;
    });
  },

  moveRecord: function(add, recs) {
    var me = this,
    fromField = me.fromField,
    toField   = me.toField,
    fromStore = add ? fromField.store : toField.store,
    toStore   = add ? toField.store   : fromField.store;

    fromStore.suspendEvents();
    toStore.suspendEvents();
    fromStore.remove(recs);
    toStore.add(recs);
    fromStore.resumeEvents();
    toStore.resumeEvents();

    fromField.boundList.refresh();
    toField.boundList.refresh();

    me.syncValue();
  },

  syncValue: function() {
    var me = this; 
    me.mixins.field.setValue.call(me, me.setupValue(me.toField.store.getRange()));
  },

  onItemDblClick: function(view, rec) {
    this.moveRec(view === this.fromField.boundList, rec);
  },

  setValue: function(value) {
    var me = this,
    fromField = me.fromField,
    toField = me.toField,
    fromStore = fromField.store,
    toStore = toField.store,
    selected;

    // Wait for from store to be loaded
    if (!me.fromStorePopulated) {
      me.fromField.store.on({
        load: Ext.Function.bind(me.setValue, me, [value]),
        single: true
      });
      return;
    }

    value = me.setupValue(value);
    me.mixins.field.setValue.call(me, value);

    selected = me.getRecordsForValue(value);

    // Clear both left and right Stores.
    // Both stores must not fire events during this process.
    fromStore.suspendEvents();
    toStore.suspendEvents();
    fromStore.removeAll();
    toStore.removeAll();

    // Reset fromStore
    me.populateFromStore(me.store);

    // Copy selection across to toStore
    Ext.Array.forEach(selected, function(rec){
      // In the from store, move it over
      if (fromStore.indexOf(rec) > -1) {
        fromStore.remove(rec);
      }
      toStore.add(rec);
    });

    // Stores may now fire events
    fromStore.resumeEvents();
    toStore.resumeEvents();

    // Refresh both sides and then update the app layout
    Ext.suspendLayouts();
    fromField.boundList.refresh();
    toField.boundList.refresh();
    Ext.resumeLayouts(true);    
  },

  onBindStore: function(store, initial) {
    var me = this;

    if (me.fromField) {
      me.fromField.store.removeAll();
      me.toField.store.removeAll();

      // Add everything to the from field as soon as the Store is loaded
      if (store.getCount()) {
        me.populateFromStore(store);
      } else {
        me.store.on('load', me.populateFromStore, me);
      }
    }
  },

  populateFromStore: function(store) {
    var fromStore = this.fromField.store;

    // Flag set when the fromStore has been loaded
    this.fromStorePopulated = true;

    fromStore.add(store.getRange());

    // setValue waits for the from Store to be loaded
    fromStore.fireEvent('load', fromStore);
  },

  onEnable: function() {

  }

});