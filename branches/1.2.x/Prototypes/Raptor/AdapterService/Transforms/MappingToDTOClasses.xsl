<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.1"
                xmlns:iring="http://ns.iringtools.org/adapter"
                xmlns:msxsl="urn:schemas-microsoft-com:xslt"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  
  <xsl:output method="text" encoding="UTF-8" omit-xml-declaration="yes"/>
  
  <xsl:param name="dataDictionaryPath"/>
  <!--<xsl:variable name="dataDictionaryPath" select="'C:\ids-adi\camelot\Code\Adapter\AdapterService\XML\DataDictionary.xml'"/>-->
  <xsl:variable name="dataDictionaryDoc" select="document($dataDictionaryPath)"/>
  
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>      
  <xsl:variable name="lowercase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="namespace" select="'org.iringtools.adapter'"/>

  <xsl:template match="/">
    <xsl:apply-templates select="Mapping"/>
  </xsl:template>
  
  <xsl:template match="Mapping">
    <xsl:variable name="tempGraphs">
      <xsl:apply-templates select="GraphMaps/GraphMap"/>
    </xsl:variable>
    <xsl:variable name="graphs" select="msxsl:node-set($tempGraphs)"/>

//------------------------------------------------------------------------------
//
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml.Xsl;
using org.iringtools.adapter.dataLayer;
using org.iringtools.adapter.dataLayer.Model;
using org.iringtools.utility;

// TODO: handle combined identifiers
namespace <xsl:value-of select="$namespace"/>.Model
{   <xsl:for-each select="$graphs/graph">
  [DataContract(Name = "<xsl:value-of select="name"/>", Namespace = "<xsl:value-of select="$namespace"/>")]
  public class <xsl:value-of select="name"/>DTO : CommonDTO
  {
    public <xsl:value-of select="name"/>DTO(string graphName, object identifier)
      : base(graphName)
    { <xsl:for-each select="properties/property">
      _properties.Add(new PropertyDTO(@"<xsl:value-of select="name"/>", null, typeof(<xsl:value-of select="dataType"/>), <xsl:value-of select="isIdentifier"/>, <xsl:value-of select="isNullable"/>));</xsl:for-each>

      this.Identifier.Value = identifier;
    }
      <xsl:for-each select="DataObjectMaps/DataObjectMap">
    public <xsl:value-of select="../../name"/>DTO(string graphName, object identifier, <xsl:value-of select="@name"/> dataObject)
      : this(graphName, identifier)
    {  
      if (dataObject != null)
      { <xsl:for-each select="../../properties/property">
        this.<xsl:value-of select="concat(template, '_', name)"/> = (<xsl:value-of select="dataType"/>)dataObject.<xsl:value-of select="name"/>;</xsl:for-each>
      }
      
      this._dataObject = dataObject;
    } 
      </xsl:for-each>    
      <xsl:for-each select="DataObjectMaps/DataObjectMap">
    public <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="@name"/> dataObject)
      : this("<xsl:value-of select="../../name"/>", null, dataObject) {}
      </xsl:for-each>      
    public <xsl:value-of select="name"/>DTO()
      : this("<xsl:value-of select="name"/>", null) {}
      <xsl:for-each select="properties/property">
    [DataMember(Name = "<xsl:value-of select="concat(template, '.', role)"/>", EmitDefaultValue = false)]<xsl:variable name="nullableType">
        <xsl:choose>
          <xsl:when test="dataType = 'DateTime' or dataType = 'Double' or dataType = 'Float' or dataType = 'Decimal' or contains(dataType,'Int')">
            <xsl:value-of select="concat('global::System.Nullable&lt;', dataType, '&gt;')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="dataType"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
    public <xsl:value-of select="concat($nullableType, ' ', template, '_', name)"/>
    {
      get
      {
        return (<xsl:value-of select="dataType"/>)GetPropertyValue("<xsl:value-of select="name"/>");
      }

      set
      {
        SetPropertyValue("<xsl:value-of select="name"/>", value);
      }
    }
      </xsl:for-each>
    public override object GetDataObject()
    {
      <xsl:for-each select="DataObjectMaps/DataObjectMap">
        <xsl:if test="@inFilter != ''">
          <xsl:if test="position() &gt; 1">
      else </xsl:if>if (<xsl:value-of select="@inFilter"/>) // inFilter
      { </xsl:if>     
        if (_dataObject == null)
        { <xsl:variable name="dataObjectName" select="@name"/>
          _dataObject = new <xsl:value-of select="$dataObjectName"/>();<xsl:for-each select="../../properties/property">
            <xsl:if test="isIdentifier = 'true'">
          ((<xsl:value-of select="$dataObjectName"/>)_dataObject).<xsl:value-of select="name"/> = (<xsl:value-of select="dataType"/>)this.<xsl:value-of select="concat(template, '_', name)"/>;</xsl:if>
          </xsl:for-each>          
        }        
        <xsl:for-each select="../../properties/property">
          <xsl:if test="isIdentifier != 'true'">
        ((<xsl:value-of select="$dataObjectName"/>)_dataObject).<xsl:value-of select="name"/> = (<xsl:value-of select="dataType"/>)this.<xsl:value-of select="concat(template, '_', name)"/>;</xsl:if>
        </xsl:for-each>          
        <xsl:if test="@inFilter != ''">
      } </xsl:if>
      </xsl:for-each>
      
      return _dataObject;
    }
    
    public override string Serialize()
    {
      return Utility.SerializeDataContract&lt;<xsl:value-of select="name"/>DTO&gt;(this);
    }

    public override void Write(string path)
    {
      Utility.Write&lt;<xsl:value-of select="name"/>DTO&gt;(this, path);
    }
    
    public override T Transform&lt;T&gt;(string xmlPath, string stylesheetUri, string mappingUri, bool useDataContractDeserializer)
    {
      string dtoPath = xmlPath + this.GraphName + ".xml";
      Mapping mapping = Utility.Read&lt;Mapping&gt;(mappingUri, false);

      List&lt;<xsl:value-of select="name"/>DTO&gt; list = new List&lt;<xsl:value-of select="name"/>DTO&gt; { this };
      Utility.Write&lt;List&lt;<xsl:value-of select="name"/>DTO&gt;&gt;(list, dtoPath);

      XsltArgumentList xsltArgumentList = new XsltArgumentList();
      xsltArgumentList.AddParam("dtoFilename", "", dtoPath);

      return Utility.Transform&lt;Mapping, T&gt;(mapping, stylesheetUri, xsltArgumentList, false, useDataContractDeserializer);
    }
  } </xsl:for-each>
}

namespace <xsl:value-of select="$namespace"/>
{
  using <xsl:value-of select="$namespace"/>.Model;
  
  public class DTOFactory
  {
    public static T TransformList&lt;T&gt;(string graphName, List&lt;CommonDTO&gt; dtoList, string xmlPath, string stylesheetUri, string mappingUri, bool useDataContractDeserializer)
    {
      string dtoPath = xmlPath + graphName + "DTO.xml";
      Mapping mapping = Utility.Read&lt;Mapping&gt;(mappingUri, false);
      
      switch (graphName)
      { <xsl:for-each select="$graphs/graph">
        case "<xsl:value-of select="name"/>":
          List&lt;<xsl:value-of select="name"/>DTO&gt; <xsl:value-of select="name"/>DTOList = new List&lt;<xsl:value-of select="name"/>DTO&gt;();

          foreach (CommonDTO dto in dtoList)
          {
            <xsl:value-of select="name"/>DTOList.Add((<xsl:value-of select="name"/>DTO)dto);
          }

          Utility.Write&lt;List&lt;<xsl:value-of select="name"/>DTO&gt;&gt;(<xsl:value-of select="name"/>DTOList, dtoPath);
          break;
        </xsl:for-each>
      }
      
      XsltArgumentList xsltArgumentList = new XsltArgumentList();
      xsltArgumentList.AddParam("dtoFilename", "", dtoPath);

      return Utility.Transform&lt;Mapping, T&gt;(mapping, stylesheetUri, xsltArgumentList, false, useDataContractDeserializer);
    }
    
    public static CommonDTO Create(string graphName, string identifier)
    {
      CommonDTO dto = null;

      switch (graphName)
      { <xsl:for-each select="$graphs/graph">
        case "<xsl:value-of select="name"/>":
          dto = new <xsl:value-of select="name"/>DTO(graphName, identifier);
          break;
        </xsl:for-each>
      }
      
      return dto;
    }
    
    public static List&lt;CommonDTO&gt; CreateList(string graphName, List&lt;string&gt; identifiers)
    {
      List&lt;CommonDTO&gt; dtoList = new List&lt;CommonDTO&gt;();

		foreach (string identifier in identifiers)
		{
		dtoList.Add(Create(graphName, identifier));
		}

		return dtoList;
		}

		public static CommonDTO GetDTO(string graphName, string identifier)
		{
		CommonDTO dto = null;		
		DataLayer dataLayer = new DataLayer();

		switch (graphName)
		{ <xsl:for-each select="$graphs/graph">
        case "<xsl:value-of select="name"/>":
          <xsl:for-each select="DataObjectMaps/DataObjectMap">
            <xsl:choose>
              <xsl:when test="@outFilter != ''">
          var <xsl:value-of select="../../name"/>DO = 
           (from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            where <xsl:value-of select="@name"/>List.<xsl:value-of select="../../identifier"/> == identifier &amp;&amp; <xsl:value-of select="@name"/>List.<xsl:value-of select="substring-after(@outFilter, '_')"/>  // outFilter
            select <xsl:value-of select="@name"/>List).FirstOrDefault&lt;<xsl:value-of select="@name"/>&gt;();
              </xsl:when>
              <xsl:otherwise>
          var <xsl:value-of select="@name"/>DO = 
           (from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            where <xsl:value-of select="@name"/>List.<xsl:value-of select="../../identifier"/> == identifier
            select <xsl:value-of select="@name"/>List).FirstOrDefault&lt;<xsl:value-of select="@name"/>&gt;();    
              </xsl:otherwise>
            </xsl:choose>
          <xsl:choose>
              <xsl:when test="@outFilter != ''">
          if (<xsl:value-of select="../../name"/>DO != default(<xsl:value-of select="@name"/>))
          {
            dto = new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="../../name"/>DO);</xsl:when>
              <xsl:otherwise>  
          if (<xsl:value-of select="@name"/>DO != default(<xsl:value-of select="@name"/>))
          {                        
            dto = new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="@name"/>DO);
            break;</xsl:otherwise>
            </xsl:choose>
          }
          </xsl:for-each>
          break;
        </xsl:for-each>
      }
      
      return dto;
    }
    
    public static List&lt;CommonDTO&gt; GetList(string graphName)
    {
      List&lt;CommonDTO&gt; dtoList = new List&lt;CommonDTO&gt;();
      DataLayer dataLayer = new DataLayer();

      switch (graphName)
      { <xsl:for-each select="$graphs/graph">
        case "<xsl:value-of select="name"/>":
          <xsl:for-each select="DataObjectMaps/DataObjectMap">
            <xsl:choose>
              <xsl:when test="@outFilter != ''">
          var <xsl:value-of select="../../name"/>DOList = 
            from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            where <xsl:value-of select="@name"/>List.<xsl:value-of select="substring-after(@outFilter, '_')"/>  // outFilter
            select <xsl:value-of select="@name"/>List;
            
          foreach (var <xsl:value-of select="../../name"/>DO in <xsl:value-of select="../../name"/>DOList)
          {   
            dtoList.Add(new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="../../name"/>DO));
          }   </xsl:when>
              <xsl:otherwise>          
          var <xsl:value-of select="@name"/>DOList = 
            from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            select <xsl:value-of select="@name"/>List;  
            
          foreach (var <xsl:value-of select="@name"/>DO in <xsl:value-of select="@name"/>DOList)
          {
            dtoList.Add(new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="@name"/>DO));
          }   </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>          
          break;
        </xsl:for-each>      
      }
      
      return dtoList;
    }
    
    public static Dictionary&lt;string, string&gt; GetDTOList(string graphName)
    {
      Dictionary&lt;string, string&gt; identifierUriPairs = new Dictionary&lt;string, string&gt;();
      DataLayer dataLayer = new DataLayer();
      String endpoint = OperationContext.Current.Channel.LocalAddress.ToString();

      switch (graphName)
      { <xsl:for-each select="$graphs/graph">
        case "<xsl:value-of select="name"/>":
          <xsl:for-each select="DataObjectMaps/DataObjectMap">
            <xsl:choose>
              <xsl:when test="@outFilter != ''">
          var <xsl:value-of select="../../name"/>DOList = 
            from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            where <xsl:value-of select="@name"/>List.<xsl:value-of select="substring-after(@outFilter, '_')"/>  // outFilter
            select <xsl:value-of select="@name"/>List;
            
          foreach (var <xsl:value-of select="../../name"/>DO in <xsl:value-of select="../../name"/>DOList)
          {   
            <xsl:value-of select="../../name"/>DTO dto = new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="../../name"/>DO);
            string identifier = dto.Identifier.Value.ToString();
            identifierUriPairs.Add(identifier, endpoint + "/" + graphName + "/" + identifier);            
          }   </xsl:when>
              <xsl:otherwise>          
          var <xsl:value-of select="@name"/>DOList = 
            from <xsl:value-of select="@name"/>List in dataLayer.GetList&lt;<xsl:value-of select="@name"/>&gt;()
            select <xsl:value-of select="@name"/>List;  
            
          foreach (var <xsl:value-of select="@name"/>DO in <xsl:value-of select="@name"/>DOList)
          {
            <xsl:value-of select="../../name"/>DTO dto = new <xsl:value-of select="../../name"/>DTO(<xsl:value-of select="@name"/>DO);
            string identifier = dto.Identifier.Value.ToString();
            identifierUriPairs.Add(identifier, endpoint + "/" + graphName + "/" + identifier);  
          }   </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>          
          break;
        </xsl:for-each>      
      }
      
      return identifierUriPairs;
    }
    
    public static Response Post(string graphName, CommonDTO dto)
    {
      Response response = new Response();
      DataLayer dataLayer = new DataLayer();

      if (dto != null)
      {
        switch (graphName)
        { <xsl:for-each select="$graphs/graph">
          case "<xsl:value-of select="name"/>":
            <xsl:choose>
              <xsl:when test="count(DataObjectMaps/DataObjectMap) = 1">
            <xsl:value-of select="concat(DataObjectMaps/DataObjectMap/@name, ' ', name)"/>DO = (<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>)dto.GetDataObject();
            response.Append(dataLayer.Post&lt;<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>&gt;(<xsl:value-of select="name"/>DO));
              </xsl:when>
              <xsl:otherwise>
            <xsl:value-of select="name"/>DTO <xsl:value-of select="name"/>DTOObj = (<xsl:value-of select="name"/>DTO)dto;            
                <xsl:for-each select="DataObjectMaps/DataObjectMap">
                  <xsl:if test="position() &gt; 1">
            else </xsl:if>if (<xsl:value-of select="../../name"/>DTOObj.<xsl:value-of select="@inFilter"/>) // inFilter
            {
              <xsl:value-of select="concat(@name, ' ', @name)"/>DO = (<xsl:value-of select="@name"/>)<xsl:value-of select="../../name"/>DTOObj.GetDataObject();
              response.Append(dataLayer.Post&lt;<xsl:value-of select="@name"/>&gt;(<xsl:value-of select="@name"/>DO));
            }   </xsl:for-each>
              </xsl:otherwise>
            </xsl:choose>
            break;
          </xsl:for-each>        
        }
      }
      
      return response;
    }
    
    public static Response PostList(string graphName, List&lt;CommonDTO&gt; dtoList)
    {
      Response response = new Response();
      DataLayer dataLayer = new DataLayer();

      if (dtoList != null &amp;&amp; dtoList.Count&lt;CommonDTO&gt;() > 0)
      {
        switch (graphName)
        { <xsl:for-each select="$graphs/graph">
          case "<xsl:value-of select="name"/>":
            <xsl:choose>
              <xsl:when test="count(DataObjectMaps/DataObjectMap) = 1">
            List&lt;<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>&gt; <xsl:value-of select="name"/>DOList = new List&lt;<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>&gt;();

            foreach (CommonDTO dto in dtoList)
            {
              <xsl:value-of select="name"/>DOList.Add((<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>)dto.GetDataObject());
            }

            response.Append(dataLayer.PostList&lt;<xsl:value-of select="DataObjectMaps/DataObjectMap/@name"/>&gt;(<xsl:value-of select="name"/>DOList));
              </xsl:when>
              <xsl:otherwise>
                <xsl:for-each select="DataObjectMaps/DataObjectMap">
            List&lt;<xsl:value-of select="@name"/>&gt; <xsl:value-of select="@name"/>DOList = new List&lt;<xsl:value-of select="@name"/>&gt;();</xsl:for-each>
            
            foreach (<xsl:value-of select="name"/>DTO dto in dtoList)
            {   
                <xsl:for-each select="DataObjectMaps/DataObjectMap"> 
                  <xsl:if test="position() &gt; 1">
              else </xsl:if>if (dto.<xsl:value-of select="@inFilter"/>) // inFilter
              {
                <xsl:value-of select="@name"/>DOList.Add((<xsl:value-of select="@name"/>)dto.GetDataObject());
              } </xsl:for-each>
            }
                <xsl:for-each select="DataObjectMaps/DataObjectMap">
            response.Append(dataLayer.PostList&lt;<xsl:value-of select="@name"/>&gt;(<xsl:value-of select="@name"/>DOList));</xsl:for-each>
              </xsl:otherwise>
            </xsl:choose>
            break;
          </xsl:for-each>
    }
    }

    return response;
    }

    public static DataDictionary GetDictionary()
    {
      DataLayer dataLayer = new DataLayer();
      return dataLayer.GetDictionary();
    }

    public static Response RefreshDictionary()
    {
      DataLayer dataLayer = new DataLayer();
      return dataLayer.RefreshDictionary();
    }
  }
}
  
namespace org.iringtools.adapter
{
  using org.iringtools.adapter;
  using org.iringtools.adapter;
  
  public partial class AdapterService : IDataService
  {
    <xsl:for-each select="$graphs/graph">
    public <xsl:value-of select="name"/>DTO Get<xsl:value-of select="name"/>DTO(string identifier)
    {
      try
      {
        return (<xsl:value-of select="name"/>DTO)DTOFactory.GetDTO("<xsl:value-of select="name"/>", identifier);
      }
      catch (Exception exception)
      {
        throw new Exception("Error while getting <xsl:value-of select="name"/> DTO with identifier " + identifier + ". " + exception.ToString(), exception);
      }
    }

    public Dictionary&lt;string, string&gt; Get<xsl:value-of select="name"/>DTOList()
    {
      try
      {
        return DTOFactory.GetDTOList("<xsl:value-of select="name"/>");
      }
      catch (Exception exception)
      {
        throw new Exception("Error while getting <xsl:value-of select="name"/>DTO list. " + exception.ToString(), exception);
      }
    }

    public <xsl:value-of select="name"/>Response Get<xsl:value-of select="name"/>(Identifier identifier)
    {
      try
      {
        <xsl:value-of select="name"/>Response response = new <xsl:value-of select="name"/>Response();
        response.dto = (<xsl:value-of select="name"/>DTO)DTOFactory.GetDTO("<xsl:value-of select="name"/>", identifier.value);
        
        return response;
      }
      catch (Exception exception)
      {
        throw new Exception("Error while getting <xsl:value-of select="name"/> DTO with identifier " + identifier.value + ". " + exception.ToString(), exception);
      }
    }

    public <xsl:value-of select="name"/>ListResponse Get<xsl:value-of select="name"/>List()
    {
      try
      {
        List&lt;CommonDTO&gt; commonDTOList = (List&lt;CommonDTO&gt;)(DTOFactory.GetList("<xsl:value-of select="name"/>"));
        
        List&lt;<xsl:value-of select="name"/>DTO&gt; <xsl:value-of select="name"/>DTOList = new List&lt;<xsl:value-of select="name"/>DTO&gt;();
        foreach (CommonDTO commonDTO in commonDTOList)
        {
          <xsl:value-of select="name"/>DTOList.Add((<xsl:value-of select="name"/>DTO)commonDTO);
        }
        
        <xsl:value-of select="name"/>ListResponse response = new <xsl:value-of select="name"/>ListResponse();
        response.dtoList = <xsl:value-of select="name"/>DTOList;
        
        return response;
      }
      catch (Exception exception)
      {
        throw new Exception("Error while getting <xsl:value-of select="name"/> DTO list. " + exception.ToString(), exception);
      }
    }
    </xsl:for-each>
  }
} </xsl:template>

  <xsl:template match="GraphMaps/GraphMap">
    <graph>
      <name><xsl:value-of select="@name"/></name>
      <identifier><xsl:value-of select="@identifier"/></identifier>
      <xsl:copy-of select="DataObjectMaps"/>
      <properties>
        <xsl:apply-templates select="TemplateMaps/TemplateMap">   
          <xsl:with-param name="dataObjectMaps" select="DataObjectMaps"/>
        </xsl:apply-templates> 
      </properties>
    </graph>
  </xsl:template>

  <xsl:template match="TemplateMaps/TemplateMap">
    <xsl:param name="dataObjectMaps"/>
    <xsl:apply-templates select="RoleMaps/RoleMap">
      <xsl:with-param name="dataObjectMaps" select="$dataObjectMaps"/>
      <xsl:with-param name="templateType" select="@type"/>
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="RoleMaps/RoleMap">
    <xsl:param name="dataObjectMaps"/>
    <xsl:param name="templateType"/>
    <xsl:choose>
      <xsl:when test="$templateType = 'Property'">
        <xsl:variable name="dataObjectName" select="$dataObjectMaps/DataObjectMap[1]/@name"/>
        <xsl:variable name="propertyName" select="@propertyName"/>
        <xsl:variable name="dataObjectProperty" select="$dataDictionaryDoc/iring:DataDictionary/iring:dataObjects/iring:DataObject[iring:objectName=$dataObjectName]/iring:dataProperties/iring:DataProperty[iring:propertyName=$propertyName]"/>
        <property>
          <name>
            <xsl:value-of select="$propertyName"/>
          </name>
          <template>
            <xsl:value-of select="../../@name"/>
          </template>
          <role>
            <xsl:value-of select="@name"/>
          </role>
          <dataType>
            <xsl:value-of select="$dataObjectProperty/iring:dataType"/>
          </dataType>
          <isIdentifier>
            <xsl:value-of select="$dataObjectProperty/iring:isPropertyKey"/>
          </isIdentifier>
          <isNullable>
            <xsl:choose>
              <xsl:when test="$dataObjectProperty/iring:isRequired = 'true'">false</xsl:when>
              <xsl:otherwise>true</xsl:otherwise>                
            </xsl:choose>
          </isNullable>
        </property>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="ClassMap">
          <xsl:with-param name="dataObjectMaps" select="$dataObjectMaps"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="ClassMap">
    <xsl:param name="dataObjectMaps"/>
    <xsl:apply-templates select="TemplateMaps/TemplateMap">
      <xsl:with-param name="dataObjectMaps" select="$dataObjectMaps"/>
    </xsl:apply-templates>
  </xsl:template>
  
</xsl:stylesheet>