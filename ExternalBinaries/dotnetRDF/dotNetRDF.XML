<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dotNetRDF</name>
    </assembly>
    <members>
        <member name="T:VDS.RDF.Writing.HtmlWriter">
            <summary>
            Class for saving RDF Graphs to a XHTML Table format with the actual Triples embedded as RDFa
            </summary>
            <remarks>
            <para>
            Since not all Triples can be embedded into XHTML those Triples will not have RDFa generated for them but all Triples will be shown in a human readable format.  Triples that can be serialized are roughly equivalent to anything that can be serialized in Turtle i.e. URI/BNode subject, URI predicates and URI/BNode/Literal object.
            </para>
            <para>
            If you encode Triples which have values datatyped as XML Literals with this writer then round-trip Graph equality is not guaranteed as the RDFa parser will add appropriate Namespace declarations to elements as required by the specification
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.IRdfWriter">
            <summary>
            Interface to be implemented by RDF Writers which generate RDF Concrete Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Method for Saving a Graph to a Concrete RDF Syntax in a file based format
            </summary>
            <param name="g">The Graph to Save</param>
            <param name="filename">The filename to save the Graph in</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the RDF in the Graph is not representable by the Writer</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Writer is unable to write to the File</exception>
        </member>
        <member name="M:VDS.RDF.IRdfWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Method for Saving a Graph to a Concrete RDF Syntax via some arbitrary <see cref="T:System.IO.TextWriter">TextWriter</see>
            </summary>
            <param name="g">The Graph to Save</param>
            <param name="output">The <see cref="T:System.IO.TextWriter">TextWriter</see> to save the Graph to</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the RDF in the Graph is not representable by the Writer</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Writer is unable to write to the underlying storage of the <see cref="T:System.IO.TextWriter">TextWriter</see> specified in the <paramref name="output"/></exception>
        </member>
        <member name="E:VDS.RDF.IRdfWriter.Warning">
            <summary>
            Event which writers can raise to indicate possible ambiguities or issues in the syntax they are producing
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IHtmlWriter">
            <summary>
            Interface for Writers that generate HTML
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.Stylesheet">
            <summary>
            Gets/Sets a Stylesheet file used to format the HTML
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassUri">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display the URIs of URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassBlankNode">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Blank Node IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassLiteral">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassDatatype">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display Literal datatypes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassLangSpec">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literal language specifiers
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.UriPrefix">
            <summary>
            Gets/Sets a Prefix that is applied to all href attributes
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves the Graph to the given File as an XHTML Table with embedded RDFa
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream as an XHTML Table with embedded RDFa
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext)">
            <summary>
            Internal method which generates the HTML Output for the Graph
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext,VDS.RDF.INode)">
            <summary>
            Generates Output for a given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext,VDS.RDF.INode,VDS.RDF.Triple)">
            <summary>
            Generates Output for a given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="t">Triple being written</param>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.Stylesheet">
            <summary>
            Gets/Sets a path to a Stylesheet which is used to format the Graph output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.CssClassUri">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display the URIs of URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.CssClassBlankNode">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Blank Node IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.CssClassLiteral">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.CssClassDatatype">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display Literal datatypes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.CssClassLangSpec">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literal language specifiers
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.UriPrefix">
            <summary>
            Gets/Sets the Prefix applied to href attributes
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.HtmlWriter.Warning">
            <summary>
            Event which is raised if there is a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration">
            <summary>
            Abstract base class for representing SPARQL Handler Configuration
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.MinimumCacheDuration">
            <summary>
            Minimum Cache Duration setting permitted
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.MaximumCacheDuration">
            <summary>
            Maximum Cache Duration setting permitted
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._defaultGraph">
            <summary>
            Default Graph Uri for queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._defaultTimeout">
            <summary>
            Default Timeout for Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._defaultPartialResults">
            <summary>
            Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._supportsTimeout">
            <summary>
            Whether the Handler supports Timeouts
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._supportsPartialResults">
            <summary>
            Whether the Handler supports Partial Results on Timeout
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._timeoutField">
            <summary>
            Querystring Field name for the Timeout setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._partialResultsField">
            <summary>
            Querystring Field name for the Partial Results setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._showErrors">
            <summary>
            Whether errors are shown to the User
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._showQueryForm">
            <summary>
            Whether a Query Form should be shown to the User
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._defaultQuery">
            <summary>
            Default Sparql Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._stylesheet">
            <summary>
            Stylesheet for formatting the Query Form and HTML format results
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._cacheDuration">
            <summary>
            Number of minutes to Cache stuff for
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._introText">
            <summary>
            Introduction Text for the Query Form
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._fullIndexing">
            <summary>
            Indicates whether full Triple indexing should be used by Handlers which use the in-memory Sparql engine
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration._queryEngine">
            <summary>
            SPARQL Engine to be used
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new instance of the Base Configuration which loads all the standard settings from Configuration
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="cacheKey">Cache Key</param>
            <param name="configPrefix">Config Prefix</param>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.SetPersistentProperties">
            <summary>
            Forces persistent global options to be set to the Configuration values
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.QueryEngine">
            <summary>
            Gets the Query Engine used for Queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.DefaultGraphURI">
            <summary>
            Gets the Default Graph Uri
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.SupportsTimeout">
            <summary>
            Whether the Remote Endpoint supports specifying Query Timeout as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.DefaultTimeout">
            <summary>
            Gets the Default Query Execution Timeout
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.TimeoutField">
            <summary>
            Querystring field name for the Query Timeout for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.SupportsPartialResults">
            <summary>
            Whether the Remote Endpoint supports specifying Partial Results on Timeout behaviour as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.DefaultPartialResults">
            <summary>
            Gets the Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.PartialResultsField">
            <summary>
            Querystring field name for the Partial Results on Timeout setting for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.ShowErrors">
            <summary>
            Gets whether Error Messages should be shown to users
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.ShowQueryForm">
            <summary>
            Gets whether the Query Form should be shown to users
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.DefaultQuery">
            <summary>
            Gets the Default Query for the Query Form
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.Stylesheet">
            <summary>
            Gets the Stylesheet for formatting HTML Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.CacheDuration">
            <summary>
            Gets how many minutes stuff should be cached for by Handlers
            </summary>
            <remarks>
            <para>
            The Sparql Handlers use the ASP.Net <see cref="!:Cache">Cache</see> object to cache information and they specify the caching duration as a Sliding Duration.  This means that each time the cache is accessed the expiration time increases again.
            </para>
            <para>
            This defaults to 15 minutes and the Handlers will only allow you to set a value between the <see cref="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.MinimumCacheDuration">MinimumCacheDuration</see> and <see cref="F:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.MaximumCacheDuration">MaximumCacheDuration</see>.  We think that 15 minutes is a good setting and we use this as the default setting unless a duration is specified explicitly.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.IntroductionText">
            <summary>
            Gets the Introduction Text for the Query Form
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseSparqlHandlerConfiguration.FullTripleIndexing">
            <summary>
            Gets whether full Triple indexing should be used by Handlers which use the in-memory Sparql engine
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.MySqlStoreManager">
            <summary>
            A <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> implementation which uses MySQL Server as the backing store
            </summary>
            <threadsafety instance="true">
            <para>
            Designed to be Thread safe for concurrent read and write access
            </para>
            <para>
            <strong>Note:</strong> To ensure correct behaviour for multi-threaded writing you must set the <see cref="P:VDS.RDF.Storage.BaseStoreManager.DisableTransactions">DisableTransactions</see> property to be true.  Classes which are designed specifically to do multi-threaded writing will <em>usually</em> set this automatically.
            </para>
            <para>
            Will only be thread safe for writing if all the classes writing to the database are using a single instance of this Manager.
            </para>
            </threadsafety>
            <remarks>
            If the Database specified is not currently a dotNetRDF Store then the appropriate database tables will be created automatically.  If the Database is a dotNetRDF Store which does not use the database format then an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown as the database setup will try to recreate the existing tables and thus fail.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.MicrosoftSqlStoreManager">
            <summary>
            A <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> implementation which uses Microsoft SQL Server as the backing store
            </summary>
            <threadsafety instance="true">
            <para>
            Designed to be Thread safe for concurrent read and write access
            </para>
            <para>
            <strong>Note:</strong> To ensure correct behaviour for multi-threaded writing you must set the <see cref="P:VDS.RDF.Storage.BaseStoreManager.DisableTransactions">DisableTransactions</see> property to be true.  Classes which are designed specifically to do multi-threaded writing will <em>usually</em> set this automatically.
            </para>
            <para>
            Will only be thread safe for writing if all the classes writing to the database are using a single instance of this Manager.
            </para>
            </threadsafety>
            <remarks>
            If the Database specified is not currently a dotNetRDF Store then the appropriate database tables will be created automatically.  If the Database is a dotNetRDF Store which does not use the database format then an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown as the database setup will try to recreate the existing tables and thus fail.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.BaseStoreManager">
            <summary>
            Abstract Base Class for dotNetRDF Store Managers which provides the basic infrastructure for a Thread Safe Manager with writing handled by a background buffer
            </summary>
            <remarks>
            Provides a Background Buffer Thread which does writing when Transactions are enabled, when transactions are disabled it assumes that this has been done to allow multi-threaded writing and so all writes are done synchronously.  Benchmarking shows this is about 3 times as fast as using the single buffer Thread when doing a large multi-threaded write.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.ISqlIOManager">
            <summary>
            Interface for classes which provide the Read/Write functionality for a SQL Store of some description
            </summary>
            <remarks>
            <para>
            Designed to allow for arbitrary database formats to be used and then implemented by simply implementing this interface and providing it to the relevant classes which use SQL Stores.  It has also been designed such that 1 Manager instance may be used across multiple Graphs to facilitate the implementation of a <see cref="T:VDS.RDF.SqlTripleStore">SqlTripleStore</see>.
            </para>
            <para>
            The design of this interface assumes fairly fine grained data storage in the SQL Store, generally it will be necessary as a minimum to implement most of the methods (except perhaps the Namespace related methods.  If your SQL Store implements storage in a way that is not easy to support with this interface consider implementing the <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> interface instead.
            </para>
            <para>
            While the interface does not define any methods related to the creation/destruction of a Store we recommend that the constructor of implementations of this class should set up the necessary database tables if it determines that they do not exist.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.GetGraphID(System.Uri)">
            <summary>
            Gets the ID for a Graph in the Store, creates a new Graph in the store if necessary
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.Exists(System.Uri)">
            <summary>
            Determines whether a given Graph exists in the Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.GetGraphUris">
            <summary>
            Gets the URIs of the Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.LoadNamespaces(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Namespaces for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.LoadTriples(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Triples for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.LoadNode(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Node from the Database into the relevant Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="nodeID">Database Node ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.SaveNode(VDS.RDF.INode)">
            <summary>
            Gets the Node ID for a Node in the Database creating a new Database record if necessary
            </summary>
            <param name="n">Node to Save</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.SaveTriple(VDS.RDF.Triple,System.String)">
            <summary>
            Saves a Triple from a Graph into the Database
            </summary>
            <param name="t">Triple to save</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.SaveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Saves a Namespace from a Graph into the Database
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.RemoveTriple(VDS.RDF.Triple,System.String)">
            <summary>
            Removes a Triple from a Graphs Database record
            </summary>
            <param name="t">Triple to remove</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.RemoveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Removes a Namespace from a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.RemoveGraph(System.String)">
            <summary>
            Removes a Graph from the Database
            </summary>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.UpdateNamespace(System.String,System.Uri,System.String)">
            <summary>
            Changes the Uri associated with the Prefix in a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">New Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.ClearGraph(System.String)">
            <summary>
            Clears all the Namespaces and Triples for the given Graph from the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.Close(System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.ISqlIOManager.EscapeString(System.String)">
            <summary>
            Escapes Strings in a manner appropriate to the underlying Database
            </summary>
            <param name="text">String to escape</param>
            <returns>Escaped String</returns>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.PreserveState">
            <summary>
            Gets/Sets whether the Manager should preserve its state (Object to ID maps and ID to Object maps) even if its Dispose method is called
            </summary>
            <remarks>
            <para>
            Useful if the Manager is used multiple times by classes which will invoke its Dispose method when they are Disposed of
            </para>
            <para>
            A user should set this property to true if an instance will be used multiple times and may get disposed of multiple times to cause it to preserve its state and not dispose itself.  Classes that use an ISqlIOManager will typically dispose of the manager in their <strong>Dispose()</strong> methods since these methods should rightly dispose of resources they no longer need.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.HasCompleted">
            <summary>
            Gets whether the Manager has completed any outstanding database operations
            </summary>
            <remarks>Useful if you need to wait for the Manager to complete and you don't know whether it's finished</remarks>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.DatabaseServer">
            <summary>
            Gets the Database Server this Manager connects to
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.DatabaseName">
            <summary>
            Gets the Database this Manager is using
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.DatabaseUser">
            <summary>
            Gets the Database Username this Manager is using
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ISqlIOManager.DatabasePassword">
            <summary>
            Gets the Database Password this Manager is using
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IThreadedSqlIOManager">
            <summary>
            Interface for classes which provide the Read/Write functionality for a SQL Store in a Thread Safe way
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.IThreadedSqlIOManager.DisableTransactions">
            <summary>
            Gets/Sets whether Database Transactions should be disabled
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IGenericIOManager">
            <summary>
            Interface for classes which provide the Read/Write functionality to some arbitrary Store
            </summary>
            <remarks>
            Designed to allow for arbitrary Triple Stores to be plugged into the library as required by the end user
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IGenericIOManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            <para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IGenericIOManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            <para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IGenericIOManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store
            </summary>
            <param name="g">Graph to Save</param>
            <remarks>
            Uri of the Graph should be taken from the <see cref="P:VDS.RDF.IGraph.BaseUri">BaseUri</see> property
            <br/><br/>
            Behaviour of this method with regards to whether it overwrites/updates/merges with existing Graphs of the same Uri is up to the implementor and may be dependent on the underlying store.  Implementors <strong>should</strong> state in the XML comments for their implementations what behaviour is implemented.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>should</strong> allow for either the additions or removals argument to be null
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level or if some error occurs while attempting the Update</exception>
        </member>
        <member name="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>should</strong> allow for either the additions or removals argument to be null
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level or if some error occurs while attempting the Update</exception>
        </member>
        <member name="P:VDS.RDF.Storage.IGenericIOManager.UpdateSupported">
            <summary>
            Gets whether the <see cref="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> method is supported by the Manager
            </summary>
            <remarks>
            Some Stores do not support updates at the Triple level and may as designated in the interface defintion throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the <see cref="!:IGenericIOManager.Update">Update()</see> method is called.  This property allows for calling code to check in advance whether Updates are supported
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.IGenericIOManager.IsReady">
            <summary>
            Gets whether the connection with the underlying Store is ready for use
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.IGenericIOManager.IsReadOnly">
            <summary>
            Gets whether the connection with the underlying Store is read-only
            </summary>
            <remarks>
            Any Manager which indicates it is read-only should also return false for the <see cref="P:VDS.RDF.Storage.IGenericIOManager.UpdateSupported">UpdatedSupported</see> property and should throw a <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the <see cref="M:VDS.RDF.Storage.IGenericIOManager.SaveGraph(VDS.RDF.IGraph)">SaveGraph()</see> or <see cref="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> methods are called
            </remarks>
        </member>
        <member name="T:VDS.RDF.Configuration.IConfigurationSerializable">
            <summary>
            Interface for Objects which can have their configuration serialized to RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationSerializable.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration in the given context
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager.DefaultBatchSize">
            <summary>
            Default Batch Size for the Buffered Writing
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._dbserver">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._dbname">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._dbuser">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._dbpwd">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._keepOpen">
            <summary>
            Indicates whether the Database Connection should be kept open
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._preserveState">
            <summary>
            Variable indicating if the Manager should preserve its State when its <see cref="M:VDS.RDF.Storage.BaseStoreManager.Dispose">Dispose</see> method is called
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._validLangSpecifier">
            <summary>
            Defines a Regular Expression for Valid Language Specifiers to aid decoding of Literal Node values from the Database
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._graphIDs">
            <summary>
            Dictionary for Mapping Graph Uri Enhanced Hash Codes to Database Graph IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._tripleIDs">
            <summary>
            Dictionary for Mapping Triple Objects by Hash Code to Database Triple IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nodes">
            <summary>
            Dictionary for Mapping Node IDs to Node Objects
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nodeIDs">
            <summary>
            Dictionary for Mapping Node Objects by Hash Code to Database Node IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nsPrefixIDs">
            <summary>
            Dictionary for Mapping Namespace Prefixes to Database Prefix IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nsUriIDs">
            <summary>
            Dictionary for Mapping Namespace Uri Enhanced Hash Codes to Database Uri IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nextTripleID">
            <summary>
            The Next Triple ID to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nextNodeID">
            <summary>
            The Next Node ID to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._tripleCollection">
            <summary>
            Triple Collection used to record which Triples have been written during a session and thus spot Triple Collisions
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._nodeCollection">
            <summary>
            Node Collection used to record which Nodes have been written during a session and thus spot Node Collisions
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._writerBuffer">
            <summary>
            Buffer for Writing
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._batchSize">
            <summary>
            Batch Size for the Buffer
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._writer">
            <summary>
            Thread that does the Writing of the Buffer to the Database
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._flushWriter">
            <summary>
            Indicates whether the Writer should Flush the Buffer to the Database even if it is below the Batch Size
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._terminateWriter">
            <summary>
            Indicates whether the Writer should stop if the Buffer is empty
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStoreManager._noTrans">
            <summary>
            Indicates whether Transactions should be used with Database Connections
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.#ctor">
            <summary>
            Constructor which sets up the Writer Thread
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Base Constructor for derived classes which fills in the Database Property fields
            </summary>
            <param name="server">Database Server</param>
            <param name="db">Database Name</param>
            <param name="user">Database Username</param>
            <param name="password">Database Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.GetGraphID(System.Uri)">
            <summary>
            Gets the ID for a Graph in the Store, creates a new Graph in the store if necessary
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.Exists(System.Uri)">
            <summary>
            Determines whether a given Graph exists in the Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.GetGraphUris">
            <summary>
            Gets the URIs of Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadNamespaces(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Namespaces for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadTriples(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Triples for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadNode(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Node from the Database into the relevant Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="nodeID">Database Node ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SaveNode(VDS.RDF.INode)">
            <summary>
            Gets the Node ID for a Node in the Database creating a new Database record if necessary
            </summary>
            <param name="n">Node to Save</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SaveTriple(VDS.RDF.Triple,System.String)">
            <summary>
            Saves a Triple from a Graph into the Database
            </summary>
            <param name="t">Triple to save</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SaveTripleInternal(VDS.RDF.Storage.BatchTriple)">
            <summary>
            Saves a Triple from the Buffer into the Database
            </summary>
            <param name="b">Batch Triple information</param>
            <remarks>Can assume an open Database connection</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SaveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Saves a Namespace from a Graph into the Database
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.RemoveTriple(VDS.RDF.Triple,System.String)">
            <summary>
            Removes a Triple from a Graphs Database record
            </summary>
            <param name="t">Triple to remove</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.RemoveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Removes a Namespace from a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.RemoveGraph(System.String)">
            <summary>
            Removes a Graph from the Database
            </summary>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.UpdateNamespace(System.String,System.Uri,System.String)">
            <summary>
            Changes the Uri associated with the Prefix in a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">New Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ClearGraph(System.String)">
            <summary>
            Clears all the Namespaces and Triples for the given Graph from the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.Close(System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ExecuteQuery(System.String,System.Data.DataTable)">
            <summary>
            Executes a Query SQL Command against the database and fills the given Data Table
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <param name="data">Data Table to fill with the results</param>
            <remarks>Allows for typed Data Tables</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.EscapeString(System.String)">
            <summary>
            Escapes Strings in a manner appropriate to the underlying Database
            </summary>
            <param name="text">String to escape</param>
            <returns>Escaped String</returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.GetNextNodeID(VDS.RDF.INode,System.Boolean@)">
            <summary>
            Gets the next available Database Node ID if the Node is not in the Database or the existing Database Node ID
            </summary>
            <param name="n">Node to get an ID for</param>
            <param name="createRequired">Whether the Manager needs to create a Node Record in the Database</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadNodeIDMap">
            <summary>
            Loads the Node Hash Code to Databas ID Map from the Database and sets the Next Node ID to the maximum in-use Node ID
            </summary>
            <remarks>
            Since Hash Codes may collide where there is a collision the implementor should set the ID mapped to the Hash as -1, this indicates to the <see cref="M:VDS.RDF.Storage.BaseStoreManager.GetNextNodeID(VDS.RDF.INode,System.Boolean@)">GetNextNodeID()</see> method that it must do a database lookup to determine the correct Node ID in this case
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.GetNextTripleID(VDS.RDF.Triple,System.Boolean@)">
            <summary>
            Gets the next available Database Triple ID if the Triple is not in the Database of the existing Database Triple ID
            </summary>
            <param name="t">Triple to get an ID for</param>
            <param name="createRequired">Whether the Manager needs to create a Triple Record in the Database</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadTripleIDMap">
            <summary>
            Loads the Triple Hash Code to Databas ID Map from the Database and sets the Next Triple ID to the maximum in-use Triple ID
            </summary>
            <remarks>
            Since Hash Codes may collide where there is a collision the implementor should set the ID mapped to the Hash as -1, this indicates to the <see cref="M:VDS.RDF.Storage.BaseStoreManager.GetNextTripleID(VDS.RDF.Triple,System.Boolean@)">GetNextTripleID()</see> method that it must do a database lookup to determine the correct Triple ID in this case
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.ProcessBuffer">
            <summary>
            Internal Helper Method which is run as a Background Thread and writes the Buffer to the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            If the Graph Uri is null or the Graph doesn't exist in the Store nothing will be returned
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            If the Graph Uri is the Empty String or the Graph doesn't exist in the Store nothing will be returned
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store (Warning: Completely replaces any existing Graph with the same URI)
            </summary>
            <param name="g">Graph to Save</param>
            <remarks>
            Saving a Graph will overwrite any existing Graph of the same Uri.
            <br /><br />
            A Graph with a Null Base Uri <strong>cannot</strong> be saved.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            If the Graph Uri is null of the Graph doesn't exist in the Store a <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown
            </remarks>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown when the Graph Uri is null or the Graph to be updated doesn't exist in the Store</exception>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            If the Graph Uri is null of the Graph doesn't exist in the Store a <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown
            </remarks>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown when the Graph Uri is null or the Graph to be updated doesn't exist in the Store</exception>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.Dispose">
            <summary>
            Base Implementation of Dispose which stops the Writer Thread and clears all the Mapping dictionaries unless <see cref="P:VDS.RDF.Storage.BaseStoreManager.PreserveState">PreserveState</see> has been set as True
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStoreManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.PreserveState">
            <summary>
            Gets/Sets whether the Manager should preserve its State when disposed of
            </summary>
            <remarks>
            <para>
            Set this property to true if this instance will be used multiple times and may get disposed of multiple times to cause it to preserve its state and not dispose itself.  Classes that use an ISqlIOManager will typically dispose of the manager in their <strong>Dispose()</strong> methods since these methods should rightly dispose of resources they no longer need.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.HasCompleted">
            <summary>
            Gets whether the Manager has completed all of its Buffered Write Operations
            </summary>
            <remarks>
            <para>
            Signals the Writer to Flush the Buffer (if it is not doing so already) since if someone wants to know if we've completed we should get on and complete
            </para>
            <para>
            If
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.DisableTransactions">
            <summary>
            Gets/Sets whether Database Transactions are disabled
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.DatabaseServer">
            <summary>
            Gets the Database Server name
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.DatabaseName">
            <summary>
            Gets the Database Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.DatabaseUser">
            <summary>
            Gets the Database Username
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.DatabasePassword">
            <summary>
            Gets the Database Password
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.UpdateSupported">
            <summary>
            Indicates that Updates are supported by SQL based Store Manager
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.IsReady">
            <summary>
            Returns that the Manager is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStoreManager.IsReadOnly">
            <summary>
            Returns that the Manager is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IDotNetRDFStoreManager">
            <summary>
            Marker interface for classes which implement SQL Stores using the dotNetRDF Store Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.#ctor">
            <summary>
            Empty Constructor for derived classes to use
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Microsoft SQL Server Store Manager
            </summary>
            <param name="server">Server</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Microsoft SQL Server Store Manager
            </summary>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
            <remarks>Assumes that the Database is on the <strong>localhost</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the Microsoft SQL Server Store Manager using Integrated Authentication
            </summary>
            <param name="server">Servername</param>
            <param name="db">Database Name</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.#ctor(System.String)">
            <summary>
            Creates a new instance of the Microsoft SQL Server Store Manager using Integrated Authentication
            </summary>
            <param name="db">Database Name</param>
            <remarks>Assumes that the Database is on the <strong>localhost</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.GetGraphID(System.Uri)">
            <summary>
            Gets the ID for a Graph in the Store, creates a new Graph in the store if necessary
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.Exists(System.Uri)">
            <summary>
            Determines whether a given Graph exists in the Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.GetGraphUris">
            <summary>
            Gets the URIs of Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.LoadNamespaces(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Namespaces for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.LoadTriples(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads Triples for the Graph with the given ID into the given Graph object
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.LoadNode(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Node from the Database into the relevant Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="nodeID">Database Node ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.SaveNode(VDS.RDF.INode)">
            <summary>
            Gets the Node ID for a Node in the Database creating a new Database record if necessary
            </summary>
            <param name="n">Node to Save</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.SaveTripleInternal(VDS.RDF.Storage.BatchTriple)">
            <summary>
            Saves a Triple from a Graph into the Database
            </summary>
            <param name="b">Triple to save</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.SaveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Saves a Namespace from a Graph into the Database
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.RemoveTriple(VDS.RDF.Triple,System.String)">
            <summary>
            Removes a Triple from a Graphs Database record
            </summary>
            <param name="t">Triple to remove</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.RemoveNamespace(System.String,System.Uri,System.String)">
            <summary>
            Removes a Namespace from a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.RemoveGraph(System.String)">
            <summary>
            Removes a Graph from the Database
            </summary>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.UpdateNamespace(System.String,System.Uri,System.String)">
            <summary>
            Changes the Uri associated with the Prefix in a Graphs Database record
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="u">New Namespace Uri</param>
            <param name="graphID">Database Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.ClearGraph(System.String)">
            <summary>
            Clears all the Namespaces and Triples for the given Graph from the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.GetNSPrefixID(System.String)">
            <summary>
            Looks up the ID for a Namespace Prefix from the Database adding it to the Database if necessary
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.GetNSUriID(System.Uri)">
            <summary>
            Looks up the ID for a Namespace Uri from the Database adding it to the Database if necessary
            </summary>
            <param name="u">Namespace Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.Close(System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.ExecuteQuery(System.String,System.Data.DataTable)">
            <summary>
            Executes a Query SQL Command against the database and fills the supplied DataTable with the results
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <param name="data">DataTable to fill with results</param>
            <remarks>Allows for queries which wish to strongly type the results for quicker reading</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.EscapeString(System.String)">
            <summary>
            Escapes Strings in a manner appropriate to the underlying Database
            </summary>
            <param name="text">String to escape</param>
            <returns>Escaped String</returns>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.LoadNodeIDMap">
            <summary>
            Loads the Node Hash to ID Map from the Database and determines the next available Node ID
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.LoadTripleIDMap">
            <summary>
            Loads the Triple Hash to ID Map from the Database and determines the next available Triple ID
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MicrosoftSqlStoreManager.Dispose">
            <summary>
            Disposes of a Manager, Manager state will be preseved if <see cref="!:MicrosoftSqlStoreManager.PreserveState">PreserveState</see> was previously set to true
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the MySQL Server Store Manager
            </summary>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
            <remarks>Assumes the Database is on the <strong>localhost</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the MySQL Server Store Manager
            </summary>
            <param name="server">Server</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the MySQL Server Store Manager
            </summary>
            <param name="server">Server</param>
            <param name="port">Port</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.ExecuteQuery(System.String,System.Data.DataTable)">
            <summary>
            Executes a Query SQL Command against the database and fills the supplied DataTable with the results
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <param name="data">DataTable to fill with results</param>
            <remarks>Allows for queries which wish to strongly type the results for quicker reading</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.MySqlStoreManager.EscapeString(System.String)">
            <summary>
            Escapes Strings in a manner appropriate to the underlying Database
            </summary>
            <param name="text">String to escape</param>
            <returns>Escaped String</returns>
        </member>
        <member name="T:VDS.RDF.Web.GraphHandler">
            <summary>
            HTTP Handler for serving Graphs in ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to serve a Graph at a specific fixed URL.  The Graph being served to the user in one of their acceptable MIME types if possible, if they don't accept any MIME type we can serve then they get a 406 Not Acceptable
            </para>
            <para>
            If you have a Graph where you use slash URIs under this URL and you want those URIs to resolve to the same Graph then you should use the <see cref="T:VDS.RDF.Web.WildcardGraphHandler">WildcardGraphHandler</see> instead
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Graph to be served:
            <code>
            &lt;dotnetrdf:/folder/graph&gt; a dnr:HttpHandler ;
                                            dnr:type "VDS.RDF.Web.GraphHandler" ;
                                            dnr:usingGraph _:graph .
                                            
            _:graph a dnr:Graph ;
                    dnr:type "VDS.RDF.Graph" ;
                    dnr:fromFile "yourGraph.rdf" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Web.BaseGraphHandler">
            <summary>
            Abstract base class for HTTP Handlers for serving Graphs in ASP.Net applications
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.BaseGraphHandler._config">
            <summary>
            Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseGraphHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes the request by loading the Configuration in order to obtain the Graph to be served and then serving it to the client
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseGraphHandler.ProcessGraph(VDS.RDF.IGraph)">
            <summary>
            Method which can be used to alter the Graph before it is served
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseGraphHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Abstract method in which concrete implementations must load and return their Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseGraphHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Abstract method in which concrete implementations may update their Configuration post-request processing if necessary
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="P:VDS.RDF.Web.BaseGraphHandler.IsReusable">
            <summary>
            Gets that the Handler is reusable
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.GraphHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handlers configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.GraphHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handlers configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.ISparqlHttpProtocolProcessor">
            <summary>
            Interface for SPARQL Uniform HTTP Protocol for Graph Management processors
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ISparqlHttpProtocolProcessor.ProcessGet(System.Web.HttpContext)">
            <summary>
            Processes a GET operation which should retrieve a Graph from the Store and return it
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ISparqlHttpProtocolProcessor.ProcessPost(System.Web.HttpContext)">
            <summary>
            Processes a POST operation which should add triples to a Graph in the Store
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ISparqlHttpProtocolProcessor.ProcessPut(System.Web.HttpContext)">
            <summary>
            Processes a PUT operation which should save a Graph to the Store completely replacing any existing Graph with the same URI
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ISparqlHttpProtocolProcessor.ProcessDelete(System.Web.HttpContext)">
            <summary>
            Processes a DELETE operation which delete a Graph from the Store
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommandType">
            <summary>
            Possible SPARQL Update Command Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.InsertData">
            <summary>
            Command inserts data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.DeleteData">
            <summary>
            Command deletes data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Insert">
            <summary>
            Command inserts data and may be based upon a template
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Delete">
            <summary>
            Command deletes data and may be based upon a template
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Modify">
            <summary>
            Command modifies data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Load">
            <summary>
            Command loads a graph into the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Clear">
            <summary>
            Command clears a graph in the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Create">
            <summary>
            Command creates a Graph in the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Drop">
            <summary>
            Command removes a Graph from the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommand">
            <summary>
            Base Class of SPARQL Update Commands
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType)">
            <summary>
            Creates a new SPARQL Update Command
            </summary>
            <param name="type">Command Type</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command Set using the given Update Processor
            </summary>
            <param name="processor">Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommand.CommandType">
            <summary>
            Gets the Type of this Command
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.LeviathanProtocolProcessor">
            <summary>
            A processor for the SPARQL Uniform HTTP Protocol which operates by using the libraries in-memory Leviathan SPARQL engine and converting protocol actions to SPARQL Query/Update commands as appropriate
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor">
            <summary>
            A processor for the SPARQL Uniform HTTP Protocol which operates by translating the requests into SPARQL Query/Update commands as specified by the SPARQL Uniform HTTP Protocol specification and passing the generated commands to a <see cref="T:VDS.RDF.Update.ISparqlUpdateProcessor">ISparqlUpdateProcessor</see> which will handle the actual application of the updates
            </summary>
            <remarks>
            The conversion from HTTP operation to SPARQL Query/Update is as defined in the <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL 1.1 Uniform HTTP Protocol for Managing RDF Graphs</a> specification
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.BaseProtocolProcessor">
            <summary>
            Abstract Base class for SPARQL Uniform HTTP Protocol for Graph Management implementations
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ProcessGet(System.Web.HttpContext)">
            <summary>
            Processes a GET operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ProcessPost(System.Web.HttpContext)">
            <summary>
            Processes a POST operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ProcessPut(System.Web.HttpContext)">
            <summary>
            Processes a PUT operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ProcessDelete(System.Web.HttpContext)">
            <summary>
            Processes a DELETE operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ResolveGraphUri(System.Web.HttpContext)">
            <summary>
            Gets the Graph URI that the request should affect
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ResolveGraphUri(System.Web.HttpContext,VDS.RDF.IGraph)">
            <summary>
            Gets the Graph URI that the request should affect
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Graph parsed from the request body</param>
            <returns></returns>
            <remarks>
            The Graph parameter may be null in which case the other overload of this method will be invoked
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.BaseProtocolProcessor.ParsePayload(System.Web.HttpContext)">
            <summary>
            Gets the Graph which can be parsed from the request body
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
            <remarks>
            In the event that there is no request body a null will be returned
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor.#ctor(VDS.RDF.Query.ISparqlQueryProcessor,VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Creates a new Protocol to Update Processor
            </summary>
            <param name="queryProcessor">Query Processor</param>
            <param name="updateProcessor">Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor.ProcessGet(System.Web.HttpContext)">
            <summary>
            Processes a GET operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor.ProcessPost(System.Web.HttpContext)">
            <summary>
            Processes a POST operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor.ProcessPut(System.Web.HttpContext)">
            <summary>
            Processes a PUT operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.ProtocolToUpdateProcessor.ProcessDelete(System.Web.HttpContext)">
            <summary>
            Processes a DELETE operation
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.LeviathanProtocolProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Protocol Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.InsertDataCommand">
            <summary>
            Represents the SPARQL Update INSERT DATA command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT DATA command
            </summary>
            <param name="pattern">Pattern containing concrete Triples to insert</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertDataCommand.DataPattern">
            <summary>
            Gets the Data Pattern containing Triples to insert
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PathTransformContext">
            <summary>
            Transform Context class that is used in the Path to Algebra Transformation process
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Path Transform Context
            </summary>
            <param name="start">Subject that is the start of the Path</param>
            <param name="end">Object that is the end of the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.ToAlgebra">
            <summary>
            Returns the BGP that the Path Transform produces
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.GetNextTemporaryVariable">
            <summary>
            Gets the next available temporary variable
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.AddTriplePattern(VDS.RDF.Query.Patterns.TriplePattern)">
            <summary>
            Adds a Triple Pattern to the Path Transform
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.ResetObject">
            <summary>
            Resets the current Object to be the end Object of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Subject">
            <summary>
            Gets/Sets the Subject of the Triple Pattern at this point in the Path Transformation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Object">
            <summary>
            Gets/Sets the Object of the Triple Pattern at this point in the Path Transformation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Top">
            <summary>
            Gets/Sets whether this is the Top Level Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PotentialPath">
            <summary>
            Class representing a potential path used during the evaluation of complex property paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new Potential Path
            </summary>
            <param name="start">Start Point of the Path</param>
            <param name="current">Current Point on the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Creates a new Potential Path which is a copy of an existing Path
            </summary>
            <param name="p">Potentuak Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.GetHashCode">
            <summary>
            Gets the Hash Code for the potential path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.Equals(System.Object)">
            <summary>
            Checks whether the other object is an equivalent potential path
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.ToString">
            <summary>
            Gets the String representation of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Start">
            <summary>
            Gets the Start of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Current">
            <summary>
            Gets/Sets the Current Point of the Path - in the case of a complete Path this is the end of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsComplete">
            <summary>
            Gets/Sets whether the Path is complete
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsDeadEnd">
            <summary>
            Gets/Sets whether the Path is a dead-end
            </summary>
            <remarks>
            <para>
            This may be useful information as it can help stop us uneccessarily regenerating partial paths which are dead ends
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsPartial">
            <summary>
            Gets/Sets whether the Path is Partial
            </summary>
            <remarks>
            While this may seem something of a misnomer what this represents is that the path is only part of the overall path so in the case of a sequence path we'll make all incomplete paths from the first part of the sequence as partial so they can't be themselves completed but they can be used to form complete paths
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Length">
            <summary>
            Gets/Sets the Length of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Cardinality">
            <summary>
            Represents a Cardinality restriction on a Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseUnaryPath">
            <summary>
            Abstract Base Class for Unary Path operators
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ISparqlPath">
            <summary>
            Represents a Path expression in SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ISparqlPath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Path Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ISparqlPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts the Path to an Algebra expression
            </summary>
            <param name="context">Transform Context</param>
            <returns></returns>
            <remarks>
            If the Path is not simple then this function will throw an error since there is no Algebra transform for the Path
            </remarks>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the path is non-simple and therefore there is no Algebra transform</exception>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ISparqlPath.IsSimple">
            <summary>
            Gets whether the Path is a Simple Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ISparqlPath.AllowsZeroLength">
            <summary>
            Gets whether the Path allows for zero-length Paths
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseUnaryPath._path">
            <summary>
            Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Unary Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path using the given Path Evaluation Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Algebra Transform of the Path
            </summary>
            <param name="context">Transform Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseUnaryPath.IsSimple">
            <summary>
            Gets whether the path is simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseUnaryPath.AllowsZeroLength">
            <summary>
            Gets whether the Path permits zero-length paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Cardinality.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Cardinality Restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Cardinality.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Cardinality.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Throws an error since non-simple Paths cannot be transformed to Algebra expressions
            </summary>
            <param name="context">Transform Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Cardinality.IsSimple">
            <summary>
            Gets whether the path is simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.FixedCardinality">
            <summary>
            Represents a Fixed Cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new Fixed Cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">N</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Path transform to an Algebra expression
            </summary>
            <param name="context">Transform Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.FixedCardinality.IsSimple">
            <summary>
            Returns true since fixed cardinalities are simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrMore">
            <summary>
            Represents a Zero or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.IsSimple">
            <summary>
            Zero or More cardinality restrictions are not simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.AllowsZeroLength">
            <summary>
            Returns that this Path allows zero-length paths
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrOne">
            <summary>
            Represents a Zero or One cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero or One cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.IsSimple">
            <summary>
            Zero or One cardinality restrictions are not simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.AllowsZeroLength">
            <summary>
            Returns that this Path allows zero-length paths
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.OneOrMore">
            <summary>
            Represents a One or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new One or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evalutes the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.OneOrMore.IsSimple">
            <summary>
            One or More cardinality restrictions are not simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NOrMore">
            <summary>
            Represents a N or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new N or More cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NOrMore.IsSimple">
            <summary>
            N or More cardinality restrictions are not simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroToN">
            <summary>
            Represents a Zero to N cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new Zero to N cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.IsSimple">
            <summary>
            Zero to N cardinality restrictions are not simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.AllowsZeroLength">
            <summary>
            Returns that this Path allows zero-length paths
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NToM">
            <summary>
            Represents a N to M cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32,System.Int32)">
            <summary>
            Creates a new N to M cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
            <param name="m">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NToM.IsSimple">
            <summary>
            N to M cardinality restrictions are not simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanQueryProcessor">
            <summary>
            Default SPARQL Query Processor provided by the library's Leviathan SPARQL Engine
            </summary>
            <remarks>
            <para>
            The Leviathan Query Processor simply invokes the <see cref="T:VDS.RDF.Query.Algebra.ISparqlAlgebra">Evaluate</see> method of the SPARQL Algebra it is asked to process
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.ISparqlQueryProcessor">
            <summary>
            Interface for SPARQL Query Processors
            </summary>
            <remarks>
            <para>
            A SPARQL Query Processor is a class that knows how to evaluate SPARQL queries against some data source to which the processor has access
            </para>
            <para>
            The point of this interface is to allow for end users to implement custom update processors or to extend and modify the behaviour of the default Leviathan engine as required.
            </para>
            <para>
            Implementations may choose to only implement the parts relevant to them and leave the rest throwing <see cref="T:System.NotImplementedException">NotImplementedException</see>'s or similar.  For example a query processor might just implement the <see cref="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">ProcessQuery</see> method and not implement any of the algebra processing methods as it may choose to evaluate the query in it's own way or simply farm the query out to some remote query engine and not need to make/use the algebra transform.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Processes SPARQL Algebra
            </summary>
            <param name="algebra">Algebra</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessAsk(VDS.RDF.Query.Algebra.Ask)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessBGP(VDS.RDF.Query.Algebra.BGP)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessBindings(VDS.RDF.Query.Algebra.Bindings)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessExistsJoin(VDS.RDF.Query.Algebra.ExistsJoin)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessFilter(VDS.RDF.Query.Algebra.Filter)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessGraph(VDS.RDF.Query.Algebra.Graph)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessHaving(VDS.RDF.Query.Algebra.Having)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessJoin(VDS.RDF.Query.Algebra.Join)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessLeftJoin(VDS.RDF.Query.Algebra.LeftJoin)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessMinus(VDS.RDF.Query.Algebra.Minus)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessProject(VDS.RDF.Query.Algebra.Project)">
            <summary>
            Processes a Projection
            </summary>
            <param name="project">Projection</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessReduced(VDS.RDF.Query.Algebra.Reduced)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessSelect(VDS.RDF.Query.Algebra.Select)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessService(VDS.RDF.Query.Algebra.Service)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessSlice(VDS.RDF.Query.Algebra.Slice)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessUnion(VDS.RDF.Query.Algebra.Union)">
            <summary>
            Processes a Union
            </summary>
            <param name="union"></param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Query Processor
            </summary>
            <param name="query">Query</param>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Query Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Processes SPARQL Algebra
            </summary>
            <param name="algebra">Algebra</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessAsk(VDS.RDF.Query.Algebra.Ask)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessBGP(VDS.RDF.Query.Algebra.BGP)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessBindings(VDS.RDF.Query.Algebra.Bindings)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessExistsJoin(VDS.RDF.Query.Algebra.ExistsJoin)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessFilter(VDS.RDF.Query.Algebra.Filter)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessGraph(VDS.RDF.Query.Algebra.Graph)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessHaving(VDS.RDF.Query.Algebra.Having)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessJoin(VDS.RDF.Query.Algebra.Join)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessLeftJoin(VDS.RDF.Query.Algebra.LeftJoin)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessMinus(VDS.RDF.Query.Algebra.Minus)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessProject(VDS.RDF.Query.Algebra.Project)">
            <summary>
            Processes a Projection
            </summary>
            <param name="project">Projection</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessReduced(VDS.RDF.Query.Algebra.Reduced)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSelect(VDS.RDF.Query.Algebra.Select)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessService(VDS.RDF.Query.Algebra.Service)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSlice(VDS.RDF.Query.Algebra.Slice)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessUnion(VDS.RDF.Query.Algebra.Union)">
            <summary>
            Processes a Union
            </summary>
            <param name="union"></param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletService">
            <summary>
            Class representing Services provided by a Pellet Server Knowledge Base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Pellet Service instance
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object representing the Service</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletService.CreateService(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Factory method for generating concrete Pellet Service instances representing different Pellet Services
            </summary>
            <param name="t">JSON Object representing the Service</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.Name">
            <summary>
            Gets the Name of the Service
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.Endpoint">
            <summary>
            Gets the Endpoint for this Service
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.MimeTypes">
            <summary>
            Gets the Response MIME Types supported by the Service
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseHashFunction">
            <summary>
            Abstract base class for Hash Functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseUnaryExpression">
            <summary>
            Abstract base class for Unary Expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ISparqlExpression">
            <summary>
            Interface for SPARQL Expression Terms that can be used in Expression Trees while evaluating Sparql Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the SPARQL Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of the SPARQL Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in an expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseUnaryExpression._expr">
            <summary>
            The sub-expression of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Unary Expression
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of a Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <remarks>
            If this method is not overridden in derived classes the value returned is the Effective Boolean Value as a Literal Node
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of a Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <remarks>Must be implemented by derived classes</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseHashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Creates a new Hash function
            </summary>
            <param name="expr">Expression</param>
            <param name="hash">Hash Algorithm to use</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseHashFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseHashFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseHashFunction.Hash(System.String)">
            <summary>
            Computes Hashes
            </summary>
            <param name="input">Input String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseHashFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Having">
            <summary>
            Represents a Having Clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ISparqlAlgebra">
            <summary>
            Interface for classes that represent the SPARQL Algebra and are used to evaluate queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISparqlAlgebra.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Algebra in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Having Clause
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Having Clause
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Filter">
            <summary>
            Represents a Filter
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Filter
            </summary>
            <param name="pattern">Algebra the Filter applies over</param>
            <param name="filter">Filter to apply</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Filter over the results of evaluating the inner pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.ToString">
            <summary>
            Gets the String representation of the FILTER
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.MedianAggregate">
            <summary>
            Class representing MEDIAN Aggregate Functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.BaseAggregate">
            <summary>
            Abstract Base Class for Aggregate Functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.ISparqlAggregate">
            <summary>
            Interface for SPARQL Aggregates which can be used to calculate aggregates over Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ISparqlAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Aggregate to the Result Binder and returns a single Node as a Result
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ISparqlAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to the Result Binder and returns a single Node as a Result
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Enumerable of Binding IDs which the aggregate is applied over</param>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.ISparqlAggregate.Expression">
            <summary>
            Gets the Expression that the Aggregate is applied to
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Aggregates.BaseAggregate._expr">
            <summary>
            Expression that the aggregate operates over
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Aggregates.BaseAggregate._distinct">
            <summary>
            Whether a DISTINCT modifer is applied
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Base Constructor for Aggregates
            </summary>
            <param name="expr">Expression that the aggregate is over</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Base Constructor for Aggregates
            </summary>
            <param name="expr">Expression that the aggregate is over</param>
            <param name="distinct">Whether a Distinct modifer is applied</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Aggregate to the Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to the Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Enumerable of Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.BaseAggregate.Expression">
            <summary>
            Expression that the Aggregate executes over
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Median Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MedianAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.ModeAggregate">
            <summary>
            Class representing MODE Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Mode Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ModeAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NumericMaxAggregate">
            <summary>
            Class representing NMAX Aggregate Functions
            </summary>
            <remarks>
            Only operates over numeric data which is typed to one of the supported SPARQL Numeric types (integers, decimals and doubles)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Numeric Max Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMaxAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NumericMinAggregate">
            <summary>
            Class representing NMIN Aggregate Functions
            </summary>
            <remarks>
            Only operates over numeric data which is typed to one of the supported SPARQL Numeric types (integers, decimals and doubles)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Numeric Min Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NumericMinAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlBooleanParser">
            <summary>
            Parser for SPARQL Boolean results as Plain Text
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsReader">
            <summary>
            Interface for Reader Classes which parser Sparql Result Set syntaxes into Result Set objects
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from the given Stream
            </summary>
            <param name="input">Stream to read from</param>
            <param name="results">Result Set to load into</param>
            <returns></returns>
            <remarks>Should throw an error if the Result Set is not empty</remarks>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Loads a Result Set from the given File
            </summary>
            <param name="filename">File containing a Result Set</param>
            <param name="results">Result Set to load into</param>
            <returns></returns>
            <remarks>Should throw an error if the Result Set is not empty</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="filename">File to read from</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.StreamingEventGenerator">
            <summary>
            A JIT event generator for RDF/XML parsing that uses Streaming parsing to parse the events
            </summary>
            <remarks>
            Currently unimplemented stub class
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IJitEventGenerator">
            <summary>
            Interface for event generators which generate events as required during the parsing process
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IEventGenerator">
            <summary>
            Interface for Event Generators
            </summary>
            <remarks>
            <para>
            An Event Generator is a class which takes an input stream which contains XML and generates a series of events from it
            </para>
            <para>
            This interface is a marker interface which indicates that the class is an event generator, implementations should implement one of the concrete derived interfaces as appropriate to their mode of operation.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IJitEventGenerator.GetNextEvent">
            <summary>
            Causes the Event Generator to attempt to retrieve the next Event
            </summary>
            <returns></returns>
            <exception cref="T:System.IO.IOException">Thrown if there is a problem reading the input</exception>
            <exception cref="T:System.Xml.XmlException">Thrown if there is a problem with the XML being read</exception>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IJitEventGenerator.Finished">
            <summary>
            Gets whether the Event Generator has finished reading events i.e. there are no further events available
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="stream">Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.IO.Stream,System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="stream">Stream</param>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="reader">Text Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="reader">Text Reader</param>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="file">Filename</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.#ctor(System.String,System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="file">Filename</param>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.GetSettings">
            <summary>
            Initialises the XML Reader settings
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventGenerator.GetNextEvent">
            <summary>
            Gets the next event from the XML stream
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.StreamingEventGenerator.Finished">
            <summary>
            Gets whether the event generator has finished generating events
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.IriSpecsHelper">
            <summary>
            Static Helper class which can be used to validate IRIs according to <a href="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987</a>
            </summary>
            <remarks>
            Some valid IRIs may be rejected by these validating functions as the IRI specification allows character codes which are outside the range of the .Net char type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIri(System.String)">
            <summary>
            Gets whether a string matches the IRI production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIHierPart(System.String)">
            <summary>
            Gets whether a string matches the ihier-part production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIriReference(System.String)">
            <summary>
            Gets whether a string matches the IRI-reference production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsAbsoluteIri(System.String)">
            <summary>
            Gets whether a string matches the absolute-IRI production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIrelativeRef(System.String)">
            <summary>
            Gets whether a string matches the irelative-ref production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIrelativePart(System.String)">
            <summary>
            Gets whether a string matches the irelative-part production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIAuthority(System.String)">
            <summary>
            Gets whether a string matches the iauthority production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIUserInfo(System.String)">
            <summary>
            Gets whether a string matches the userinfo production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIHost(System.String)">
            <summary>
            Gets whether a string matches the ihost production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIRegName(System.String)">
            <summary>
            Gets whether a string matches the ireg-name production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPath(System.String)">
            <summary>
            Gets whether a string matches the ipath production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathAbEmpty(System.String)">
            <summary>
            Gets whether a string matches the ipath-abempty production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathAbsolute(System.String)">
            <summary>
            Gets whether a string matches the ipath-absolute production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathNoScheme(System.String)">
            <summary>
            Gets whether a string matches the ipath-noscheme production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathRootless(System.String)">
            <summary>
            Gets whether a string matches the ipath-rootless production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathEmpty(System.String)">
            <summary>
            Gets whether a string matches the ipath-empty production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegment(System.String)">
            <summary>
            Gets whether a string matches the isegment production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegmentNz(System.String)">
            <summary>
            Gets whether a string matches the isegment-nz production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegmentNzNc(System.String)">
            <summary>
            Gets whether a string matches the isegment-nz-nc production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIpChar(System.String)">
            <summary>
            Gets whether a string matches the ipchar production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIQuery(System.String)">
            <summary>
            Gets whether a string matches the iquery production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIFragment(System.String)">
            <summary>
            Gets whether a string matches the ifragment production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIUnreserved(System.Char)">
            <summary>
            Gets whether a character matches the iunreserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsUcsChar(System.Char)">
            <summary>
            Gets whether a character matches the ucschar production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
            <remarks>
            Not all strings that will match the official ucschar production will be matched by this function as the ucschar production permits character codes beyond the range of the .Net char type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsScheme(System.String)">
            <summary>
            Gets whether a string matches the scheme production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsPort(System.String)">
            <summary>
            Gets whether a string matches the port production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPLiteral(System.String)">
            <summary>
            Gets whether a string matches the IP-literal production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPvFuture(System.String)">
            <summary>
            Gets whether a string matches the IPvFuture production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPv6Address(System.String)">
            <summary>
            Gets whether a string matches the IPv6address production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsH16(System.String)">
            <summary>
            Gets whether a string matches the h16 production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsLs32(System.String)">
            <summary>
            Gets whether a string matches the ls32 production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPv4Address(System.String)">
            <summary>
            Gets whether a string matches the IPv4address production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsDecOctet(System.String)">
            <summary>
            Gets whether a string matches the dec-octet production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsPctEncoded(System.String)">
            <summary>
            Gets whether a string matches the pct-encoded production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsUnreserved(System.Char)">
            <summary>
            Gets whether a character matches the unreserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsReserved(System.Char)">
            <summary>
            Gets whether a character matches the reserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsGenDelims(System.Char)">
            <summary>
            Gets whether a character matches the gen-delims production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsSubDelims(System.Char)">
            <summary>
            Gets whether a character matches the sub-delims production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsHexDigit(System.Char)">
            <summary>
            Gets whether a character matches the HEXDIG terminal
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext">
            <summary>
            Parser Context for SPARQL Update Parser
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TokenisingParserContext">
            <summary>
            Class for Parser Contexts for Tokeniser based Parsing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.BaseParserContext">
            <summary>
            Base Class for Parser Contexts
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseParserContext._g">
            <summary>
            Graph being parsed into
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseParserContext._traceParsing">
            <summary>
            Is Parsing Traced?
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.Graph">
            <summary>
            Gets the Graph being parsed into
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.TraceParsing">
            <summary>
            Gets/Sets whether to trace parsing
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._queue">
            <summary>
            Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._traceTokeniser">
            <summary>
            Is Tokeniser traced?
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._localTokens">
            <summary>
            Local Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Parser Context with default settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether tokeniser tracing is used
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new SPARQL Update Parser Context
            </summary>
            <param name="tokeniser">Tokeniser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.CommandSet">
            <summary>
            Gets the Update Command Set that is being populated
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.ExpressionParser">
            <summary>
            Gets the Expression Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.PathParser">
            <summary>
            Gets the Path Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.QueryParser">
            <summary>
            Gets the Query Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.NamespaceMap">
            <summary>
            Gets the Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.BaseUri">
            <summary>
            Gets the Base URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ObjectFactoryFactory">
            <summary>
            Factory class for producing <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> instances from Configuration Graphs
            </summary>
            <remarks>
            <para>
            This essentially reflexive implementation allows for defining additional <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> instances that can load custom/user defined types based on user definable Configuration.  If your Configuration Graphs contain custom object factory definitions then you should call <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.AutoDetectObjectFactories(VDS.RDF.IGraph)">ConfigurationLoader.AutoDetectObjectFactories()</see> before attempting to load any Configuration.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Configuration.IObjectFactory">
            <summary>
            Interface for Object Factories which are factory classes that can create Objects based on configuration information in a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Attempts to load an Object of the given type identified by the given Node and returned as the Type that this loader generates
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Created Object</param>
            <returns>True if the loader succeeded in creating an Object</returns>
            <remarks>
            <para>
            The Factory should not throw an error if some required configuration is missing as another factory further down the processing chain may still be able to create the object.  If the factory encounters errors and all the required configuration information is present then that error should be thrown i.e. class instantiation throws an error or a call to load an object that this object requires fails.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.CanLoadObject(System.Type)">
            <summary>
            Returns whether this Factory is capable of creating objects of the given type
            </summary>
            <param name="t">Target Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ObjectFactoryFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load an Object Factory based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ObjectFactoryFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.GraphFactory">
            <summary>
            Factory class for producing Graphs from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.GraphFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Graph based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.GraphFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.StoreFactory">
            <summary>
            Factory class for producing Triple Stores from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.StoreFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Triple Store based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.StoreFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.InternalXmlWriter">
            <summary>
            Internal Writer class which is used by <see cref="T:VDS.RDF.Writing.RdfXmlTreeWriter">RdfXmlTreeWriter</see> to output the produced XML DOM Tree without having Namespace attributes on every node
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IPrettyPrintingWriter">
            <summary>
            Interface for Writers that Support Pretty Printing
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IPrettyPrintingWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing Mode should be used
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.InternalXmlWriter.Save(System.IO.TextWriter,System.Xml.XmlDocument)">
            <summary>
            Saves an XMLDocument to a given Stream
            </summary>
            <param name="output">Stream to save to</param>
            <param name="doc">XML Document to save</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.BaseResourceHandlerConfiguration">
            <summary>
            Abstract Base class for Resource Handlers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.ISQLIOParams">
            <summary>
            Interface for Store Parameters where the Parameter is a <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.IStoreParams">
            <summary>
            Marker Interface for classes which provide Parameter information to <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> and <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> implementations
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.ISQLIOParams.Manager">
            <summary>
            Gets the Manager for the Store
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.SqlIOParams">
            <summary>
            Store Parameters for Readers &amp; Writers which use SQL based storage where the main Parameter is a <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see>
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Params.SqlIOParams._manager">
            <summary>
            A SQL IO Manager
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Params.SqlIOParams._clearIfExists">
            <summary>
            Variable indicating the writers overwrite behaviour
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.SqlIOParams.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="manager">SQL IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Storage.Params.SqlIOParams.#ctor(VDS.RDF.Storage.ISqlIOManager,System.Boolean)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="manager">SQL IO Manager</param>
            <param name="clearIfExists">Whether existing Graphs of the same Uri should be removed from the Store before saving a Graph</param>
        </member>
        <member name="P:VDS.RDF.Storage.Params.SqlIOParams.Manager">
            <summary>
            Gets the SQL IO Manager
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.SqlIOParams.ClearIfExists">
            <summary>
            Gets/Sets whether Graphs from the Store being saved should completely overwrite an existing Graph of the same Uri in the Store being written to
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.ThreadedSqlIOParams">
            <summary>
            Store Parameters for multi-threaded Readers &amp; Writers which use SQL based storage where the main Parameter is a <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.ThreadedSqlIOParams.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="manager">Threaded SQL IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Storage.Params.ThreadedSqlIOParams.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager,System.Int32)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="manager">Threaded SQL IO Manager</param>
            <param name="threads">Number of Threads to use</param>
        </member>
        <member name="P:VDS.RDF.Storage.Params.ThreadedSqlIOParams.ThreadedManager">
            <summary>
            Gets the Threaded SQL IO Manager
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.ThreadedSqlIOParams.Threads">
            <summary>
            Gets the number of Threads to use
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.StreamParams">
            <summary>
            Parameters for Store Readers and Writers which read/write using a Stream
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.StreamParams.#ctor(System.String)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="filename">File to Stream to/from</param>
            <remarks>If created using this constructor then a new Reader/Writer will be generated by each call to the relevant properties</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Params.StreamParams.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="filename">File to Stream to/from</param>
            <param name="encoding">Encoding of the File</param>
            <remarks>If created using this constructor then a new Reader/Writer will be generated by each call to the relevant properties</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Params.StreamParams.#ctor(System.IO.Stream)">
            <summary>
            Creates a new set of Parameters
            </summary>
            <param name="stream">Stream to use</param>
            <remarks>If created using this constructor then theses Parameters are one use only</remarks>
        </member>
        <member name="P:VDS.RDF.Storage.Params.StreamParams.StreamReader">
            <summary>
            Gets the Stream for Reading
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.StreamParams.StreamWriter">
            <summary>
            Gets the Stream for Writing
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.StreamParams.Encoding">
            <summary>
            Gets/Sets the Encoding used for writing
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphLiteralNode">
            <summary>
            Class for representing Graph Literal Nodes which are supported in highly expressive RDF syntaxes like Notation 3
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseNode">
            <summary>
            Abstract Class for Nodes, implements the two basic properties of the INode Interface
            </summary>
        </member>
        <member name="T:VDS.RDF.INode">
            <summary>
            Interface for Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.INode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
            <remarks>Primarily provided so can do quick integer comparison to see what type of Node you have without having to do actual full blown Type comparison</remarks>
        </member>
        <member name="P:VDS.RDF.INode.Graph">
            <summary>
            Nodes belong to a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.INode.GraphUri">
            <summary>
            The Graph a Node belongs to may have a Uri
            </summary>
        </member>
        <member name="P:VDS.RDF.INode.Collides">
            <summary>
            Gets/Sets whether the Nodes Hash Code collides with other Nodes in the Graph
            </summary>
            <remarks>
            Designed for internal use only, exposed via the Interface in order to simplify implementation.  For Triples the equivalent method is protected internal since we pass a concrete class as the parameter and can do this but without switching the entire API to use <see cref="T:VDS.RDF.BaseNode">BaseNode</see> as the type for Nodes the same is not possible and this is not a change we wish to make to the API as it limits extensibility
            </remarks>
        </member>
        <member name="F:VDS.RDF.BaseNode._graph">
            <summary>
            Reference to the Graph that the Node belongs to
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._graphUri">
            <summary>
            Uri of the Graph that the Node belongs to
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._nodetype">
            <summary>
            Node Type for the Node
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._hashcode">
            <summary>
            Stores the computed Hash Code for this Node
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseNode.#ctor(VDS.RDF.IGraph,VDS.RDF.NodeType)">
            <summary>
            Base Constructor which instantiates the Graph reference, Graph Uri and Node Type of the Node
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="type">Node Type</param>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(System.Object)">
            <summary>
            Nodes must implement an Equals method
            </summary>
            <param name="obj">Object to compare against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseNode.ToString">
            <summary>
            Nodes must implement a ToString method
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Essential for the implementation of GetHashCode to work correctly, Nodes should generate a String representation that is 'unique' as far as that is possible.
            </para>
            <para>
            Any two Nodes which match via the Equals method (based on strict RDF Specification Equality) should produce the same String representation since Hash Codes are generated by calling GetHashCode on this String
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.GetHashCode">
            <summary>
            Gets a Hash Code for a Node
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Implemented by getting the Hash Code of the result of ToString for a Node prefixed with its Node Type, this is pre-computed for efficiency when a Node is created since Nodes are immutable.  See remarks on ToString for more detail.
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Triple will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">System.String.GetHashCode()</see> for further details)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.op_Equality(VDS.RDF.BaseNode,VDS.RDF.BaseNode)">
            <summary>
            The Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.op_Inequality(VDS.RDF.BaseNode,VDS.RDF.BaseNode)">
            <summary>
            The Non-Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are non-equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order)
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.INode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseNode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNode.Graph">
            <summary>
            Nodes belong to a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNode.GraphUri">
            <summary>
            Gets/Sets the Graph Uri of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNode.Collides">
            <summary>
            Gets/Sets whether the Nodes Hash Code collides with other Nodes in the Node Collection it is contained within
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.#ctor(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node in the given Graph which represents the given Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
            <param name="subgraph">Sub Graph this node represents</param>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node whose value is an empty Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.ToString">
            <summary>
            Implementation of ToString for Graph Literals which produces a String representation of the Subgraph in N3 style syntax
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of CompareTo for Graph Literals
            </summary>
            <param name="other">Node to compare to</param>
            <returns></returns>
            <remarks>
            Graph Literal Nodes are greater than Blank Nodes, Uri Nodes, Literal Nodes and Nulls
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.CompareTo(VDS.RDF.GraphLiteralNode)">
            <summary>
            Implementation of Compare To for Graph Literal Nodes
            </summary>
            <param name="other">Graph Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="P:VDS.RDF.GraphLiteralNode.SubGraph">
            <summary>
            Gets the Subgraph that this Node represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokenQueue">
            <summary>
            Basic Token Queue which provides no Buffering except in the sense that it queues all possible Tokens when the InitialiseBuffer method is called
            </summary>
            <remarks>This is the recommended Token Queue and the one used by default in the Parser implementations</remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseTokenQueue">
            <summary>
            Abstract base implementation of a Token Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ITokenQueue">
            <summary>
            Interface for implementing Token Queues which provide Bufferable wrappers to Tokenisers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Dequeue">
            <summary>
            Removes the first Token from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Token to the end of the Queue
            </summary>
            <param name="t">Token to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Clear">
            <summary>
            Clears the Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Buffer
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Initialises the Buffer and sets the Buffering Level
            </summary>
            <param name="amount">Buffering Amount</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tokeniser">
            <summary>
            Tokeniser that this is a Queue for
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Count">
            <summary>
            Gets the number of Tokens in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tokens">
            <summary>
            Gets the underlying Queue of Tokens
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tracing">
            <summary>
            Gets/Sets whether Tokeniser Tracing should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.LastTokenType">
            <summary>
            Gets the Token Type of the last Token dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._tokeniser">
            <summary>
            Tokeniser used to fill the Token Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._tracing">
            <summary>
            Variable indicating whether Tokeniser Tracing is enabled
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._lasttokentype">
            <summary>
            Type of Last Token dequeued
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Dequeue">
            <summary>
            Abstract Definition of Interface Method
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Peek">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Clear">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.InitialiseBuffer">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Abstract Definition of Interface Method
            </summary>
            <param name="amount">Buffering Amount</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tokeniser">
            <summary>
            Sets the Tokeniser used by the Queue
            </summary>
            <remarks>Setting the Tokeniser causes the Queue to clear itself</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Count">
            <summary>
            Abstract Definition of Interface Property
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tokens">
            <summary>
            Abstract Definition of Interface Property
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tracing">
            <summary>
            Gets/Sets Tracing for the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.LastTokenType">
            <summary>
            Gets the Token Type of the last Token dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueue._tokens">
            <summary>
            Internal Queue object which this class is a wrapper around
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.#ctor">
            <summary>
            Creates a new Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Token Queue with the given Tokeniser
            </summary>
            <param name="tokeniser">Tokeniser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Dequeue">
            <summary>
            Removes and returns the first Token from the Queue
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Token to the end of the Queue
            </summary>
            <param name="t">Token to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Clear">
            <summary>
            Empties the Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Token Queue Buffer
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Initialises the Token Queue Buffer to the set Buffer Amount
            </summary>
            <param name="amount">Amount of Tokens to Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.PrintTrace(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Internal Helper Method for Tokeniser Tracing
            </summary>
            <param name="t"></param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.TokenQueue.Count">
            <summary>
            Gets the number of Tokens in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.TokenQueue.Tokens">
            <summary>
            Gets the underlying Queue of Tokens
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue">
            <summary>
            Token Queue which is not backed by a Tokeniser
            </summary>
            <remarks>
            Designed to be explicitly populated with Tokens for when a Parser needs to be invoked on a subset of the overall Tokens
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.#ctor">
            <summary>
            Creates a new non-Tokenised Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.Dequeue">
            <summary>
            Removed and returns the first Token from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Buffer by doing nothing since there is no buffering on this Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BufferedTokenQueue">
            <summary>
            A Buffered Queue for a Tokeniser which synchronously buffers a number of Tokens when the Queue is accessed and nothing is Buffered
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BufferedTokenQueue._bufferAmount">
            <summary>
            Variable storing the Buffer Size
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Buffered Queue for the given Tokeniser
            </summary>
            <param name="tokeniser">Tokeniser to Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.#ctor">
            <summary>
            Creates a new Buffered Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.Dequeue">
            <summary>
            Gets the next Token in the Queue and removes it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.Peek">
            <summary>
            Gets the next Token in the Queue without removing it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.InitialiseBuffer">
            <summary>
            Causes the Buffer to be filled using the Default Buffering level of 10
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Causes the Buffer to be filled and sets the Buffering level for the Queue
            </summary>
            <param name="amount">Number of Tokens to Buffer</param>
            <remarks>If a Buffer amount of less than zero is given then Buffer size will stay at default size (10) or existing size if it's previously been set</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.BufferInternal">
            <summary>
            Internal Helper Method which performs the Buffering
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue">
            <summary>
            An Asynchronous version of <see cref="T:VDS.RDF.Parsing.Tokens.BufferedTokenQueue">BufferedTokenQueue</see> which automatically Buffers as many Tokens as possible in a Background thread
            </summary>
            <remarks>
            Periodic instablility is fixed to the best of my knowledge, it is still recommended to use a <see cref="T:VDS.RDF.Parsing.Tokens.BufferedTokenQueue">BufferedTokenQueue</see> or the basic <see cref="T:VDS.RDF.Parsing.Tokens.TokenQueue">TokenQueue</see>.  This implementation offers little/no performance improvement over the other types of Token Queue.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Asynchronous Buffered Queue with the given Tokeniser
            </summary>
            <param name="tokeniser">Tokeniser to Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.#ctor">
            <summary>
            Creates a new Asynchronous Buffered Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.Dequeue">
            <summary>
            Gets the next Token in the Queue and removes it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.Peek">
            <summary>
            Gets the next Token in the Queue without removing it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.BufferInternal">
            <summary>
            Internal Helper Method which starts the Background Buffering if not already running
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue.BufferBackground">
            <summary>
            Internal Thread Method which does the Background Buffering
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlVariable">
            <summary>
            Class of Sparql Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Sparql Variable
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
            <param name="isResultVar">Does this Variable appear in the Result Set?</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String)">
            <summary>
            Creates a new Sparql Variable
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Creates a new Sparql Variable which is an Aggregate
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
            <param name="aggregate">Aggregate Function</param>
            <remarks>All Aggregate Variables are automatically considered as Result Variables</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Sparql Variable which is a Projection Expression
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
            <param name="expr">Projection Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.ToString">
            <summary>
            Get the String representation of the Variable
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Name">
            <summary>
            Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsResultVariable">
            <summary>
            Gets whether the Variable appears in the Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsAggregate">
            <summary>
            Gets whether the Variable is an Aggregate 
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsProjection">
            <summary>
            Gets whether the Variable is a Projection Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Aggregate">
            <summary>
            Gets the Aggregate Function for this Variable
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Projection">
            <summary>
            Gets the Projection Expression for this Variable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlExpressionParser">
            <summary>
            Internal Class which parses SPARQL Expressions into Expression Trees
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor">
            <summary>
            Creates a new SPARQL Expression Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(VDS.RDF.Parsing.SparqlQueryParser)">
            <summary>
            Creates a new SPARQL Expression Parser which has a reference back to a Query Parser
            </summary>
            <param name="parser">Query Parser</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(System.Boolean)">
            <summary>
            Creates a new SPARQL Expression Parser
            </summary>
            <param name="allowAggregates">Whether Aggregates are allowed in Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(VDS.RDF.Parsing.SparqlQueryParser,System.Boolean)">
            <summary>
            Creates a new SPARQL Expression Parser which has a reference back to a Query Parser
            </summary>
            <param name="parser">Query Parser</param>
            <param name="allowAggregates">Whether Aggregates are allowed in Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.Parse(System.Collections.Generic.Queue{VDS.RDF.Parsing.Tokens.IToken})">
            <summary>
            Parses a SPARQL Expression
            </summary>
            <param name="tokens">Tokens that the Expression should be parsed from</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.BaseUri">
            <summary>
            Sets the Base Uri used to resolve URIs and QNames
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.NamespaceMap">
            <summary>
            Sets the Namespace Map used to resolve QNames
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.AllowAggregates">
            <summary>
            Gets/Sets whether Aggregates are permitted in Expressions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.QueryParser">
            <summary>
            Sets the Query Parser that the Expression Parser can call back into when needed
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.TriplePattern">
            <summary>
            Class for representing Triple Patterns in SPARQL Queries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BaseTriplePattern">
            <summary>
            Base class for representing all types of Triple Patterns in SPARQL queries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.ITriplePattern">
            <summary>
            Interface for Triple Patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.ITriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Query Evaluation Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.IndexType">
            <summary>
            Gets the Index type that should be used in Pattern execution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.IsAcceptAll">
            <summary>
            Gets whether the Pattern accepts all
            </summary>
            <remarks>
            Indicates that a Pattern is of the form ?s ?p ?o
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.Variables">
            <summary>
            Gets the List of Variables used in the Pattern
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.BaseTriplePattern._indexType">
            <summary>
            Stores the Index Type for the Triple Pattern
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.BaseTriplePattern._vars">
            <summary>
            Stores the list of variables that are used in the Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.CompareTo(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Compares a Triple Pattern to another Triple Pattern
            </summary>
            <param name="other">Other Triple Pattern</param>
            <returns></returns>
            <remarks>
            <para>
            The aim of this function is to sort Triple Patterns into what is hopefully an optimal order such that during execution the query space is restricted as early as possible.
            </para>
            <para>
            The basic rules of this are as follows:
            <ol>
                <li>Patterns with fewer variables should be executed first</li>
                <li>Patterns using the same variables should be executed in sequence</li>
                <li>Patterns using indexes which are considered more useful should be executed first</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.IndexType">
            <summary>
            Gets the Index Type we will use for this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.IsAcceptAll">
            <summary>
            Returns whether the Triple Pattern is an accept all
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.Variables">
            <summary>
            Gets the List of Variables used in the Pattern
            </summary>
            <remarks>
            These are sorted in alphabetical order
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IConstructTriplePattern">
            <summary>
            Interface for Triple Patterns that can be used in a CONSTRUCT pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IConstructTriplePattern.Construct(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="s">Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IConstructTriplePattern.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="s">Set</param>
            <param name="preserveBNodes">Whether Blank Nodes should be preserved as-is (default behaviour is to re-write them)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Triple Pattern
            </summary>
            <param name="subj">Subject Pattern</param>
            <param name="pred">Predicate Pattern</param>
            <param name="obj">Object Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple is accepted by this Pattern in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.GetResults(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Takes an enumerable and extracts Triples which match this pattern as results
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="ts">Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Result(VDS.RDF.Triple)">
            <summary>
            Generates a Result Set for a Triple that matches the Pattern
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="s">Set</param>
            <param name="preserveBNodes">Whether Blank Nodes should be preserved as-is or remapped (remapped is the default)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Construct(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="s">Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.ToString">
            <summary>
            Gets the String representation of this Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Subject">
            <summary>
            Subject Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Predicate">
            <summary>
            Predicate Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Object">
            <summary>
            Object Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.IsAcceptAll">
            <summary>
            Returns whether the Triple Pattern is an accept all
            </summary>
            <remarks>
            True if all three Pattern Items are <see cref="T:VDS.RDF.Query.Patterns.VariablePattern">VariablePattern</see> and all the Variables names are distinct
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.GraphPattern">
            <summary>
            Class for representing Graph Patterns in Sparql Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.#ctor">
            <summary>
            Creates a new Graph Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddTriplePattern(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Adds a Triple Pattern to the Graph Pattern
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddGraphPattern(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Adds a child Graph Pattern to the Graph Pattern
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.BreakBGP">
            <summary>
            Tells the Graph Pattern that any subsequent Graph/Triple Patterns added go in a new BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.LastChildPattern">
            <summary>
            Gets the Last Child Graph Pattern of this Pattern and removes it from this Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.Optimise(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Causes the Query to be optimised if it isn't already
            </summary>
            <remarks>
            Variables that have occurred prior to this Pattern
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.TryReorderPatterns(System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            Tries to reorder patterns when the initial ordering is considered poor
            </summary>
            <param name="desiredVariables">Variables that are desired</param>
            <param name="start">Point at which to start looking for better matches</param>
            <param name="end">Point at which to move the better match to</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.TryPlaceFilter(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Tries to place filters at the earliest point possible i.e. the first point after which all required variables have occurred
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.TryPlaceAssignment(VDS.RDF.Query.Patterns.LetPattern)">
            <summary>
            Tries to place assignments at the earliest point possible i.e. the first point after which all required variables have occurred
            </summary>
            <param name="let">LET Assignment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.ToString">
            <summary>
            Gets the String representation of the Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.ToAlgebra">
            <summary>
            Gets the Algebra representation of the Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsOptional">
            <summary>
            Gets/Sets whether the Graph Pattern is Optional
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsFiltered">
            <summary>
            Gets/Sets whether the Graph Pattern is Filtered
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsUnion">
            <summary>
            Gets/Sets whether the Graph Pattern is a Union of its Child Graph Patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsGraph">
            <summary>
            Gets/Sets whether the Graph Pattern operates on a specific Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsEmpty">
            <summary>
            Gets whether this is an empty Graph Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsExists">
            <summary>
            Gets/Sets whether the Graph Pattern is an EXISTS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsNotExists">
            <summary>
            Gets/Sets whether the Graph Pattern is a NOT EXISTS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsMinus">
            <summary>
            Gets/Sets whether the Graph Pattern is a MINUS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsService">
            <summary>
            Gets/Sets whether the Graph Pattern is a SERVICE clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsOptimised">
            <summary>
            Gets whether Optimisation has been applied to this query
            </summary>
            <remarks>
            Optimisation involves the reordering of Triple Patterns and placement of FILTERs in an attempt to improve performance
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.Filter">
            <summary>
            Gets/Sets the FILTER that applies to this Graph Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.GraphSpecifier">
            <summary>
            Gets/Sets the Graph Specifier that applies to this Graph Pattern
            </summary>
            <remarks>
            This property is also used internally for SERVICE specifiers to save adding an additional property unnecessarily
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.HasChildGraphPatterns">
            <summary>
            Checks whether this Pattern has any Child Graph Patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.ChildGraphPatterns">
            <summary>
            Gets the Child Graph Patterns of this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.TriplePatterns">
            <summary>
            Gets the Triple Patterns in this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsSimplifiable">
            <summary>
            Gets whether this Pattern can be simplified
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsSubQuery">
            <summary>
            Gets whether this Graph Pattern is a Sub-query which can be simplified
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.UnplacedFilters">
            <summary>
            Gets the list of Filters that apply to this Graph Pattern which will be placed appropriately later
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.UnplacedAssignments">
            <summary>
            Gets the list of LET assignments that are in this Graph Pattern which will be placed appropriately later
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.Variables">
            <summary>
            Gets the Variab
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlJsonParser">
            <summary>
            Parser for SPARQL Results JSON Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.#ctor">
            <summary>
            Creates a new Sparql Result Json Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Loads a Result Set from a File
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="filename">File to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Parse(System.IO.StreamReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the Stream as Json
            </summary>
            <param name="input">Input Stream</param>
            <param name="results">Result Set to parse into</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseResultSetObject(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the top level Json Object which represents the overall Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeader(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the 'head' property of the top level Json Object which represents the Header of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeaderObject(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the Header Object of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeaderProperties(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the Properties of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseVariables(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the 'vars' property of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseLink(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the 'link' property of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBody(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the Body of the Result Set which may be either a 'results' or 'boolean' property of the top level Json Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseResults(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the Results Object of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBindings(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the 'bindings' property of the Results Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBinding(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses a Binding Object which occurs in the array of Bindings
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBoundVariable(Newtonsoft.Json.JsonTextReader,System.String,VDS.RDF.Query.SparqlResult)">
            <summary>
            Parser method which parses a Bound Variable Object which occurs within a Binding Object
            </summary>
            <param name="reader">Json Text Reader</param>
            <param name="var">Variable Name</param>
            <param name="r">Result Object that is being constructed from the Binding Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBoolean(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parser method which parses the 'boolean' property of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Error(Newtonsoft.Json.JsonTextReader,System.String)">
            <summary>
            Helper method for raising Error messages with attached Line Information
            </summary>
            <param name="reader">Json Text Reader being used to parse the Result Set</param>
            <param name="message">Error Message</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.StoreGraph">
            <summary>
            A Graph which represents a Graph of a given Uri retrieved from some arbitrary Store
            </summary>
            <remarks>
            <para>
            Any Changes to this Graph locally are persisted to the underlying Storage using a Background Thread. This live persistence is only provided for <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> implementations which return <em>true</em> as the value of their <see cref="P:VDS.RDF.Storage.IGenericIOManager.UpdateSupported">UpdateSupported</see> property, otherwise persistence only occurs when the Graph is disposed of by using the <see cref="M:VDS.RDF.Storage.IGenericIOManager.SaveGraph(VDS.RDF.IGraph)">SaveGraph</see> method of the manager.
            </para>
            <para>
            If a process using this class terminates unexpectedly some changes may be lost.
            </para>
            <para>
            This class is designed to be <strong>completely</strong> agnostic of it's underlying Storage.  The Storage may be SQL Based for example a <see cref="T:VDS.RDF.Storage.MicrosoftSqlStoreManager">MicrosoftSqlStoreManager</see> supports <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> and can be used with this class though there are specific classes like <see cref="T:VDS.RDF.SqlGraph">SqlGraph</see> for SQL backed stores and a separate interface <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> dedicated to them.  The Storage may equally be some kind of Native RDF Storage such as a <see cref="T:VDS.RDF.Storage.VirtuosoManager">VirtuosoManager</see> which stores data in a Native Quad Store or a <see cref="T:VDS.RDF.Storage.TalisPlatformConnector">TalisPlatformConnector</see> which connects to the Talis paltform to access their SaaS solution for RDF Storage.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.BackgroundPersistedGraph">
            <summary>
            Base Class for Graphs which have their persistence to some underlying Store handled by a background thread
            </summary>
            <remarks>
            This class provides a useful general base class for Graphs which are based on some underlying Storage where the persistence to the Store can be done asychronously.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Graph">
            <summary>
            Class for representing RDF Graphs
            </summary>
            <threadsafety instance="false">Safe for multi-threaded read-only access but unsafe if one/more threads may modify the Graph by using the <see cref="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple)">Assert</see>, <see cref="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple)">Retract</see> or <see cref="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph)">Merge</see> methods</threadsafety>
        </member>
        <member name="T:VDS.RDF.BaseGraph">
            <summary>
            Abstract Base Implementation of the <see cref="T:VDS.RDF.IGraph">IGraph</see> interface
            </summary>
        </member>
        <member name="T:VDS.RDF.IGraph">
            <summary>
            Interface for RDF Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the Graph
            </summary>
            <param name="ts">List of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts an array of Triples in the Graph
            </summary>
            <param name="ts">Array of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts an Enumerable of Triples in the Graph
            </summary>
            <param name="ts">An Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts an Array of Triples from the Graph
            </summary>
            <param name="ts">Array of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the Graph
            </summary>
            <param name="ts">List of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts an Enumerable of Triples from the Graph
            </summary>
            <param name="ts">Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Clear">
            <summary>
            Retracts all Triples from the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateBlankNode(System.String)">
            <summary>
            Creates a Blank Node with the given Node ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateBlankNode">
            <summary>
            Creates a Blank Node with a new automatically generated ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetNextBlankNodeID">
            <summary>
            Gets the next available auto-assigned Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a Graph Literal Node which represents the given Subgraph
            </summary>
            <param name="subgraph">Subgraph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node which represents the empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier for the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateUriNode">
            <summary>
            Creates a Uri Node that corresponds to the Base Uri of the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateUriNode(System.String)">
            <summary>
            Creates a Uri Node for the given QName
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateUriNode(System.Uri)">
            <summary>
            Creates a Uri Node for the given Uri
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetBlankNode(System.String)">
            <summary>
            Selects the Blank Node with the given ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Selects the Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String)">
            <summary>
            Selects the Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Selects the Literal Node with the given Value and DataType
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Nodes that meet the criteria of a given ISelector
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors where the results of each Selector influence the next selector and selection at each stage is over the entire Graph
            </summary>
            <param name="firstSelector">First Selector in the Chain</param>
            <param name="selectorChain">Dependent Selectors which form the rest of the Chain</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors where each Selector is independent and selection at each stage is over the results of the previous selection stages
            </summary>
            <param name="selectorChain">Chain of Independent Selectors</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Selects all Triples which meet the criteria of an ISelector
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Object Node meets the criteria of an ISelector
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Predicate meets the criteria of an ISelector
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Subject meets the criteria of an ISelector
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetUriNode(System.String)">
            <summary>
            Selects the Uri Node with the given QName
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetUriNode(System.Uri)">
            <summary>
            Selects the Uri Node with the given Uri
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples meeting the criteria of an ISelector can be found
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple is in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges the given Graph into this Graph
            </summary>
            <param name="g">Graph to merge</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges the given Graph into this Graph
            </summary>
            <param name="g">Graph to merge</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether a Graph is equal to another Graph and if so returns the mapping of Blank Nodes
            </summary>
            <param name="g">Graph to compare with</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.ResolveQName(System.String)">
            <summary>
            Resolves a QName into a Uri using the Namespace Map and Base Uri of this Graph
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.IGraph.BaseUri">
            <summary>
            Gets/Sets the Base Uri for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.Nodes">
            <summary>
            Gets the Node Collection for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.Triples">
            <summary>
            Gets the Triple Collection for the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._triples">
            <summary>
            Collection of Triples in the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._nodes">
            <summary>
            Collection of Subject &amp; Object Nodes in the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._nsmapper">
            <summary>
            Namespace Mapper
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._baseuri">
            <summary>
            Base Uri of the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._bnodemapper">
            <summary>
            Blank Node ID Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.#ctor">
            <summary>
            Creates a new Base Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts multiple Triples in the Graph
            </summary>
            <param name="ts">Array of Triples to add</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts multiple Triples from the Graph
            </summary>
            <param name="ts">Array of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the graph
            </summary>
            <param name="ts">List of Triples to retract from the Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Clear">
            <summary>
            Clears all Triples from the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateBlankNode">
            <summary>
            Creates a New Blank Node with an auto-generated Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateBlankNode(System.String)">
            <summary>
            Creates a New Blank Node with a user-defined Blank Node ID
            </summary>
            <param name="nodeId">Node ID to use</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String)">
            <summary>
            Creates a New Literal Node with the given Value
            </summary>
            <param name="literal">String value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a New Literal Node with the given Value and Language Specifier
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">Language Specifier of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a new Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri of the Data Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode">
            <summary>
            Creates a new Uri Node that refers to the Base Uri of the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode(System.Uri)">
            <summary>
            Creates a new Uri Node with the given Uri
            </summary>
            <param name="uri">Uri for the Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode(System.String)">
            <summary>
            Creates a new Uri Node with the given QName
            </summary>
            <param name="qname">QName for the Node</param>
            <returns></returns>
            <remarks>Internally the Graph will resolve the QName to a full Uri, throws an RDF Exception when this is not possible</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateGraphLiteralNode">
            <summary>
            Creates a new Graph Literal Node with its value being an Empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node with its value being the given Subgraph
            </summary>
            <param name="subgraph">Subgraph this Node represents</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetBlankNode(System.String)">
            <summary>
            Returns the Blank Node with the given Identifier
            </summary>
            <param name="nodeId">The Identifier of the Blank Node to select</param>
            <returns>Either the Blank Node or null if no Node with the given Identifier exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Returns the LiteralNode with the given Value in the given Language if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="langspec">The Language Specifier for the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Language Specifier exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String)">
            <summary>
            Returns the LiteralNode with the given Value if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value exists</returns>
            <remarks>The LiteralNode in the Graph must have no Language or DataType set</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Returns the LiteralNode with the given Value and given Data Type if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="datatype">The Uri for the Data Type of the Literal to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Data Type exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Nodes according to some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Nodes</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by the final Selector in the Chain (where the results of each Selector are used to initialise the next Selector in the chain and selection applied to the whole Graph each time)
            </summary>
            <param name="firstSelector">Selector Class which does the initial Selection</param>
            <param name="selectorChain">Chain of Dependent Selectors to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filter is applied to the entire Graph but is initialised with the results of the previous Selector in the chain.  This means that something eliminated in a given step can potentially be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by all the Selectors in the Chain (with the Selectors applied in order to the result set of the previous Selector)
            </summary>
            <param name="selectorChain">Chain of Selector Classes to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filters the results of the previous.  Each application of a Selector potentially reduces the results set, anything eliminated in a given step cannot possibly be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given Uri
            </summary>
            <param name="uri">The Uri to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Gets all the Triples which meet some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triple</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Object
            </summary>
            <param name="u">The Uri to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with an Object matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Predicate matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Subject matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples Exist which match a given Selector
            </summary>
            <param name="selector">Selector Class which performs the Selection</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <remarks>The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes so they refer to the Graph they originated in</param>
            <remarks>The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            <para>
            A Graph can only be equal to another Object which is an <see cref="T:VDS.RDF.IGraph">IGraph</see>
            </para>
            <para>
            Graph Equality is determined by a somewhat complex algorithm which is explained in the remarks of the other overload for Equals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Determines whether this Graph is equal to the given Graph
            </summary>
            <param name="g">Graph to test for equality</param>
            <param name="mapping">Mapping of Blank Nodes iff the Graphs are equal and contain some Blank Nodes</param>
            <returns></returns>
            <remarks>
            <para>
            The algorithm used to determine Graph equality is based in part on a Iterative Vertex Classification Algorithm described in a Technical Report from HP by Jeremy J Carroll - <a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html">Matching RDF Graphs</a>
            </para>
            <para>
            Graph Equality is determined according to the following algorithm:
            </para>
            <ol>
            <li>If the given Graph is null Graphs are not equal</li>
            <li>If the given Graph is this Graph (as determined by Reference Equality) then Graphs are equal</li>
            <li>If the Graphs have a different number of Triples they are not equal</li>
            <li>Declare a list of Triples which are the Triples of the given Graph called <em>OtherTriples</em></li>
            <li>Declare two dictionaries of Nodes to Integers which are called <em>LocalClassification</em> and <em>OtherClassification</em></li>
            <li>For Each Triple in this Graph
                <ol>
                <li>If it is a Ground Triple and cannot be found and removed from <em>OtherTriples</em> then Graphs are not equal since the Triple does not exist in both Graphs</li>
                <li>If it contains Blank Nodes track the number of usages of this Blank Node in <em>LocalClassification</em></li>
                </ol>
            </li> 
            <li>If there are any Triples remaining in <em>OtherTriples</em> which are Ground Triples then Graphs are not equal since this Graph does not contain them</li>
            <li>If all the Triples from both Graphs were Ground Triples and there were no Blank Nodes then the Graphs are equal</li>
            <li>Iterate over the remaining Triples in <em>OtherTriples</em> and populate the <em>OtherClassification</em></li>
            <li>If the count of the two classifications is different the Graphs are not equal since there are differing numbers of Blank Nodes in the Graph</li>
            <li>Now build two additional dictionaries of Integers to Integers which are called <em>LocalDegreeClassification</em> and <em>OtherDegreeClassification</em>.  Iterate over <em>LocalClassification</em> and <em>OtherClassification</em> such that the corresponding degree classifications contain a mapping of the number of Blank Nodes with a given degree</li>
            <li>If the count of the two degree classifications is different the Graphs are not equal since there are not the same range of Blank Node degrees in both Graphs</li>
            <li>For All classifications in <em>LocalDegreeClassification</em> there must be a matching classification in <em>OtherDegreeClassification</em> else the Graphs are not equal</li>
            <li>Then build a possible mapping using the following rules:
                <ol>
                <li>Any Blank Node used only once should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Any Blank Node with a unique degree should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Keep a copy of the mapping up to this point as a Base Mapping for use as a fallback in later steps</li>
                <li>Build up lists of dependent pairs of Blank Nodes for both Graphs</li>
                <li>Use these lists to determine if there are any independent nodes not yet mapped.  These should be mapped to equivalent Blank Nodes in the other Graph, if this is not possible the Graphs are not equal</li>
                <li>Use the Dependencies and existing mappings to generate a possible mapping</li>
                <li>If a Complete Possible Mapping (there is a Mapping for each Blank Node from this Graph to the Other Graph) then test this mapping.  If it succeeds then the Graphs are equal</li>
                <li>Otherwise we now fallback to the Base Mapping and use it as a basis for Brute Forcing the possible solution space and testing every possibility until either a mapping works or we find the Graphs to be non-equal</li>
                </ol>
            </li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.ResolveQName(System.String)">
            <summary>
            Helper function for Resolving QNames to URIs
            </summary>
            <param name="qname">QName to resolve to a Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetNextBlankNodeID">
            <summary>
            Creates a new Blank Node ID and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Dispose">
            <summary>
            Disposes of a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.Triples">
            <summary>
            Gets the set of Triples described in this Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.Nodes">
            <summary>
            Gets the set of Nodes which make up this Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.NamespaceMap">
            <summary>
            Gets the Namespace Mapper for this Graph which contains all in use Namespace Prefixes and their URIs
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseGraph.BaseUri">
            <summary>
            Gets the current Base Uri for the Graph
            </summary>
            <remarks>
            This value may be changed during Graph population depending on whether the Concrete syntax allows the Base Uri to be changed and how the Parser handles this
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty ie. Contains No Triples or Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor">
            <summary>
            Creates a new instance of a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of a Graph with an optionally empty Namespace Map
            </summary>
            <param name="emptyNamespaceMap">Whether the Namespace Map should be empty</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts multiple Triples in the Graph
            </summary>
            <param name="ts">Array of Triples to add</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts multiple Triples from the Graph
            </summary>
            <param name="ts">Array of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the graph
            </summary>
            <param name="ts">List of Triples to retract from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.Graph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String)">
            <summary>
            Returns the LiteralNode with the given Value if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value exists</returns>
            <remarks>The LiteralNode in the Graph must have no Language or DataType set</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String,System.String)">
            <summary>
            Returns the LiteralNode with the given Value in the given Language if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="langspec">The Language Specifier for the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Language Specifier exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Returns the LiteralNode with the given Value and given Data Type if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="datatype">The Uri for the Data Type of the Literal to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Data Type exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetBlankNode(System.String)">
            <summary>
            Returns the Blank Node with the given Identifier
            </summary>
            <param name="nodeId">The Identifier of the Blank Node to select</param>
            <returns>Either the Blank Node or null if no Node with the given Identifier exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Nodes according to some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Nodes</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given Uri
            </summary>
            <param name="uri">The Uri to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Gets all the Triples which meet some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triple</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Subject matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Predicate matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Object
            </summary>
            <param name="u">The Uri to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with an Object matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by all the Selectors in the Chain (with the Selectors applied in order to the result set of the previous Selector)
            </summary>
            <param name="selectorChain">Chain of Selector Classes to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filters the results of the previous.  Each application of a Selector potentially reduces the results set, anything eliminated in a given step cannot possibly be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by the final Selector in the Chain (where the results of each Selector are used to initialise the next Selector in the chain and selection applied to the whole Graph each time)
            </summary>
            <param name="firstSelector">Selector Class which does the initial Selection</param>
            <param name="selectorChain">Chain of Dependent Selectors to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filter is applied to the entire Graph but is initialised with the results of the previous Selector in the chain.  This means that something eliminated in a given step can potentially be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Internal Helper method for applying a Selector to a subset of the Triples in the Graph
            </summary>
            <param name="triples">Subset of Triples</param>
            <param name="selector">Selector Class to perform the Selection</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples Exist which match a given Selector
            </summary>
            <param name="selector">Selector Class which performs the Selection</param>
            <returns></returns>
        </member>
        <member name="F:VDS.RDF.BackgroundPersistedGraph._addedTriplesBuffer">
            <summary>
            Change Buffer for Added Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.BackgroundPersistedGraph._removedTriplesBuffer">
            <summary>
            Change Buffer for Removed Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.BackgroundPersistedGraph._persister">
            <summary>
            Thread which does the Persistence
            </summary>
        </member>
        <member name="F:VDS.RDF.BackgroundPersistedGraph._suspendPersistence">
            <summary>
            Boolean indicating whether persistence is suspended
            </summary>
            <remarks>
            Set to true during initial loading so the system does not attempt to persist the existing contents of the Graph back to Storage.  Set to false at the end of the <see cref="!:BackgroundPersistedGraph.Initialise">Initialise()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Intialise">
            <summary>
            Initialises the Thread which will manage persistence of data
            </summary>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.PersistData">
            <summary>
            Method for the Background Thread which handles persistence of data
            </summary>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Flush">
            <summary>
            Forces any changes to the Graph to be persisted to the underlying Store immediately
            </summary>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.UpdateStore">
            <summary>
            Abstract Method to be implemented by derived classes which Updates the Store
            </summary>
            <remarks>Implements should take appropriate steps to push the Updates to the underlying Store.  This will in practise be a one/two line implementation which invokes an appropriate method on some <see cref="!:IGenericIOManager">IGenericIOManager</see> or similar class.</remarks>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts multiple Triples in the Graph
            </summary>
            <param name="ts">Array of Triples to add</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>
            Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted
            </remarks>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts multiple Triples from the Graph
            </summary>
            <param name="ts">Array of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the graph
            </summary>
            <param name="ts">List of Triples to retract from the Graph</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.BackgroundPersistedGraph.Dispose">
            <summary>
            Disposes of a Background Persisted Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.StoreGraph._manager">
            <summary>
            Manager for Input/Output to and from the backing Store
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraph.#ctor">
            <summary>
            Empty Constructor for use by derived classes which don't wish to have the Graph automatically loaded
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraph.#ctor(System.Uri,VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance of a Store Graph which will contain the contents of the Graph with the given Uri
            </summary>
            <param name="graphUri">Uri of the Graph to retrieve</param>
            <param name="manager">Generic Store Manager</param>
        </member>
        <member name="M:VDS.RDF.StoreGraph.#ctor(System.String,VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance of a Store Graph which will contain the contents of the Graph with the given Uri
            </summary>
            <param name="graphUri">Uri of the Graph to retrieve</param>
            <param name="manager">Generic Store Manager</param>
        </member>
        <member name="M:VDS.RDF.StoreGraph.Intialise">
            <summary>
            Initialises the Thread which will manage persistence of data using the Generic Store Manager
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraph.Flush">
            <summary>
            Forces any changes to the Store Graph to be persisted to the underlying Store immediately
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraph.UpdateStore">
            <summary>
            Updates the store by calling the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> instances <see cref="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> method
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraph.Dispose">
            <summary>
            Disposes of a Store Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.WriteOnlyStoreGraph">
            <summary>
            Class for representing an RDF Graph which is automatically stored to some arbitrary Store as it is modified
            </summary>
            <remarks>
            <para>
            Designed for situations where you wish to write data to a Graph in the Store where the data being added is not affected by existing data in the Graph.
            </para>
            <para>
            Unlike it's parent class <see cref="T:VDS.RDF.StoreGraph">StoreGraph</see> this class will not automatically load the contents of the existing Graph when instantiated.
            </para>
            <para>
            Iterating over the Triples/Nodes of this Graph will only return those that have been added to the Graph since its instantiation.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.WriteOnlyStoreGraph.#ctor(System.Uri,VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance which will represent a write-only view of the Graph with the given URI
            </summary>
            <param name="graphUri">URI of the Graph to write to</param>
            <param name="manager">Generic Store Manager</param>
        </member>
        <member name="M:VDS.RDF.WriteOnlyStoreGraph.#ctor(System.String,VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance which will represent a write-only view of the Graph with the given URI
            </summary>
            <param name="graphUri">URI of the Graph to retrieve</param>
            <param name="manager">Generic Store Manager</param>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.IStoreWriterContext">
            <summary>
            Interface for Store Writer Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IStoreWriterContext.Store">
            <summary>
            Gets the Store being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.BaseStoreWriterContext">
            <summary>
            Base Class for Store Writer Context Objects
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseStoreWriterContext._prettyPrint">
            <summary>
            Pretty Print Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseStoreWriterContext._hiSpeedAllowed">
            <summary>
            High Speed Mode setting
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Creates a new Base Store Writer Context with default settings
            </summary>
            <param name="store">Store to write</param>
            <param name="output">TextWriter being written to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Base Store Writer Context with custom settings
            </summary>
            <param name="store">Store to write</param>
            <param name="output">TextWriter being written to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.FormatUri(System.String)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.Store">
            <summary>
            Gets the Store being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration">
            <summary>
            Abstract Base class for SPARQL Update Handler configurations
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.BaseHandlerConfiguration">
            <summary>
            Abstract Base Class for Handler Configuration
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.MinimumCacheDuration">
            <summary>
            Minimum Cache Duration setting permitted
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.MaximumCacheDuration">
            <summary>
            Maximum Cache Duration setting permitted
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration._showErrors">
            <summary>
            Whether errors are shown to the User
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration._stylesheet">
            <summary>
            Stylesheet for formatting the Query Form and HTML format results
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration._introText">
            <summary>
            Introduction Text for the Query Form
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration._expressionFactories">
            <summary>
            List of Custom Expression Factories which have been specified in the Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Base Handler Configuration which loads common Handler settings from a Configuration Graph
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.UserGroups">
            <summary>
            Gets the User Groups for the Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.ShowErrors">
            <summary>
            Gets whether Error Messages should be shown to users
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.Stylesheet">
            <summary>
            Gets the Stylesheet for formatting HTML Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.IntroductionText">
            <summary>
            Gets the Introduction Text for the Query Form
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.CacheDuration">
            <summary>
            Gets the Cache Duration in minutes to use
            </summary>
            <para>
            The SPARQL Handlers use the ASP.Net <see cref="!:Cache">Cache</see> object to cache information and they specify the caching duration as a Sliding Duration by default.  This means that each time the cache is accessed the expiration time increases again.  Set the <see cref="!:BaseQueryHandlerConfiguration.CacheSliding">CacheSliding</see> property to false if you'd prefer an absolute expiration
            </para>
            <para>
            This defaults to 15 minutes and the Handlers will only allow you to set a value between the <see cref="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.MinimumCacheDuration">MinimumCacheDuration</see> and <see cref="F:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.MaximumCacheDuration">MaximumCacheDuration</see>.  We think that 15 minutes is a good setting and we use this as the default setting unless a duration is specified explicitly.
            </para>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.CacheSliding">
            <summary>
            Gets whether Sliding Cache expiration is used
            </summary>
            <remarks>
            <para>
            The SPARQL Handlers use the ASP.Net <see cref="!:Cache">Cache</see> object to cache information and they specify the cache duration as a Sliding Duration by default.  Set this property to false if you'd prefer absolute expiration
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.HasExpressionFactories">
            <summary>
            Gets whether any Custom Expression Factories are registered in the Config for this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.BaseHandlerConfiguration.ExpressionFactories">
            <summary>
            Gets the Custom Expression Factories which are in the Config for this Handler
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration._processor">
            <summary>
            Update Processor to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration._showUpdateForm">
            <summary>
            Whether Update Form should be shown
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration._haltOnError">
            <summary>
            Whether the Handler should stop processing commands if a command errors
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration._defaultUpdate">
            <summary>
            Default Update Text for the Update Form
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Update Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration.Processor">
            <summary>
            Gets the SPARQL Update processor which is to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration.ShowUpdateForm">
            <summary>
            Gets whether to show the Update Form if no update is specified
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration.HaltOnError">
            <summary>
            Gets whether to Halt on Errors
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Update.BaseUpdateHandlerConfiguration.DefaultUpdate">
            <summary>
            Gets the Default Update for the Update Form
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Update.UpdateHandlerConfiguration">
            <summary>
            Basic implementation of a Update Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Update.UpdateHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Update Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.LetPattern">
            <summary>
            Class for representing LET Patterns in SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.#ctor(System.String,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new LET Pattern
            </summary>
            <param name="var">Variable to assign to</param>
            <param name="expr">Expression which generates a value which will be assigned to the variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a LET assignment in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.ToString">
            <summary>
            Gets the string representation of the LET assignment
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.CompareTo(VDS.RDF.Query.Patterns.LetPattern)">
            <summary>
            Compares this Let to another Let
            </summary>
            <param name="other">Let to compare to</param>
            <returns>Just calls the base compare method since that implements all the logic we need</returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.IsAcceptAll">
            <summary>
            Returns that this is not an accept all since it is a LET assignment
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.AssignExpression">
            <summary>
            Gets the Expression that is used to generate values to be assigned
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.VariableName">
            <summary>
            Gets the Name of the Variable to which values will be assigned
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Property">
            <summary>
            Represents a Predicate which is part of a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Property
            </summary>
            <param name="predicate">Predicate</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path using the given Path Evaluation Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Algebra Transform of the Path
            </summary>
            <param name="context">Transform Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Property.IsSimple">
            <summary>
            A Property is always simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Property.AllowsZeroLength">
            <summary>
            A Property does not allow zero-length paths
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Property.Predicate">
            <summary>
            Gets the Predicate this part of the Path represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.KnowledgeBase">
            <summary>
            Represents a Knowledge Base on a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.#ctor(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Creates a new Knowledge Base
            </summary>
            <param name="t">JSON Token for the Object that represents the Service</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.SupportsService(System.Type)">
            <summary>
            Gets whether a Service is supported by the Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.SupportsService(System.String)">
            <summary>
            Gets whether a Service is supported by the Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetService(System.Type)">
            <summary>
            Gets the first available implementation of the given Service Type for this Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns>
            Either the Service or a Null if the Knowledge Base does not expose a Service of the given Type
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetService(System.String)">
            <summary>
            Gets the first available Service with the given name for this Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns>
            Either the Service or a Null if the Knowledge Base does not expose a Service with the given name
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetServices(System.Type)">
            <summary>
            Gets all the available implementations of the given Service Type for this Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetServices(System.String)">
            <summary>
            Gets all the available services with the given name for this Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.Name">
            <summary>
            Gets the Name of the Knowledge Base
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.Services">
            <summary>
            Gets the Services provided by this Knowledge Base
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.AdditionExpression">
            <summary>
            Class representing Arithmetic Addition expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression">
            <summary>
            Abstract base class for Binary Arithmetic Expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseArithmeticExpression">
            <summary>
            Abstract Base class for arithmetic expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ISparqlNumericExpression">
            <summary>
            Interface for SPARQL Expression Terms that are expected to provide a Numeric value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.NumericType(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Type of a SPARQL Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.IntegerValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as an Integer as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.DecimalValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as a Decimal as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.FloatValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as a Float as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlNumericExpression.DoubleValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as a Double as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of a Sparql Expression as an Integer as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.NumericType(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric type of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.IntegerValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Integer value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.DecimalValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Decimal value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.FloatValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Float value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.DoubleValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Double value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseArithmeticExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseArithmeticExpression.Variables">
            <summary>
            Gets the Variable used in the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.IBinaryOperator">
            <summary>
            Marker interface for Expression classes which represent Binary Operators
            </summary>
            <remarks>
            Used as a marker so that the ToString() implementations can appropriately bracket expressions with binary operators so that the precedence of the expression is clear
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression._leftExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression._rightExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Binary Arithmetic Expression
            </summary>
            <param name="leftExpr"></param>
            <param name="rightExpr"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryArithmeticExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AdditionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Addition Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AdditionExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AdditionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SubtractionExpression">
            <summary>
            Class representing Arithmetic Subtraction expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SubtractionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Subtraction Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SubtractionExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SubtractionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.MultiplicationExpression">
            <summary>
            Class representing Arithmetic Multiplication expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MultiplicationExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Multiplication Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MultiplicationExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MultiplicationExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.DivisionExpression">
            <summary>
            Class representing Arithmetic Division expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.DivisionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Division Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.DivisionExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.DivisionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.MinusExpression">
            <summary>
            Class representing Unary Minus expressions (sign of numeric expression is reversed)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseUnaryArithmeticExpression">
            <summary>
            Abstract Base Class for Unary Numeric Expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseUnaryArithmeticExpression._expr">
            <summary>
            The sub-expression of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryArithmeticExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Unary Arithmetic Expression
            </summary>
            <param name="expr">Sub-expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryArithmeticExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryArithmeticExpression.Variables">
            <summary>
            Gets the enumeration of Variables used in this expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MinusExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Minus Expression
            </summary>
            <param name="expr">Expression to apply the Minus operator to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MinusExpression.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.MinusExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ExistsFunction">
            <summary>
            Represents an EXIST/NOT EXIST clause used as a Function in an Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ExistsFunction.#ctor(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Creates a new EXISTS/NOT EXISTS function
            </summary>
            <param name="pattern">Graph Pattern</param>
            <param name="mustExist">Whether this is an EXIST</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ExistsFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of this function which is a Boolean as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ExistsFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets whether a given Binding from the Input has joinable Bindings in the results of the EXISTS/NOT EXISTS pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ExistsFunction.EvaluateInternal(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Internal method which evaluates the Graph Pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <remarks>
            We only ever need to evaluate the Graph Pattern once to get the Results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ExistsFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.ExistsFunction.Variables">
            <summary>
            Gets the Variables used in this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction">
            <summary>
            Abstract Base class for unary numeric functions in the Leviathan Function Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Unary Numeric function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the Function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanNumericFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction">
            <summary>
            Abstract Base class for binary numeric functions in the Leviathan Function Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Binary Numeric function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the Function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryLeviathanNumericFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction">
            <summary>
            Represents the Leviathan lfn:sq() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Square Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction">
            <summary>
            Represents the Leviathan lfn:cube() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cube Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCubeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction">
            <summary>
            Represents the Leviathan lfn:sqrt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Square Root Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSquareRootFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction">
            <summary>
            Represents the Leviathan lfn:ln() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Natural Logarithm Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanNaturalLogFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction">
            <summary>
            Represents the Leviathan lfn:e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan E Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanEFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction">
            <summary>
            Represents the Leviathan lfn:ten() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Ten Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTenFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction">
            <summary>
            Represents the Leviathan lfn:factorial() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Factorial Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanFactorialFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction">
            <summary>
            Represents the Leviathan lfn:reciprocal() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Reciprocal Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double Value of the function as applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanReciprocalFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction">
            <summary>
            Represents the Leviathan lfn:pow() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Power Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPowerFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction">
            <summary>
            Represents the Leviathan lfn:root() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Root Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRootFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction">
            <summary>
            Represents the Leviathan lfn:log() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanLogFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction">
            <summary>
            Represents the Leviathan lfn:pythagoras() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Pythagorean Distance Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanPyathagoreanDistanceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction">
            <summary>
            Represents the Leviathan lfn:rnd() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.#ctor">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="min">Minumum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.IntegerValueInternal(System.Int64,System.Int64)">
            <summary>
            Gets the Integer Value of the function as applied to two Integers
            </summary>
            <param name="x">Integer</param>
            <param name="y">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.DecimalValueInternal(System.Decimal,System.Decimal)">
            <summary>
            Gets the Decimal Value of the function as applied to two Decimals
            </summary>
            <param name="x">Decimal</param>
            <param name="y">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.DoubleValueInternal(System.Double,System.Double)">
            <summary>
            Gets the Double Value of the function as applied to two Doubles
            </summary>
            <param name="x">Double</param>
            <param name="y">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRandomFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.TriXParser">
            <summary>
            Parser for parsing TriX (a named Graph XML format for RDF)
            </summary>
            <remarks>
            <para>
            The Default Graph (if any) will be given the special Uri <strong>trix:default-graph</strong>
            </para>
            <para>
            TriX permits Graphs to be named with Blank Node IDs, since the library only supports Graphs named with URIs these are converted to URIs of the form <strong>trix:local:ID</strong>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.IStoreReader">
            <summary>
            Interface to be implemented by Triple Store Readers
            </summary>
        </member>
        <member name="M:VDS.RDF.IStoreReader.Load(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Method for loading data into a Triple Store
            </summary>
            <param name="store">Triple Store</param>
            <param name="parameters">Parameters indicating where the Reader should read from</param>
            <exception cref="!:RdfStorageException">May be thrown if the Parameters are not valid for this Reader</exception>
        </member>
        <member name="E:VDS.RDF.IStoreReader.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TriXParser.DefaultGraphURI">
            <summary>
            Default Graph Uri for default graphs parsed from TriX input
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TriXParser.TriXNamespaceURI">
            <summary>
            Current W3C Namespace Uri for TriX
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.Load(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Loads the named Graphs from the NQuads input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="parameters">Parameters indicating the Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.Error(System.String,System.Xml.XmlNode)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="n">The Node that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.OnWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="E:VDS.RDF.Parsing.TriXParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ClearKeywordToken">
            <summary>
            Token which represents the SPARQL Update CLEAR Keyword
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseToken">
            <summary>
            Base Implementation of IToken used by all derived tokens for ease of implementation
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IToken">
            <summary>
            Interface for defining Token classes to be used in Parsing RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.TokenType">
            <summary>
            Gives some Integer representing the Token Type as understood by a specific Parser implementation
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.Value">
            <summary>
            Gives the Value of the Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.StartLine">
            <summary>
            Gives the Line at which the Token starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.EndLine">
            <summary>
            Gives the Line at which the Token ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.StartPosition">
            <summary>
            Gives the Position within the Start Line that the Token starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.EndPosition">
            <summary>
            Gives the Position within the End Line that the Token ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.Length">
            <summary>
            Gives the Length of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._tokentype">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._startline">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._endline">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._startpos">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._endpos">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._value">
            <summary>
            Variable containg the value of the Token
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Token and fills in its Values
            </summary>
            <param name="tokenType">Integer denoting the Tokens Type</param>
            <param name="value">String value that the Token represents (if any)</param>
            <param name="startLine">Line at which the Token starts</param>
            <param name="endLine">Line at which the Token ends</param>
            <param name="startPos">Column at which the Token starts</param>
            <param name="endPos">Column at which the Token ends</param>
            <remarks>All the derived classes use this Constructor to fill in the basic values of a Token</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.ToString">
            <summary>
            Gets a String representation of the Token Type and Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.GetHashCode">
            <summary>
            Gets a Hash Code for a Token
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.TokenType">
            <summary>
            Gets an arbitrary integer which indicates the Type of the Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.Value">
            <summary>
            Gets the String Value which this Token represents (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.StartLine">
            <summary>
            Gets the Line at which this Token Starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.EndLine">
            <summary>
            Gets the Line at which this Token Ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.StartPosition">
            <summary>
            Gets the Column at which this Token Starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.EndPosition">
            <summary>
            Gets the Column at which this Token Ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.Length">
            <summary>
            Gets the Length of the Tokens Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ClearKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CLEAR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CreateKeywordToken">
            <summary>
            Token which represents the SPARQL Update CREATE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CreateKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CREATE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataKeywordToken">
            <summary>
            Token which represents the SPARQL Update DATA Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DATA Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DefaultKeywordToken">
            <summary>
            Token which represents the SPARQL Update DEFAULT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DefaultKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DEFAULT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DeleteKeywordToken">
            <summary>
            Token which represents the SPARQL Update DELETE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DeleteKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DELETE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DropKeywordToken">
            <summary>
            Token which represents the SPARQL Update DROP Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DropKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DROP Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.InsertKeywordToken">
            <summary>
            Token which represents the SPARQL Update INSERT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.InsertKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new INSERT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IntoKeywordToken">
            <summary>
            Token which represents the SPARQL Update INTO Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IntoKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new INTO Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LoadKeywordToken">
            <summary>
            Token which represents the SPARQL Update LOAD Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LoadKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LOAD Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SilentKeywordToken">
            <summary>
            Token which represents the SPARQL Update SILENT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SilentKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SILENT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UsingKeywordToken">
            <summary>
            Token which represents the SPARQL Update USING Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UsingKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new USING Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.WithKeywordToken">
            <summary>
            Token which represents the SPARQL Update WITH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.WithKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new WITH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PathToken">
            <summary>
            Special Token which acts as a Placeholder for SPARQL Property Paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PathToken.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.String)">
            <summary>
            Creates a new Path Token
            </summary>
            <param name="path">Path</param>
            <param name="lengthVar">Length Variable</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.PathToken.Path">
            <summary>
            Gets the Path this Token acts as a placeholder for
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.PathToken.LengthVariable">
            <summary>
            Gets the Length Variable for this path or the empty string if one is not used
            </summary>
        </member>
        <member name="T:VDS.RDF.UnionTripleCollection">
            <summary>
            Represents a union of multiple Triple Collections
            </summary>
            <remarks>
            <para>
            The union consists of a <em>Base</em> collection which is the collection that Triples can actually be added to and deleted from and any number of additional collections which are read-only as far as the union is concerned (this does not mean they cannot be altered elsewhere by other code)
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.BaseTripleCollection">
            <summary>
            Abstract Base Class for Triple Collections
            </summary>
            <remarks>
            Designed to allow the underlying storage of a Triple Collection to be changed at a later date without affecting classes that use it.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
            <remarks>Adding a Triple that already exists should be permitted though it is not necessary to persist the duplicate to underlying storage</remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist should have no effect and give no error</remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject
            </summary>
            <param name="subj">ubject to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Predicate
            </summary>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Object
            </summary>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject Predicate pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Predicate Object pair
            </summary>
            <param name="pred">Predicate to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject Object pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Dispose">
            <summary>
            Diposes of a Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.GetEnumerator">
            <summary>
            Gets the typed Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the non-generic Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given Triple doesn't exist</exception>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.#ctor(VDS.RDF.BaseTripleCollection,VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new Union Triple Collection which is a union of two collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.#ctor(VDS.RDF.BaseTripleCollection,System.Collections.Generic.IEnumerable{VDS.RDF.BaseTripleCollection})">
            <summary>
            Creates a new Union Triple Collection which is a union of any number of collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection(s)</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the base collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Checks whether the union contains this Triple in any of the collections it comprises
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the base collection
            </summary>
            <param name="t">Triple to delete</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
            <remarks>
            This does nothing since we don't know where and how the collections we are the union of are being used and therefore to dispose of them could have unwanted/unexpected results
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.GetEnumerator">
            <summary>
            Gets the enumeration of Triples in the union
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.Count">
            <summary>
            Gets the count of Triples in this union
            </summary>
            <remarks>
            The Count is the total number of Triples, this may be different from the number of distinct triples
            </remarks>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Retrieves a Triple from the union
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the Triple is not contained in any of the collections this union comprises</exception>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.ObjectNodes">
            <summary>
            Gets the enumeration of distinct objects of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.PredicateNodes">
            <summary>
            Gets the enumeration of distinct predicates of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.SubjectNodes">
            <summary>
            Gets the enumeration of distinct subjects of Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.UnionNodeCollection">
            <summary>
            Represents a union of multiple Node Collections
            </summary>
            <remarks>
            <para>
            The union consists of a <em>Base</em> collection which is the collection that Nodes can actually be added to and deleted from and any number of additional collections which are read-only as far as the union is concerned (this does not mean they cannot be altered elsewhere by other code)
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.BaseNodeCollection">
            <summary>
            Abstract Base Class for Node Collections
            </summary>
            <remarks>Designed to allow the underlying storage of a Node Collection to be changed at a later date without affecting classes that use it</remarks>
        </member>
        <member name="M:VDS.RDF.BaseNodeCollection.Add(VDS.RDF.INode)">
            <summary>
            Adds a new Node to the Collection
            </summary>
            <param name="n">Node to add</param>
        </member>
        <member name="M:VDS.RDF.BaseNodeCollection.Contains(VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is in the Node Collection
            </summary>
            <param name="n">The Node to test</param>
            <returns>Returns True if the Node is already in the collection</returns>
        </member>
        <member name="M:VDS.RDF.BaseNodeCollection.Dispose">
            <summary>
            Disposes of a Node Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseNodeCollection.GetEnumerator">
            <summary>
            Gets the Typed Enumerator for the Node Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseNodeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the non-generic Enumerator for the Node Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseNodeCollection.BlankNodes">
            <summary>
            Gets all the Blank Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNodeCollection.Count">
            <summary>
            Gets the Number of Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNodeCollection.GraphLiteralNodes">
            <summary>
            Gets all the Graph Literal Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNodeCollection.LiteralNodes">
            <summary>
            Gets all the Literal Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNodeCollection.UriNodes">
            <summary>
            Gets all the Uri Nodes in the Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.#ctor(VDS.RDF.BaseNodeCollection,VDS.RDF.BaseNodeCollection)">
            <summary>
            Creates a new Union Node Collection which is the union of two collections
            </summary>
            <param name="baseNodes">Base Collection</param>
            <param name="additionalNodes">Additional Collection</param>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.#ctor(VDS.RDF.BaseNodeCollection,System.Collections.Generic.IEnumerable{VDS.RDF.BaseNodeCollection})">
            <summary>
            Creates a new Union Node Collection which is the union of any number of collections
            </summary>
            <param name="baseNodes">Base Collection</param>
            <param name="additionalNodes">Additional Collection(s)</param>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.Add(VDS.RDF.INode)">
            <summary>
            Adds a Node to the Base Collection
            </summary>
            <param name="n">Node to add</param>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.Contains(VDS.RDF.INode)">
            <summary>
            Gets whether any collection in the union contains the given Node
            </summary>
            <param name="n">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
            <remarks>
            This does nothing since we don't know where and how the collections we are the union of are being used and therefore to dispose of them could have unwanted/unexpected results
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionNodeCollection.GetEnumerator">
            <summary>
            Gets the enumeration of Nodes
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.UnionNodeCollection.BlankNodes">
            <summary>
            Gets the enumeration of Blank Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionNodeCollection.Count">
            <summary>
            Gets the count of Nodes in the collection
            </summary>
            <remarks>
            This is the total count of Nodes which may be greater than the count of distinct nodes
            </remarks>
        </member>
        <member name="P:VDS.RDF.UnionNodeCollection.GraphLiteralNodes">
            <summary>
            Gets the enumeration of Graph Literal Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionNodeCollection.LiteralNodes">
            <summary>
            Gets the enumeration of Literal Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionNodeCollection.UriNodes">
            <summary>
            Gets the enumeration of URI Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.HandlerDBTypes">
            <summary>
            Possible Database Types for Handlers which use a SQL Based Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerDBTypes.MSSQL">
            <summary>
            Connect to a Microsoft SQL Server based Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerDBTypes.MySQL">
            <summary>
            Connect to a MySQL based Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerDBTypes.Virtuoso">
            <summary>
            Connect to a non-native Virtuoso based Store (eg Microsoft SQL via Virtuoso)
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.HandlerStoreTypes">
            <summary>
            Possible Store Types for Handlers which use a Native Triple Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerStoreTypes.Talis">
            <summary>
            Connect to a Talis Platform Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerStoreTypes.Virtuoso">
            <summary>
            Connect to a Virtuoso Universal Server native Quad Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerStoreTypes.FourStore">
            <summary>
            Connect to a 4store Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerStoreTypes.Sesame2HTTP">
            <summary>
            Connect to any server supporting the Sesame 2 HTTP Protocol
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.HandlerStoreTypes.AllegroGraph">
            <summary>
            Connect to an AllegroGraph Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.SparqlLoadMode">
            <summary>
            Possible data Loading Modes for the <see cref="T:VDS.RDF.Web.SparqlHandler">SparqlHandler</see>
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.SparqlLoadMode.OnDemand">
            <summary>
            Graphs are loaded On Demand as required by the Query (Default)
            </summary>
            <remarks>Graphs are loaded only if they are mentioned in a FROM, FROM NAMED or GRAPH clause</remarks>
        </member>
        <member name="F:VDS.RDF.Web.SparqlLoadMode.OnDemandEnhanced">
            <summary>
            Graphs are loaded On Demand as required by the Query, Query is analysed prior to execution in order that additional pertinent Graphs can be loaded.
            </summary>
            <remarks>
            Any Uri mentioned in the query that does not correspond to a widely used Namespaces (RDF, RDFS and XML Schema plus User defined exclusions) will be looked up in the Store.  A number of Graphs using that Uri will be loaded, this may be all the Graphs that use that Uri but the Handler will decide based on the amount of work to be done in loading the Graphs.
            </remarks>
        </member>
        <member name="F:VDS.RDF.Web.SparqlLoadMode.OnDemandAggressive">
            <summary>
            Graphs are loaded On Demand as required by the Query, Query is analysed prior to execution in order that additional pertinent Graphs can be loaded.
            </summary>
            <remarks>As <see cref="F:VDS.RDF.Web.SparqlLoadMode.OnDemandEnhanced">OnDemandEnhanced</see> except that all URIs are used regardless of their Namespace</remarks>
        </member>
        <member name="F:VDS.RDF.Web.SparqlLoadMode.PreloadAll">
            <summary>
            The entire Triple Store must be loaded into memory before the Sparql Handler will function
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.SparqlLoadMode.PreloadAllAsync">
            <summary>
            The entire Triple Store will be loaded into memory asynchronously allowing the Sparql Handler to function immediately albeit with incomplete data
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.SQLResourceLookupMode">
            <summary>
            Possible Resource Lookup Modes for the <see cref="T:VDS.RDF.Web.SqlResourceHandler">SqlResourceHandler</see>
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.SQLResourceLookupMode.Graph">
            <summary>
            URIs must correspond to a Graph Uri in order that a resource can be retrieved
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.SQLResourceLookupMode.GraphOrDescribe">
            <summary>
            URIs may correspond to either a Graph Uri or must occur as a Subject in some Triples in order that a resource can be retrieved
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.SQLResourceLookupMode.Describe">
            <summary>
            URIs must occur as the Subject of some Triples in order that a resource can be retrieved
            </summary>
        </member>
        <member name="T:VDS.RDF.BlankNode">
            <summary>
            Class for representing Blank RDF Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Internal Only Constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
            <param name="nodeId">Custom Node ID to use</param>
        </member>
        <member name="M:VDS.RDF.BlankNode.Equals(System.Object)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="obj">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their internal IDs match precisely and they originate from the same Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BlankNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="other">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their internal IDs match precisely and they originate from the same Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BlankNode.ToString">
            <summary>
            Returns a string representation of this Blank Node in QName form
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNode.CompareTo(VDS.RDF.BlankNode)">
            <summary>
            Implementation of Compare To for Blank Nodes
            </summary>
            <param name="other">Blank Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="P:VDS.RDF.BlankNode.InternalID">
            <summary>
            Returns the Internal Blank Node ID this Node has in the Graph
            </summary>
            <remarks>
            Usually automatically assigned and of the form autosXXX where XXX is some number.  If an RDF document contains a Blank Node ID of this form that clashes with an existing auto-assigned ID it will be automatically remapped by the Graph using the <see cref="T:VDS.RDF.BlankNodeMapper">BlankNodeMapper</see> when it is created.
            </remarks>
        </member>
        <member name="P:VDS.RDF.BlankNode.HasAutoAssignedID">
            <summary>
            Indicates whether this Blank Node had its ID assigned for it by the Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TriGParser">
            <summary>
            Parser for parsing TriG (Turtle with Named Graphs) RDF Syntax into a Triple Store
            </summary>
            <remarks>The Default Graph (if any) will be given the special Uri <strong>trig:default-graph</strong></remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.ITraceableTokeniser">
            <summary>
            Interface for Parsers that support Tokeniser Tracing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.ITraceableTokeniser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TriGParser.DefaultGraphURI">
            <summary>
            Default Graph Uri for default graphs parsed from TriG input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.Load(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Loads the named Graphs from the TriG input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="parameters">Parameters indicating the Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.OnWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="P:VDS.RDF.Parsing.TriGParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.TriGParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.WriteOnlySqlGraph">
            <summary>
            Class for representing an RDF Graph which is automatically stored to a backing SQL Store as it is modified
            </summary>
            <remarks>
            <para>
            Designed for situations where you wish to write data to a Graph in the Store where the data being added is not affected by existing data in the Graph.
            </para>
            <para>
            Unlike it's parent class <see cref="T:VDS.RDF.SqlGraph">SqlGraph</see> this class will not automatically load the contents of the existing Graph when instantiated.  Instead it will only load the Namespaces so that you can use QNames based on the prefixes defined in the existing Graph to insert data.
            </para>
            <para>
            Iterating over the Triples/Nodes of this Graph will only return those that have been added to the Graph since its instantiation or the most recent call to <see cref="M:VDS.RDF.WriteOnlySqlGraph.Refresh">Refresh()</see>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.SqlGraph">
            <summary>
            Class for representing an RDF Graph which is automatically stored to a backing SQL Store as it is modified
            </summary>
            <threadsafety instance="false">Safe for multi-threaded read-only access but unsafe if one/more threads may modify the Graph by using the <see cref="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple)">Assert</see>, <see cref="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple)">Retract</see> or <see cref="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph)">Merge</see> methods</threadsafety>
        </member>
        <member name="F:VDS.RDF.SqlGraph._graphID">
            <summary>
            Graph ID of the Graph in the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.SqlGraph._manager">
            <summary>
            Manager that manages the SQL IO
            </summary>
        </member>
        <member name="F:VDS.RDF.SqlGraph._suspendIO">
            <summary>
            Indicates whether database IO should be suspended, used during loading of the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlGraph.#ctor">
            <summary>
            Empty Constructor for use by derived classes which don't wish to have the Graph automatically loaded
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlGraph.#ctor(System.Uri,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.SqlGraph.#ctor(System.Uri,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded.  Assumes the Database is on the localhost
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.SqlGraph.#ctor(System.Uri,VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen underlying store</param>
            <remarks>The Store may be any database for which a working <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> has been defined</remarks>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple into the Graph
            </summary>
            <param name="t">Triple to Assert</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts an Enumerable of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts an Array of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts an Enumerable of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts an Array of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Refresh">
            <summary>
            Causes the Graph to be refreshed from the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlGraph.HandleNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceAdded Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.HandleNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceModified Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.HandleNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceRemoved Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.SqlGraph.Dispose">
            <summary>
            Disposes of a SQL Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.SqlGraph.Manager">
            <summary>
            Gets the <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> used to manage database IO for this Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.WriteOnlySqlGraph.#ctor(System.Uri,VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen underlying Store</param>
        </member>
        <member name="M:VDS.RDF.WriteOnlySqlGraph.#ctor(System.Uri,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store accessible on the localhost</remarks>
        </member>
        <member name="M:VDS.RDF.WriteOnlySqlGraph.#ctor(System.Uri,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.WriteOnlySqlGraph.Refresh">
            <summary>
            Refreshes the Graphs Namespace Map from the Database
            </summary>
            <remarks>Any Triples that have been written are forgotten when refresh is called</remarks>
        </member>
        <member name="T:VDS.RDF.ThreadSafeGraph">
            <summary>
            A Thread Safe version of the <see cref="T:VDS.RDF.Graph">Graph</see> class
            </summary>
            <threadsafety instance="true">Should be safe for almost any concurrent read and write access scenario, internally managed using a <see cref="T:System.Threading.ReaderWriterLockSlim">ReaderWriterLockSlim</see>.  If you encounter any sort of Threading/Concurrency issue please report to the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">dotNetRDF Bugs Mailing List</a></threadsafety>
            <remarks>Performance will be marginally worse than a normal <see cref="T:VDS.RDF.Graph">Graph</see> but in multi-threaded scenarios this will likely be offset by the benefits of multi-threading.</remarks>
        </member>
        <member name="F:VDS.RDF.ThreadSafeGraph._lockManager">
            <summary>
            Locking Manager for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.#ctor">
            <summary>
            Creates a new Thread Safe Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts multiple Triples in the Graph
            </summary>
            <param name="ts">Array of Triples to add</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the graph
            </summary>
            <param name="ts">List of Triples to retract from the Graph</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts multiple Triples from the Graph
            </summary>
            <param name="ts">Array of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetNextBlankNodeID">
            <summary>
            Creates a new Blank Node ID and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.Dispose">
            <summary>
            Disposes of a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetBlankNode(System.String)">
            <summary>
            Returns the Blank Node with the given Identifier
            </summary>
            <param name="nodeId">The Identifier of the Blank Node to select</param>
            <returns>Either the Blank Node or null if no Node with the given Identifier exists</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetLiteralNode(System.String)">
            <summary>
            Returns the LiteralNode with the given Value if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value exists</returns>
            <remarks>The LiteralNode in the Graph must have no Language or DataType set</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Returns the LiteralNode with the given Value in the given Language if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="langspec">The Language Specifier for the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Language Specifier exists</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Returns the LiteralNode with the given Value and given Data Type if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="datatype">The Uri for the Data Type of the Literal to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Data Type exists</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Nodes according to some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Nodes</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by the final Selector in the Chain (where the results of each Selector are used to initialise the next Selector in the chain and selection applied to the whole Graph each time)
            </summary>
            <param name="firstSelector">Selector Class which does the initial Selection</param>
            <param name="selectorChain">Chain of Dependent Selectors to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filter is applied to the entire Graph but is initialised with the results of the previous Selector in the chain.  This means that something eliminated in a given step can potentially be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Gets all the Triples which meet some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triple</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Gets all Triples which are selected by all the Selectors in the Chain (with the Selectors applied in order to the result set of the previous Selector)
            </summary>
            <param name="selectorChain">Chain of Selector Classes to perform the Selection</param>
            <returns>Zero/More Triples</returns>
            <remarks>This method is used to apply a series of Selectors where each filters the results of the previous.  Each application of a Selector potentially reduces the results set, anything eliminated in a given step cannot possibly be selected by a later Selector in the Chain.</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given Uri
            </summary>
            <param name="uri">The Uri to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with an Object matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Object
            </summary>
            <param name="u">The Uri to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Predicate matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Gets all the Triples with a Subject matching some arbitrary criteria as embodied in a Selector
            </summary>
            <param name="selector">Selector class which performs the Selection</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraph.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples Exist which match a given Selector
            </summary>
            <param name="selector">Selector Class which performs the Selection</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.NonIndexedThreadSafeGraph">
            <summary>
            A Thread Safe version of the <see cref="T:VDS.RDF.Graph">Graph</see> class
            </summary>
            <threadsafety instance="true">Should be safe for almost any concurrent read and write access scenario, internally managed using a <see cref="T:System.Threading.ReaderWriterLockSlim">ReaderWriterLockSlim</see>.  If you encounter any sort of Threading/Concurrency issue please report to the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">dotNetRDF Bugs Mailing List</a></threadsafety>
            <remarks>
            <para>
            Performance will be marginally worse than a normal <see cref="T:VDS.RDF.Graph">Graph</see> but in multi-threaded scenarios this will likely be offset by the benefits of multi-threading.
            </para>
            <para>
            Since this is a non-indexed version load performance will be better but query performance better
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.NonIndexedThreadSafeGraph.#ctor">
            <summary>
            Creates a new non-indexed Thread Safe Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.IWriterContext">
            <summary>
            Interface for Writer Contexts
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.IWriterContext.FormatNode(VDS.RDF.INode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Node as a String for the given Format
            </summary>
            <param name="n">Node</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.IWriterContext.FormatUri(System.String)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.IWriterContext.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.IWriterContext.FormatChar(System.Char,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Character for the given Format
            </summary>
            <param name="c">Character</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.Graph">
            <summary>
            Gets the Graph being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext">
            <summary>
            Interface for Writer Contexts which store collection compression data
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext.Collections">
            <summary>
            Gets the mapping from Blank Nodes to Collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext.TriplesDone">
            <summary>
            Gets the Triples that should be excluded from standard output as they are part of collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.BaseWriterContext">
            <summary>
            Base Class for Writer Context Objects
            </summary>
            <remarks>
            This is not an abstract class since some writers will require only this information or possibly less
            </remarks>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._compressionLevel">
            <summary>
            Compression Level to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._prettyPrint">
            <summary>
            Pretty Printing Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._hiSpeedAllowed">
            <summary>
            High Speed Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._g">
            <summary>
            Graph being written
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._output">
            <summary>
            TextWriter being written to
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._qnameMapper">
            <summary>
            QName Output Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Base Writer Context with default settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32)">
            <summary>
            Creates a new Base Writer Context with custom settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
            <param name="compressionLevel">Compression Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Base Writer Context with custom settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
            <param name="compressionLevel">Compression Level</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.SetQNameOutputerMapper(VDS.RDF.QNameOutputMapper)">
            <summary>
            Sets the QName Mapper used
            </summary>
            <param name="mapper">QName Mapper</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatNode(VDS.RDF.INode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Node as a String for the given Format
            </summary>
            <param name="n">Node</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatUriNode(VDS.RDF.UriNode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a URI Node as a String for the given Format
            </summary>
            <param name="u">URI Node</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatUri(System.String)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatLiteralNode(VDS.RDF.LiteralNode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Literal Node as a String for the given Format
            </summary>
            <param name="l">Literal Node</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatBlankNode(VDS.RDF.BlankNode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Blank Node as a String for the given Format
            </summary>
            <param name="b">Blank Node</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.FormatChar(System.Char,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Character for the given Format
            </summary>
            <param name="c">Character</param>
            <param name="format">Format</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.Graph">
            <summary>
            Gets the Graph being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.QNameMapper">
            <summary>
            Gets the QName Output Mapper in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.ExtensionSupportingSparqlHandlerConfiguration">
            <summary>
            Class for storing SPARQL Handler Configuration where custom expression factories are supported
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.ExtensionSupportingSparqlHandlerConfiguration._expressionFactories">
            <summary>
            List of Custom Expression Factories which have been specified in the Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.ExtensionSupportingSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new Extension Function Supporting Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.ExtensionSupportingSparqlHandlerConfiguration.HasExpressionFactories">
            <summary>
            Gets whether any Custom Expression Factories are registered in the Config for this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.ExtensionSupportingSparqlHandlerConfiguration.ExpressionFactories">
            <summary>
            Gets the Custom Expression Factories which are in the Config for this Handler
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.InsertCommand">
            <summary>
            Represents a SPARQL Update INSERT command
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.BaseModificationCommand">
            <summary>
            Abstract Base class for classes that represent SPARQL Update INSERT, DELETE and INSERT/DELETE commands
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseModificationCommand._graphUri">
            <summary>
            URI from the WITH statement
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseModificationCommand._usingUris">
            <summary>
            URIs for the USING clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType)">
            <summary>
            Creates a new Base Modification Command
            </summary>
            <param name="type">Update Command Type</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.AddUsingUri(System.Uri)">
            <summary>
            Adds a new USING URI
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseModificationCommand.UsingUris">
            <summary>
            Gets the URIs specified in the USING clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseModificationCommand.GraphUri">
            <summary>
            Gets the URI of the Graph specified in the WITH clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new INSERT command
            </summary>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT command which operates on the Default Graph
            </summary>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the insertions are made to
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.InsertPattern">
            <summary>
            Gets the pattern used for insertions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlPathParser">
            <summary>
            Internal class which parses SPARQL Paths into path expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction">
            <summary>
            Abstract Base Class for XPath Unary String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction._expr">
            <summary>
            Expression the function applies over
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Unary String function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathStringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction">
            <summary>
            Abstract Base class for XPath Binary String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction._expr">
            <summary>
            Expression the function applies over
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction._arg">
            <summary>
            Argument expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction._allowNullArgument">
            <summary>
            Whether the argument can be null
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction._argumentTypeValidator">
            <summary>
            Type validation function for the argument
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean,System.Func{System.Uri,System.Boolean})">
            <summary>
            Creates a new XPath Binary String function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="argExpr">Argument</param>
            <param name="allowNullArgument">Whether the argument may be null</param>
            <param name="argumentTypeValidator">Type validator for the argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.BaseBinaryXPathStringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathStringLengthFunction">
            <summary>
            Represents the XPath fn:string-length() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringLengthFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Length function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringLengthFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringLengthFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathEncodeForUriFunction">
            <summary>
            Represents the XPath fn:encode-for-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEncodeForUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Encode for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEncodeForUriFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEncodeForUriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathEscapeHtmlUriFunction">
            <summary>
            Represents the XPath fn:escape-html-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEscapeHtmlUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Escape HTML for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEscapeHtmlUriFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEscapeHtmlUriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathLowerCaseFunction">
            <summary>
            Represents the XPath fn:lower-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathLowerCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Lower Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathLowerCaseFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathLowerCaseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathUpperCaseFunction">
            <summary>
            Represents the XPath fn:upper-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathUpperCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Upper Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathUpperCaseFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathUpperCaseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathNormalizeSpaceFunction">
            <summary>
            Represents the XPath fn:normalize-space() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeSpaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Normalize Space function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeSpaceFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeSpaceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction">
            <summary>
            Represents the XPath fn:normalize-unicode() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Normalize Unicode function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Normalize Unicode function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="normalizationFormExpr">Normalization Form</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction.ValueInternal(VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathNormalizeUnicodeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathContainsFunction">
            <summary>
            Represents the XPath fn:contains() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathContainsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Contains function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="searchExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathContainsFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathContainsFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathEndsWithFunction">
            <summary>
            Represents the XPath fn:ends-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEndsWithFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Ends With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="suffixExpr">Suffix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEndsWithFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathEndsWithFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathStartsWithFunction">
            <summary>
            Represents the XPath fn:starts-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStartsWithFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Starts With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="prefixExpr">Prefix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStartsWithFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStartsWithFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathSubstringBeforeFunction">
            <summary>
            Represents the XPath fn:substring-before() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringBeforeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring Before function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringBeforeFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringBeforeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathSubstringAfterFunction">
            <summary>
            Represents the XPath fn:substring-after() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringAfterFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring After function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringAfterFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringAfterFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction">
            <summary>
            Represents the XPath fn:compare() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Compare function
            </summary>
            <param name="a">First Comparand</param>
            <param name="b">Second Comparand</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.ValueInternal(VDS.RDF.LiteralNode,VDS.RDF.LiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.NumericType(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Type of this function as evaluated in the given Context for the given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns>
            Either <see cref="F:VDS.RDF.Query.Expressions.SparqlNumericType.Integer">Integer</see> or <see cref="F:VDS.RDF.Query.Expressions.SparqlNumericType.NaN">NaN</see>
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the numeric value of the Expression as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.IntegerValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the integer value of the Expression as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.DecimalValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the decimal value of the Expression as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.FloatValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the float value of the Expression as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCompareFunction.DoubleValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the double value of the Expression as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction">
            <summary>
            Represents the XPath fn:substring() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
            <param name="lengthExpr">Length</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the Effective Boolean Value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPathSubstringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction">
            <summary>
            Represents the XPath fn:replace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
            <param name="options">Options Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.ConfigureOptions(VDS.RDF.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPathReplaceFunction.Variables">
            <summary>
            Gets the enumeration of Variables involved in this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction">
            <summary>
            Represents the XPath fn:concat() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Concatenation function
            </summary>
            <param name="first">First Expression</param>
            <param name="second">Second Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new XPath Concatenation function
            </summary>
            <param name="expressions">Enumeration of expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPathConcatFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction">
            <summary>
            Represents the XPath fn:string-join() aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Join aggregate which uses no separator
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Join aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="sep">Separator Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate in the given Context over the given Binding IDs
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.ValueInternal(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of a member of the Group for concatenating as part of the result for the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.GetSeparator(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the separator to use in the concatenation
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringJoinFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.XPathFunctionFactory">
            <summary>
            Expression Factory which generates XPath Function expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory">
            <summary>
            Interface for implementing SPARQL custom expression factories which turn Uri specified functions into Sparql Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to Create a SPARQL Expression for a function with the given Uri and set of arguments
            </summary>
            <param name="u">Uri of the function</param>
            <param name="args">List of Arguments</param>
            <param name="expr">Resulting Expression if able to generate</param>
            <returns>True if an expression is generated, false if not</returns>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathFunctionsNamespace">
            <summary>
            Namespace Uri for XPath Functions Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Not">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Boolean">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Matches">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Contains">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StartsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EndsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StringLength">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Concat">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Substring">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.NormalizeSpace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.NormalizeUnicode">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.UpperCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.LowerCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EncodeForURI">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SubstringBefore">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SubstringAfter">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Replace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Translate">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Compare">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StringJoin">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EscapeHtmlURI">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.True">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.False">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Absolute">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Ceiling">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Floor">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Round">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.RoundHalfToEven">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.YearFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.MonthFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.DayFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.HoursFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.MinutesFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SecondsFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.TimezoneFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AdjustDateTimeToTimezone">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormKC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormKD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormFull">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptStringArguments">
            <summary>
            Argument Type Validator for validating that a Literal either has no datatype or is a String
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptIntegerArguments">
            <summary>
            Argument Type Validator for validating that a Literal has an Integer datatype
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptNumericArguments">
            <summary>
            Argument Type Validator for validating that a Literal has a Numeric datatype
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.XPathFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an XPath Function expression if the function Uri correseponds to a supported XPath Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PathEvaluationContext">
            <summary>
            Evaluation Context for evaluating complex property paths in SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.#ctor(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Path Evaluation Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="end">Start point of the Path</param>
            <param name="start">End point of the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.#ctor(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Creates a new Path Evaluation Context copied from the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.AddPath(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Adds a new path to the list of current incomplete paths
            </summary>
            <param name="p">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.AddCompletePath(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Adds a new path to the list of complete paths
            </summary>
            <param name="p">Path</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.SparqlContext">
            <summary>
            Gets the SPARQL Evaluation Context
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsFirst">
            <summary>
            Gets/Sets whether this is the first part of the Path to be evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsLast">
            <summary>
            Gets/Sets whether this is the last part of the Path to be evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsReversed">
            <summary>
            Gets/Sets whether the Path is currently reversed
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.Paths">
            <summary>
            Gets the hash set of incomplete paths generated so far
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.CompletePaths">
            <summary>
            Gets the hash set of complete paths generated so far
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PathStart">
            <summary>
            Gets the pattern which is the start of the path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PathEnd">
            <summary>
            Gets the pattern which is the end of the path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.CanAbortEarly">
            <summary>
            Gets whether pattern evaluation can be aborted early
            </summary>
            <remarks>
            Useful when both the start and end of the path are fixed (non-variables) which means that we can stop evaluating once we find the path (if it exists)
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PermitsNewPaths">
            <summary>
            Gets/Sets whether new paths can be introduced when not evaluating the first part of the path
            </summary>
            <remarks>
            <para>
            This is required when we have a path like ?x foaf:knows* /foaf:knows ?y and ?x is not bound prior to the path being executed.  Since we permit zero-length paths we should return the names of everyone even if they don't know anyone
            </para>
            <para>
            The cases where ?x is already bound are handled elsewhere as we can just introduce zero-length paths for every existing binding for ?x
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.PelletReasoner">
            <summary>
            A Pellet Reasoner which provides OWL 2 capable reasoning using an external knowledge base from a Pellet Server instance
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> Currently this reasoner operates only on a external knowledge base and there is currently no way to introduce new knowledge bases/data through the dotNetRDF API
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IQueryableOwlReasoner">
            <summary>
            Interface for OWL Reasoners which have access to their own SPARQL implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IOwlReasoner">
            <summary>
            Proposed interface for OWL Reasoners - currently incomplete
            </summary>
            <remarks>
            <para>
            <strong>Important:</strong> This interface is specifically designed so that it does not require the provision of a Graph to methods unless the method does not make sense without taking an <see cref="T:VDS.RDF.IGraph">IGraph</see> as a parameter.  This is because we envisage the use of this interface for connecting to reasoners which have their own access to the data over which they are reasoning and do not need it providing explicitly to them.
            </para>
            <para>
            Reasoner implementations may throw <see cref="T:System.NotSupportedException">NotSupportedException</see> for operations they don't support and may throw any other appropriate exceptions as appropriate for operations that encounter errors.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the reasoners knowledge base
            </summary>
            <param name="g">Graph</param>
            <remarks>
            <para>
            A reasoner may choose to do nothing in this method if that reasoner especially if it operates using some pre-defined, remote or otherwise immutable knowledge base.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Extract a reasoning enhanced sub-graph from the given Graph rooted at the given Node
            </summary>
            <param name="g">Graph</param>
            <param name="n">Root Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(System.String)">
            <summary>
            Extracts all possible triples using the given extraction mode
            </summary>
            <param name="mode">Extraction Mode</param>
            <returns></returns>
            <remarks>
            The <paramref name="mode">mode</paramref> permits for the specification of an extraction mode for reasoners that can extract specific subsets of reasoning.  Where this is not supported the reasoner should simply extract all triples that can be inferred by reasoning
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Extracts all possible triples using the given extraction modes
            </summary>
            <param name="modes">Extraction Modes</param>
            <returns></returns>
            <remarks>
            The <paramref name="modes">modes</paramref> permits for the specification of an extraction mode for reasoners that can extract specific subsets of reasoning.  Where this is not supported the reasoner should simply extract all triples that can be inferred by reasoning
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Classify">
            <summary>
            Extracts the triples which comprise the class hierarchy
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Realize">
            <summary>
            Extracts the triples which comprise the class hierarchy and individuals of those classes
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.IsConsistent">
            <summary>
            Returns whether the underlying knowledge base is consistent
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.IsConsistent(VDS.RDF.IGraph)">
            <summary>
            Returns whether the given Graph is consistent with the underlying knowledge base
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="P:VDS.RDF.Query.Inference.IOwlReasoner.Unsatisfiable">
            <summary>
            Returns the enumeration of unsatisfiable classes
            </summary>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IQueryableOwlReasoner.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query using the reasoners SPARQL implementation
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.#ctor(VDS.RDF.Query.Inference.Pellet.PelletServer,System.String)">
            <summary>
            Creates a new Pellet Reasoner
            </summary>
            <param name="server">Pellet Server</param>
            <param name="kbName">Knowledge Base name</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.#ctor(System.Uri,System.String)">
            <summary>
            Creates a new Pellet Reasoner
            </summary>
            <param name="serverUri">Pellet Server URI</param>
            <param name="kbName">Knowledge Base name</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query against the underlying Knowledge Base
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Knowledge Base
            </summary>
            <param name="g">Graph</param>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Extract(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Extract a reasoning enhanced sub-graph from the given Graph rooted at the given Node
            </summary>
            <param name="g">Graph</param>
            <param name="n">Root Node</param>
            <returns></returns>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Extract(System.String)">
            <summary>
            Extracts all possible triples using the given extraction mode
            </summary>
            <param name="mode">Extraction Mode</param>
            <returns></returns>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Extract(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Extracts all possible triples using the given extraction modes
            </summary>
            <param name="modes">Extraction Modes</param>
            <returns></returns>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Classify">
            <summary>
            Extracts the triples which comprise the class hierarchy
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.Realize">
            <summary>
            Extracts the triples which comprise the class hierarchy and individuals of those classes
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.IsConsistent">
            <summary>
            Returns whether the underlying knowledge base is consistent
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.PelletReasoner.IsConsistent(VDS.RDF.IGraph)">
            <summary>
            Returns whether the given Graph is consistent with the underlying knowledge base
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Inference.PelletReasoner.KnowledgeBase">
            <summary>
            Gets the Knowledge Base this Reasoner operates over
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.PelletReasoner.Server">
            <summary>
            Gets the Pellet Server this Reasoner operates on
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.PelletReasoner.Unsatisfiable">
            <summary>
            Returns the enumeration of unsatisfiable classes
            </summary>
            <remarks>
            Currently not supported by Pellet Server
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseBinaryExpression">
            <summary>
            Abstract base class for Binary Expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryExpression._leftExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryExpression._rightExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Binary Expression
            </summary>
            <param name="leftExpr">Left Expression</param>
            <param name="rightExpr">Right Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of a Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <remarks>If this method is not overridden in derived classes the value returned is the Effective Boolean Value as a Literal Node</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of a Sparql Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <remarks>Must be implemented by derived classes</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.BaseStoreParserContext">
            <summary>
            Base Class for Store Parser Contexts
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseStoreParserContext._store">
            <summary>
            Store being parsed into
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseStoreParserContext._traceParsing">
            <summary>
            Is Parsing Traced?
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new Base Store Parser Context
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.ITripleStore,System.Boolean)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.Store">
            <summary>
            Gets the Store being parsed into
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.TraceParsing">
            <summary>
            Gets/Sets whether to trace parsing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext">
            <summary>
            Class for Store Parser Contexts for Tokeniser based Parsing
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._queue">
            <summary>
            Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._traceTokeniser">
            <summary>
            Is Tokeniser traced?
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._localTokens">
            <summary>
            Local Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Store Parser Context with default settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether tokeniser tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ProxyFactory">
            <summary>
            Factory class for creating Web Proxies from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ProxyFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Web Proxy based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ProxyFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.SparqlEndpointFactory">
            <summary>
            Factory class for producing SPARQL Endpoints from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.SparqlEndpointFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Endpoint based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.SparqlEndpointFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.CredentialsFactory">
            <summary>
            Factory class for producing Network Credentials
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.CredentialsFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Network Credential based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CredentialsFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.NTriplesParser">
            <summary>
            Parser for NTriples syntax which is designed specifically for NTriples
            </summary>
            <remarks>The <see cref="T:VDS.RDF.Parsing.NTriplesParser">NTriplesParser</see> class can also be used which is a wrapper to a <see cref="T:VDS.RDF.Parsing.TurtleParser">TurtleParser</see> which can be restricted to only parse NTriples syntax.  This Native Parser should be faster since it uses a NTriples only Tokeniser as opposed to the Turtle Tokeniser which will Tokenise syntax which is invalid in NTriples.  The NTriples specific Tokeniser is able to reject this syntax at the Tokeniser stage whereas the Turtle based parser has to reject at the Parser stage which is potentially slower.</remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="T:VDS.RDF.IRdfReader">
            <summary>
            Interface to be implemented by RDF Readers which parse Concrete RDF Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Method for Loading a Graph from some Concrete RDF Syntax via some arbitrary Stream
            </summary>
            <param name="g">Graph to load RDF into</param>
            <param name="input">The Stream to read input from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the Stream</exception>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Method for Loading a Graph from some Concrete RDF Syntax from a given File
            </summary>
            <param name="g">Graph to load RDF into</param>
            <param name="filename">The Filename of the File to read from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the File</exception>
        </member>
        <member name="E:VDS.RDF.IRdfReader.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.ITraceableParser">
            <summary>
            Interface for Parsers that support Parser Tracing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.ITraceableParser.TraceParsing">
            <summary>
            Gets/Sets whether Parser Tracing is used
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor">
            <summary>
            Creates a new Instance of the Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Instance of the Parser using the given Token Queue Mode
            </summary>
            <param name="qmode">Token Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Parses NTriples Syntax from the given Input Stream into Triples in the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Arbitrary Input Stream to read input from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Parses NTriples Syntax from the given File into Triples in the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="filename">Name of the file containing Turtle Syntax</param>
            <remarks>Simply opens an StreamReader and uses the overloaded version of this function</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event if an event handler is registered to it
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.TraceTokeniser">
            <summary>
            Controls whether Tokeniser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.TraceParsing">
            <summary>
            Controls whether Parser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.NTriplesParser.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the NTriples being parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IRdfXmlEvent">
            <summary>
            Interface for XML/RDF Events as defined by the XML/RDF Specification
            </summary>
            <remarks>Used to provide polymorphism for the XML/RDF Parser</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IRdfXmlEvent.EventType">
            <summary>
            Gives some Integer representing the Event Type as understood by a specific Parser implementation
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IRdfXmlEvent.SourceXml">
            <summary>
            Gets the XML that produced the given event (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.FolderStoreWriter">
            <summary>
            Class for storing entire Triple Stores into disk based storage as a set of files in a Folder
            </summary>
        </member>
        <member name="T:VDS.RDF.IStoreWriter">
            <summary>
            Interface to be implemented by Triple Store Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.IStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Method for saving data to a Triple Store
            </summary>
            <param name="store">Triple Store</param>
            <param name="parameters">Parameters indicating where the Writer should write to</param> 
            <exception cref="!:RdfStorageException">May be thrown if the Parameters are not valid for this Writer</exception>
        </member>
        <member name="E:VDS.RDF.IStoreWriter.Warning">
            <summary>
            Event which writers can raise to indicate possible ambiguities or issues in the syntax they are producing
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.FolderStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves the given Store to Disk using the settings the Writer was instantiated with
            </summary>
            <param name="store">Store to save</param>
            <param name="parameters">Parameters indicating where to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.FolderStoreWriter.SaveGraphs(VDS.RDF.Writing.Contexts.FolderStoreWriterContext)">
            <summary>
            Internal Method which performs multi-threaded writing of data
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.FolderStoreWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Writing.FolderStoreWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.FolderStoreWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="T:VDS.RDF.Storage.IQueryableGenericIOManager">
            <summary>
            Interface for classes which provide SPARQL Query functionality to some arbitrary Store in addition to Read/Write functionality
            </summary>
            <remarks>
            Designed to allow for arbitrary Triple Stores to be plugged into the library as required by the end user
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IQueryableGenericIOManager.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the underlying store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns><see cref="!:SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the Sparql Query</returns>
        </member>
        <member name="T:VDS.RDF.Storage.IUpdateableGenericIOManager">
            <summary>
            Interface for classes which provide SPARQL Update functionality to some arbitrary Store in addition to Read/Write functionality
            </summary>
            <remarks>
            Designed to allow for arbitrary Triple Stores to be plugged into the library as required by the end user
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IUpdateableGenericIOManager.Update(System.String)">
            <summary>
            Processes a SPARQL Update command against the underlying Store
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseXPathCast">
            <summary>
            Abstract Expression class used as the base class for implementation of XPath Casting Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseXPathCast._expr">
            <summary>
            Expression to be Cast by the Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseXPathCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base XPath Cast Expression
            </summary>
            <param name="expr">Expression to be Cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseXPathCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of Casting the inner Expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseXPathCast.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of this Expressions result
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseXPathCast.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.BaseXPathCast.Variables">
            <summary>
            Gets the enumeration of Variables involved in this expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathBooleanCast">
            <summary>
            Class representing an XPath Boolean Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Boolean Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Boolean
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathDoubleCast">
            <summary>
            Class representing an XPath Double Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDoubleCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Double Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDoubleCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Double
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDoubleCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathFloatCast">
            <summary>
            Class representing an XPath Float Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloatCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Float Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloatCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Float
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Vinding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloatCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathDecimalCast">
            <summary>
            Class representing an XPath Decimal Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDecimalCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Decimal Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDecimalCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the Value of the inner Expression to a Decimal
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDecimalCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathIntegerCast">
            <summary>
            Class representing an XPath Integer Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathIntegerCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Integer Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathIntegerCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to an Integer
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathIntegerCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathDateTimeCast">
            <summary>
            Class representing an XPath Date Time Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDateTimeCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Date Time Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDateTimeCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Date Time
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDateTimeCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathStringCast">
            <summary>
            Class representing an XPath String Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringCast.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the results of the inner expression to a Literal Node typed xsd:string
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathStringCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Filters.BaseUnaryFilter">
            <summary>
            Abstract Base class for Unary Filters that operate on a single Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.ISparqlFilter">
            <summary>
            Interface for Classes which implement SPARQL Filter Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ISparqlFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ISparqlFilter.Variables">
            <summary>
            Gets the enumeration of Variables that are used in the Filter
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ISparqlFilter.Expression">
            <summary>
            Gets the Expression that this Filter uses
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Filters.BaseUnaryFilter._arg">
            <summary>
            Expression which is the Argument to the Filter
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Unary Filter
            </summary>
            <param name="arg">Argument to the Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Filters.BaseUnaryFilter.Variables">
            <summary>
            Gets the enumeration of Variables used in the Filter
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.BaseUnaryFilter.Expression">
            <summary>
            Gets the inner expression this Filter uses
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.BoundFilter">
            <summary>
            Filter that represents the Sparql BOUND() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new Bound Filter
            </summary>
            <param name="varTerm">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Filters.UnaryExpressionFilter">
            <summary>
            Generic Filter for Filters which take a single sub-expression as an argument
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Expression Filter which filters on the basis of a single sub-expression
            </summary>
            <param name="expr">Expression to filter with</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Filters.ChainFilter">
            <summary>
            Generic Filter for use where multiple Filters are applied on a single Graph Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.#ctor(VDS.RDF.Query.Filters.ISparqlFilter,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Chain Filter
            </summary>
            <param name="first">First Filter</param>
            <param name="second">Second Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.Add(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Adds an additional Filter to the Filter Chain
            </summary>
            <param name="filter">A Filter to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.ToString">
            <summary>
            Gets the String representation of the Filters
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ChainFilter.Variables">
            <summary>
            Gets the enumeration of Variables used in the chained Filters
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ChainFilter.Expression">
            <summary>
            Gets the Inner Expression used by the Chained Filters
            </summary>
            <remarks>
            Equivalent to ANDing all the Chained Filters expressions
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Filters.HavingClauseFilter">
            <summary>
            Represents a Filter in a HAVING Clause of a Sparql Query
            </summary>
            <remarks>
            Having Clause Filters are only applied over Binding IDs that refer to Groups
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Filters.HavingClauseFilter.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new HAVING Clause Filter which filters using the given Expression
            </summary>
            <param name="expr">Expression to filter with</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.HavingClauseFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.HavingClauseFilter.ToString">
            <summary>
            Gets the String representation of the Having Clause Filter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfJsonParser">
            <summary>
            Parser for RDF/JSON Syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Read RDF/JSON Syntax from some Stream into a Graph
            </summary>
            <param name="g">Graph to read into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Read RDF/Json Syntax from some File into a Graph
            </summary>
            <param name="g">Graph to read into</param>
            <param name="filename">File to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Parse(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Internal top level Parse method which parses the Json
            </summary>
            <param name="g">Graph to read into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseGraphObject(VDS.RDF.Parsing.Contexts.JsonParserContext)">
            <summary>
            Parser method which parses the top level Json Object which represents the overall Graph
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseTriples(VDS.RDF.Parsing.Contexts.JsonParserContext)">
            <summary>
            Parser method which parses Json Objects representing Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParsePredicateObjectList(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Objects representing Predicate Object Lists
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the parent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseObjectList(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Arrays representing Object Lists
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the Grandparent Json Object</param>
            <param name="pred">Predicate of Triples which comes form the Parent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseObject(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Objects reprsenting Object Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the Great-Grandparent Json Object</param>
            <param name="pred">Predicate of Triples which comes form the Grandparent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Error(VDS.RDF.Parsing.Contexts.JsonParserContext,System.String)">
            <summary>
            Helper method for raising Error messages with attached Line Information
            </summary>
            <param name="context">Parser Context</param>
            <param name="message">Error Message</param>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.RdfJsonParser.Warning">
            <summary>
            Event which is raised if there's a non-fatal issue with the RDF/Json Syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvWriter">
            <summary>
            Class for generating TSV files from RDF Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TsvWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to TSV format
            </summary>
            <param name="g">Graph</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to TSV format
            </summary>
            <param name="g">Graph</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="E:VDS.RDF.Writing.TsvWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvStoreWriter">
            <summary>
            Class for generating TSV output from RDF Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves a Triple Store to TSV format
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="parameters">A set of <see cref="T:VDS.RDF.Storage.Params.StreamParams">StreamParams</see></param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in TSV syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.BaseWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for the given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="segment">Triple Context</param>
        </member>
        <member name="E:VDS.RDF.Writing.TsvStoreWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvStoreWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Storage.BatchTriple">
            <summary>
            Structure for representing Triples that are waiting to be Batch written to the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.#ctor(VDS.RDF.Triple,System.String)">
            <summary>
            Creates a new Batch Triple
            </summary>
            <param name="t">Triple</param>
            <param name="graphID">Graph ID to store Triple for</param>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.Equals(System.Object)">
            <summary>
            Equality for Batch Triples
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.GetHashCode">
            <summary>
            Hash Code for Batch Triples
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.BatchTriple.Triple">
            <summary>
            Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BatchTriple.GraphID">
            <summary>
            Graph ID
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.ISparqlGroupBy">
            <summary>
            Interface for Classes that represent SPARQL GROUP BY clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.ISparqlGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Grouping to a Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.ISparqlGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies the Grouping to a Result Binder subdividing the Groups from the previous Group By clause into further Groups
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Groups</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.Child">
            <summary>
            Gets/Sets the child GROUP BY Clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.Variables">
            <summary>
            Gets the Fixed Variables used in the GROUP BY
            </summary>
            <remarks>
            Should only return variables whose raw values are grouped upon not those which are used in expressions
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IInferenceEngine">
            <summary>
            Interfaces for Inference Engines
            </summary>
            <remarks>
            <para>
            An Inference Engine is a class that given a Graph can infer extra information from that Graph based on fixed rules or rules computed from the Graphs it is performing inference on
            </para>
            <para>
            In general terms an implementation of an Inference Engine typically provides some form of forward chaining reasoner though implementations may do more advanced reasoning or wrap other kinds of reasoner.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Initialise(VDS.RDF.IGraph)">
            <summary>
            Initialises the Inference Engine using the given Graph
            </summary>
            <param name="g">Graph to initialise from</param>
        </member>
        <member name="T:VDS.RDF.Web.BaseSparqlServer">
            <summary>
            Abstract Base class for SPARQL Servers which provide combined SPARQL Query, Update and Uniform HTTP Protocol endpoints
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.BaseSparqlServer._config">
            <summary>
            Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes requests
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessQueryRequest(System.Web.HttpContext)">
            <summary>
            Processes Query requests
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessUpdateRequest(System.Web.HttpContext)">
            <summary>
            Processes Update requests
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessProtocolRequest(System.Web.HttpContext)">
            <summary>
            Processes Protocol requests
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.LoadConfig(System.Web.HttpContext,System.String@)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="basePath">Base Path of the Handler</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes SPARQL Queries
            </summary>
            <param name="query">Query</param>
            <returns></returns>
            <remarks>
            <para>
            Implementations should override this method if their behaviour requires more than just invoking the configured Query processor
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes SPARQL Updates
            </summary>
            <param name="cmd">Update Command</param>
            <remarks>
            <para>
            Implementations should override this method if their behaviour requires more than just invoking the configured Update processor
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ProcessQueryResults(System.Web.HttpContext,System.Object)">
            <summary>
            Internal Helper function which returns the Results back to the Client in one of their accepted formats
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="result">Results of the Sparql Query</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.HandleQueryErrors(System.Web.HttpContext,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.HandleQueryErrors(System.Web.HttpContext,System.String,System.String,System.Exception,System.Int32)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
            <param name="statusCode">HTTP Status Code to return</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.HandleUpdateErrors(System.Web.HttpContext,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Update Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="update">SPARQL Update</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ShowQueryForm(System.Web.HttpContext)">
            <summary>
            Generates a SPARQL Query Form
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.ShowUpdateForm(System.Web.HttpContext)">
            <summary>
            Generates a SPARQL Update Form
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.GetQueryPermissionAction(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Gets the Permission action for a SPARQL Query
            </summary>
            <param name="query">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlServer.GetUpdatePermissionAction(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Gets the Permission action for a SPARQL Update Command
            </summary>
            <param name="cmd">Update Command</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Web.BaseSparqlServer.IsReusable">
            <summary>
            Returns that the Handler is reusable
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.IPathResolver">
            <summary>
            Inteface for Objects which can resolve paths specified for Configuration properties
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IPathResolver.ResolvePath(System.String)">
            <summary>
            Resolves a Path
            </summary>
            <param name="path">Path</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Update.GenericUpdateProcessor">
            <summary>
            SPARQL Update Processor which processes commands against a generic underlying store represented by an <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> implementation
            </summary>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> interface then the managers native SPARQL Update implementation will be used for the non-type specific calls i.e. <see cref="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">ProcessCommand()</see> and <see cref="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">ProcessCommandSet()</see>.  At all other times the SPARQL Update commands will be processed by approximating their behaviour through calls to <see cref="M:VDS.RDF.Storage.IGenericIOManager.SaveGraph(VDS.RDF.IGraph)">SaveGraph()</see>, <see cref="M:VDS.RDF.Storage.IGenericIOManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">LoadGraph()</see> and <see cref="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> in addition to local in-memory manipulation of the data.  Some commands such as INSERT and DELETE can only be processed when the manager is also a <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see> since they rely on making a query and performing actions based on the results of that query.
            </para>
            <para>
            The performance of this processor is somewhat dependent on the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>.  If the underlying manager supports triple level updates as indicated by the <see cref="P:VDS.RDF.Storage.IGenericIOManager.UpdateSupported">UpdateSupported</see> property then operations can be performed quite efficiently, if this is not the case then any operation which modifies a Graph will need to load the existing Graph from the store, make the modifications locally in-memory and then save the resulting Graph back to the Store
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.ISparqlUpdateProcessor">
            <summary>
            Interface for SPARQL Update Processors
            </summary>
            <remarks>
            <para>
            A SPARQL Update Processor is a class that knows how apply SPARQL Update Commands to some data source to which the processor has access
            </para>
            <para>
            The point of this interface is to allow for end users to implement custom update processors or to extend and modify the behaviour of the default Leviathan engine as required.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.#ctor(VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new Generic Update Processor
            </summary>
            <param name="manager">Generic IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
            <remarks>
            Implemented by replacing the Graph with an empty Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
            <remarks>
            <para>
            Implemented by adding an empty Graph to the Store
            </para>
            <para>
            <strong>Warning:</strong> As the <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> interface does not allow checking whether a Graph exists processing CREATE commands can result in overwriting existing Graphs
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> interface then the managers native SPARQL Update implementation will be used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> interface then the managers native SPARQL Update implementation will be used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
            <remarks>
            <para>
            <strong>Note:</strong> The underlying manager must implement the <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see> interface in order for DELETE commands to be processed
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
            <remarks>
            <para>
            <strong>Note:</strong> The underlying manager must implement the <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see> interface in order for INSERT commands to be processed
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.ModifyCommand">
            <summary>
            Represents the SPARQL Update INSERT/DELETE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new INSERT/DELETE command
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions and deletions</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT/DELETE command which operates on the Default Graph
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions and deletions</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the insertions are made to
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.DeletePattern">
            <summary>
            Gets the pattern used for deletions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.InsertPattern">
            <summary>
            Gets the pattern used for insertions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.CreateCommand">
            <summary>
            Represents the SPARQL Update CREATE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.#ctor(System.Uri,System.Boolean)">
            <summary>
            Creates a new CREATE command
            </summary>
            <param name="graphUri">URI of the Graph to create</param>
            <param name="silent">Whether the create should be done silenty</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.#ctor(System.Uri)">
            <summary>
            Creates a new CREATE command
            </summary>
            <param name="graphUri">URI of the Graph to create</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.CreateCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be created
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.CreateCommand.Silent">
            <summary>
            Gets whether the Create should be done silently
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathBooleanFunction">
            <summary>
            Represents the XPath boolean() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Boolean Function
            </summary>
            <param name="expr">Expression to compute the Effective Boolean Value of</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Effective Boolean Value of the contained expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathBooleanFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction">
            <summary>
            Represents the Leviathan lfn:cartesian() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new 2D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new 3D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="z1">Expression for Z Coordiante of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
            <param name="z2">Expression for Z Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.CartesianDistance2D(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Internal helper for calculating 2D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.CartesianDistance3D(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Internal helper for calculating 3D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.LeviathanCartesianFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.ConciseBoundedDescription">
            <summary>
            Computes a Concise Bounded Description for all the Subjects resulting
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.ISparqlDescribe">
            <summary>
            Interface for classes that implement the DESCRIBE functionality of SPARQL
            </summary>
            <remarks>
            <para>
            This is designed so that developers can introduce their own DESCRIBE algorithms as required
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ISparqlDescribe.Describe(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Generates a Graph which is the description of the resources resulting from the Query
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ConciseBoundedDescription.Describe(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Returns the Graph which is the Result of the Describe Query by computing the Concise Bounded Description for all Results
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ConciseBoundedDescription.RewriteDescribeBNodes(VDS.RDF.Triple,System.Collections.Generic.Dictionary{System.String,VDS.RDF.INode},VDS.RDF.Graph)">
            <summary>
            Helper method which rewrites Blank Node IDs for Describe Queries
            </summary>
            <param name="t">Triple</param>
            <param name="mapping">Mapping of IDs to new Blank Nodes</param>
            <param name="g">Graph of the Description</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.TurtleParser">
            <summary>
            Parser for Turtle syntax
            </summary>
            <remarks>
            <para>
            This is a newly implemented parser as of 11/12/2009 - it was rewritten from scratch in order to remove an issue with Blank Node Handling which could not be solved with the old parser.  The code is now around a third the size, parses faster and appears to be bug free so far!
            </para>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor">
            <summary>
            Creates a new Turtle Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Turtle Parser which uses the given Token Queue Mode
            </summary>
            <param name="queueMode">Queue Mode for Tokenising</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Loads a Graph by reading Turtle syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph by reading Turtle syntax from the given file
            </summary>
            <param name="g">Graph to load into</param>
            <param name="filename">File to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Parse(VDS.RDF.Parsing.Contexts.TokenisingParserContext)">
            <summary>
            Internal method which does the parsing of the input
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseDirective(VDS.RDF.Parsing.Contexts.TokenisingParserContext)">
            <summary>
            Tries to parse Base/Prefix declarations
            </summary>
            <param name="context">Parse Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseTriples(VDS.RDF.Parsing.Contexts.TokenisingParserContext)">
            <summary>
            Tries to parse Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParsePredicateObjectList(VDS.RDF.Parsing.Contexts.TokenisingParserContext,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Predicate Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Predicate Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseObjectList(VDS.RDF.Parsing.Contexts.TokenisingParserContext,VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="pred">Predicate of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseCollection(VDS.RDF.Parsing.Contexts.TokenisingParserContext,VDS.RDF.INode)">
            <summary>
            Tries to parse Collections
            </summary>
            <param name="context">Parser Context</param>
            <param name="firstSubj">Blank Node which is the head of the collection</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseLiteral(VDS.RDF.Parsing.Contexts.TokenisingParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Tries to parse Literal Tokens into Literal Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="lit">Literal Token</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.OnWarning(System.String)">
            <summary>
            Helper method which raises the Warning event if there is an event handler registered
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:VDS.RDF.Parsing.TurtleParser.TraceParsing">
            <summary>
            Gets/Sets whether Parsing Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TurtleParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Trace is written to the Console
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.TurtleParser.Warning">
            <summary>
            Event which is raised when the parser detects issues with the input which are non-fatal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SelectKeywordToken">
            <summary>
            Token which represents the Sparql SELECT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SelectKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SELECT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AskKeywordToken">
            <summary>
            Token which represents the Sparql ASK Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AskKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ASK Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DescribeKeywordToken">
            <summary>
            Token which represents the Sparql DESCRIBE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DescribeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DESCRIBE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ConstructKeywordToken">
            <summary>
            Token which represents the Sparql CONSTRUCT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ConstructKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CONSTRUCT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AllToken">
            <summary>
            Token which represents the use of the * character to mean All
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AllToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new All Token
            </summary>
            <param name="line">Line the * occurs on</param>
            <param name="pos">Position the * occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AsKeywordToken">
            <summary>
            Token which represents the Sparql AS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new AS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AscKeywordToken">
            <summary>
            Token which represents the Sparql ASC Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AscKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ASC Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AvgKeywordToken">
            <summary>
            Token which represents the Sparql AVG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AvgKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new AVG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BindingsKeywordToken">
            <summary>
            Token which represents the Sparql BINDINGS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BindingsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BINDINGS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BoundKeywordToken">
            <summary>
            Token which represents the Sparql BOUND Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BoundKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BOUND Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CoalesceKeywordToken">
            <summary>
            Token which represents the Sparql COALESCE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CoalesceKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new COALESCE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CountKeywordToken">
            <summary>
            Token which represents the Sparql COUNT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CountKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new COUNT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataTypeKeywordToken">
            <summary>
            Token which represents the Sparql DATATYPE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataTypeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DATATYPE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DescKeywordToken">
            <summary>
            Token which represents the Sparql DESC Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DescKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DESC Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DistinctKeywordToken">
            <summary>
            Token which represents the Sparql DISTINCT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DistinctKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DISTINCT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ExistsKeywordToken">
            <summary>
            Token which represents the Sparql EXISTS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ExistsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new EXISTS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FilterKeywordToken">
            <summary>
            Token which represents the Sparql FILTER Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FilterKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FILTER Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FromKeywordToken">
            <summary>
            Token which represents the Sparql FROM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FromKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FROM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FromNamedKeywordToken">
            <summary>
            Token which represents the Sparql FROM NAMED Keyword combination
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FromNamedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FROM NAMED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GraphKeywordToken">
            <summary>
            Token which represents the Sparql GRAPH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GraphKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GRAPH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GroupByKeywordToken">
            <summary>
            Token which represents the Sparql GROUP BY Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GroupByKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GROUP BY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GroupConcatKeywordToken">
            <summary>
            Token which represents the Sparql GROUP_CONCAT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GroupConcatKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GROUP_CONCAT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HavingKeywordToken">
            <summary>
            Token which represents the Sparql HAVING Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HavingKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new HAVING Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IfKeywordToken">
            <summary>
            Token which represents the Sparql IF Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IfKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IF Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.InKeywordToken">
            <summary>
            Token which represents the Sparql IN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.InKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IriKeywordToken">
            <summary>
            Token which represents the Sparql IRI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IRI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsBlankKeywordToken">
            <summary>
            Token which represents the Sparql ISBLANK Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsBlankKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISBLANK Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsIriKeywordToken">
            <summary>
            Token which represents the Sparql ISIRI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsIriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISIRI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsLiteralKeywordToken">
            <summary>
            Token which represents the Sparql ISLITERAL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsLiteralKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISLITERAL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsUriKeywordToken">
            <summary>
            Token which represents the Sparql ISURI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsUriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISURI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LangKeywordToken">
            <summary>
            Token which represents the Sparql LANG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LangKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LANG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LangMatchesKeywordToken">
            <summary>
            Token which represents the Sparql LANGMATCHES Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LangMatchesKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LANGMATCHES Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LengthKeywordToken">
            <summary>
            Token which represents the Sparql LENGTH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LengthKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LENGTH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LetKeywordToken">
            <summary>
            Token which represents the Sparql LET Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LetKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LET Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LimitKeywordToken">
            <summary>
            Token which represents the Sparql LIMIT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LimitKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LIMIT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MaxKeywordToken">
            <summary>
            Token which represents the Sparql MAX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MaxKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MAX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MedianKeywordToken">
            <summary>
            Token which represents the Sparql MEDIAN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MedianKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MEDIAN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinKeywordToken">
            <summary>
            Token which represents the Sparql MIN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MIN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinusKeywordToken">
            <summary>
            Token which represents the Sparql MINUS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinusKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MINUS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ModeKeywordToken">
            <summary>
            Token which represents the Sparql MODE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ModeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MODE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NamedKeywordToken">
            <summary>
            Token which represents the Sparql NAMED Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NamedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NAMED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotInKeywordToken">
            <summary>
            Token which represents the Sparql NOT IN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotInKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NOT IN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NumericMaxKeywordToken">
            <summary>
            Token which represents the Sparql NMAX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NumericMaxKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NMAX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NumericMinKeywordToken">
            <summary>
            Token which represents the Sparql NMIN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NumericMinKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NMIN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotExistsKeywordToken">
            <summary>
            Token which represents the Sparql NOT EXISTS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotExistsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NOT EXISTS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OffsetKeywordToken">
            <summary>
            Token which represents the Sparql OFFSET Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OffsetKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new OFFSET Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OptionalKeywordToken">
            <summary>
            Token which represents the Sparql OPTIONAL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OptionalKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new OPTIONAL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OrderByKeywordToken">
            <summary>
            Token which represents the Sparql ORDER BY Keyword combination
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OrderByKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ORDER BY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ReducedKeywordToken">
            <summary>
            Token which represents the Sparql REDUCED Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ReducedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new REDUCED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RegexKeywordToken">
            <summary>
            Token which represents the Sparql REGEX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RegexKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new REGEX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SameTermKeywordToken">
            <summary>
            Token which represents the Sparql SAMETERM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SameTermKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SAMETERM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SampleKeywordToken">
            <summary>
            Token which represents the Sparql SAMPLE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SampleKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SAMPLE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ServiceKeywordToken">
            <summary>
            Token which represents the Sparql SERVICE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ServiceKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SERVICE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrKeywordToken">
            <summary>
            Token which represents the Sparql STR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrDtKeywordToken">
            <summary>
            Token which represents the Sparql STRDT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrDtKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRDT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrLangKeywordToken">
            <summary>
            Token which represents the Sparql STRLANG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrLangKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRLANG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SumKeywordToken">
            <summary>
            Token which represents the Sparql SUM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SumKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SUM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UndefKeywordToken">
            <summary>
            Token which represents the Sparql UNDEF Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UndefKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNDEF Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnionKeywordToken">
            <summary>
            Token which represents the Sparql UNION Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnionKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNION Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnsaidKeywordToken">
            <summary>
            Token which represents the Sparql UNSAID Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnsaidKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNSAID Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UriKeywordToken">
            <summary>
            Token which represents the Sparql URI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new URI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.WhereKeywordToken">
            <summary>
            Token which represents the Sparql WHERE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.WhereKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new WHERE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PlusToken">
            <summary>
            Token which represents Mathematical Plus
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PlusToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Plus Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinusToken">
            <summary>
            Token which represents Mathematical Minus
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinusToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Minus Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MultiplyToken">
            <summary>
            Token which represents Mathematical Multiply
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MultiplyToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Multiply Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DivideToken">
            <summary>
            Token which represents Mathematical Divide
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DivideToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Divide Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotEqualsToken">
            <summary>
            Token which represents Logical Not Equals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotEqualsToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Not Equals Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NegationToken">
            <summary>
            Token which represents Logical Negation
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NegationToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Negation Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AndToken">
            <summary>
            Token which represents Logical And
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AndToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical And Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OrToken">
            <summary>
            Token which represents Logical Or
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OrToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Or Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LessThanToken">
            <summary>
            Token which represents Relational Less Than
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LessThanToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Less Than Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LessThanOrEqualToToken">
            <summary>
            Token which represents Relational Less Than or Equal To
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LessThanOrEqualToToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Less Than or Equal To Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GreaterThanToken">
            <summary>
            Token which represents Relational Greater Than
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GreaterThanToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Greater Than Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GreaterThanOrEqualToToken">
            <summary>
            Token which represents Greater Than or Equal To
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GreaterThanOrEqualToToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Greater Than or Equal To Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlUpdateParser">
            <summary>
            Class for parsing SPARQL Update commands into <see cref="T:VDS.RDF.Update.SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> objects that can be used to modify a Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.Parse(System.IO.StreamReader)">
            <summary>
            Parses a SPARQL Update Command Set from the input stream
            </summary>
            <param name="input">Input Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.ParseFromFile(System.String)">
            <summary>
            Parses a SPARQL Update Command Set from the given file
            </summary>
            <param name="file">File</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.ParseFromString(System.String)">
            <summary>
            Parses a SPARQL Update Command Set from the given String
            </summary>
            <param name="updates">SPARQL Update Commands</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.ParseFromString(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Parses a SPARQL Update Command Set from the given String
            </summary>
            <param name="updates">SPARQL Update Commands</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IEventQueue">
            <summary>
            Interface for implementing Event Queues which provide Bufferable wrappers to Event Generators
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue.Dequeue">
            <summary>
            Removes the first Event from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue.Enqueue(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Adds an Event to the end of the Queue
            </summary>
            <param name="e">Event to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue.Peek">
            <summary>
            Gets the first Event from the Queue without removing it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue.Clear">
            <summary>
            Clears the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue.EventGenerator">
            <summary>
            Gets the Event Generator that this Queue uses
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue.Count">
            <summary>
            Gets the number of Events in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue.Events">
            <summary>
            Gets the underlying Queue of Events
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue.Tracing">
            <summary>
            Gets/Sets whether Generator Tracing should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue.LastEventType">
            <summary>
            Gets the Event Type of the last Event dequeued
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseEventQueue">
            <summary>
            Abstract base implementation of an Event Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue._eventgen">
            <summary>
            Generator used to fill the Event Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue._tracing">
            <summary>
            Variable indicating whether Generator Tracing is enabled
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue._lasteventtype">
            <summary>
            Type of Last Event dequeued
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue.Dequeue">
            <summary>
            Dequeues an Event from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue.Enqueue(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Adds an Event to the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue.Peek">
            <summary>
            Gets the next Event from the Queue without removing it from the queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue.Clear">
            <summary>
            Clears the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue.EventGenerator">
            <summary>
            Gets the Event Generator used by the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue.Count">
            <summary>
            Gets the number of Events in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue.Events">
            <summary>
            Gets the underlying Queue of Events
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue.Tracing">
            <summary>
            Gets/Sets Tracing for the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue.LastEventType">
            <summary>
            Gets the Event Type of the last Event dequeued
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.RdfAParserContext">
            <summary>
            Parser Context for RDFa Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfAParserContext.#ctor(VDS.RDF.IGraph,HtmlAgilityPack.HtmlDocument)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph</param>
            <param name="document">XML Document</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfAParserContext.#ctor(VDS.RDF.IGraph,HtmlAgilityPack.HtmlDocument,System.Boolean)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph</param>
            <param name="document">HTML Document</param>
            <param name="traceParsing">Whether to Trace Parsing</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAParserContext.Document">
            <summary>
            Gets the HTML Document
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAParserContext.XmlBaseAllowed">
            <summary>
            Gets/Sets whether xml:base is allowed in the embedded RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAParserContext.DefaultVocabulary">
            <summary>
            Gets/Sets the Default Vocabularly
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAParserContext.Syntax">
            <summary>
            Gets/Sets the RDFa syntax in use
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext">
            <summary>
            Evaluation Context for RDFa Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.#ctor(System.Uri)">
            <summary>
            Creates a new RDFa Evaluation Context
            </summary>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.#ctor(System.Uri,VDS.RDF.NamespaceMapper)">
            <summary>
            Creates a new RDFa Evaluation Context
            </summary>
            <param name="baseUri">Base URI</param>
            <param name="nsmap">Namepace Map</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.BaseUri">
            <summary>
            Gets/Sets the Base URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.ParentSubject">
            <summary>
            Gets/Sets the Parent Subject
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.ParentObject">
            <summary>
            Gets/Sets the Parent Object
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.NamespaceMap">
            <summary>
            Gets the Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.Language">
            <summary>
            Gets/Sets the Language
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.IncompleteTriples">
            <summary>
            Gets the list of incomplete Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfAEvaluationContext.LocalVocabulary">
            <summary>
            Gets/Sets the Local Vocabulary
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IncompleteTriple">
            <summary>
            Represents an incomplete Triple as part of the RDFa parsing process
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.IncompleteTriple.#ctor(VDS.RDF.INode,VDS.RDF.Parsing.Contexts.IncompleteTripleDirection)">
            <summary>
            Creates a new Incomplete Triple
            </summary>
            <param name="pred">Predicate</param>
            <param name="direction">Direction</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IncompleteTriple.Predicate">
            <summary>
            Gets the Predicate of the Incomplete Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IncompleteTriple.Direction">
            <summary>
            Gets the Direction of the Incomplete Triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IncompleteTripleDirection">
            <summary>
            Possible Directions for Incomplete Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.IncompleteTripleDirection.Forward">
            <summary>
            Forward
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.IncompleteTripleDirection.Reverse">
            <summary>
            Reverse
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.Individual">
            <summary>
            Represents an Individual i.e. an instance of some class in an ontology
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyResource">
            <summary>
            Base class for representing a resource in an Ontology
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._literalProperties">
            <summary>
            Storage of Literal Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._resourceProperties">
            <summary>
            Storage of Resource Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._resource">
            <summary>
            The Node which this Resource is a wrapper around
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._graph">
            <summary>
            The Graph from which this Resource originates
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Resource for the given Resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.#ctor(System.Uri,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Resource for the given Resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.IntialiseProperty(System.String,System.Boolean)">
            <summary>
            Retrieves all the Triples which have the Resource as the subject and the given property URI as the predicate from the Graph and stores the values locally
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="requireLiteral">Whether only Literal values are acceptable</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLiteralProperty(System.String,VDS.RDF.LiteralNode,System.Boolean)">
            <summary>
            Adds a new literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLiteralProperty(System.Uri,VDS.RDF.LiteralNode,System.Boolean)">
            <summary>
            Adds a new literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddResourceProperty(System.String,VDS.RDF.INode,System.Boolean)">
            <summary>
            Adds a new value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddResourceProperty(System.Uri,VDS.RDF.INode,System.Boolean)">
            <summary>
            Adds a new value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLiteralProperty(System.String,System.Boolean)">
            <summary>
            Clears all values for a Literal Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLiteralProperty(System.Uri,System.Boolean)">
            <summary>
            Clears all values for a Literal Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearResourceProperty(System.String,System.Boolean)">
            <summary>
            Clears all values for a Resource Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearResourceProperty(System.Uri,System.Boolean)">
            <summary>
            Clears all values for a Resource Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLiteralProperty(System.String,VDS.RDF.LiteralNode,System.Boolean)">
            <summary>
            Removes a literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLiteralProperty(System.Uri,VDS.RDF.LiteralNode,System.Boolean)">
            <summary>
            Removes a literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveResourceProperty(System.String,VDS.RDF.INode,System.Boolean)">
            <summary>
            Removes a value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveResourceProperty(System.Uri,VDS.RDF.INode,System.Boolean)">
            <summary>
            Removes a value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddComment(System.String)">
            <summary>
            Adds a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddComment(System.String,System.String)">
            <summary>
            Adds a comment in a specific language for this resource
            </summary>
            <param name="comment">Comment</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearComments">
            <summary>
            Removes all comments for this resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(VDS.RDF.LiteralNode)">
            <summary>
            Removes a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(System.String)">
            <summary>
            Removes a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(System.String,System.String)">
            <summary>
            Removes a comment in a specific language for this resource
            </summary>
            <param name="comment">Comment</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(System.Uri)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also adds this resource as different from the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearDifferentFrom">
            <summary>
            Clears all <em>owl:differentFrom</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(System.Uri)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also removes this resource as different from the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(System.Uri)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearIsDefinedBy">
            <summary>
            Removes all <em>rdfs:isDefinedBy</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(System.Uri)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLabel(System.String)">
            <summary>
            Adds a label for the resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLabel(System.String,System.String)">
            <summary>
            Adds a label in a specific language for a resource
            </summary>
            <param name="label">Label</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLabels">
            <summary>
            Clears all labels for a resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(VDS.RDF.LiteralNode)">
            <summary>
            Removes a specific label for a resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(System.String)">
            <summary>
            Removes a label for a resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(System.String,System.String)">
            <summary>
            Removes a label in a specific language for a resource
            </summary>
            <param name="label">Label</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(System.Uri)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also adds this resource as an <em>owl:sameAs</em> triple for the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearSameAs">
            <summary>
            Removes all <em>owl:sameAs</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(System.Uri)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also removes the <em>owl:sameAs</em> triple for the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(System.Uri)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearSeeAlso">
            <summary>
            Removes all <em>rdfs:seeAlso</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(System.Uri)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(System.Uri)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearTypes">
            <summary>
            Removes all <em>rdf:type</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(System.Uri)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddVersionInfo(System.String)">
            <summary>
            Adds version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearVersionInfo">
            <summary>
            Clears version information for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveVersionInfo(VDS.RDF.LiteralNode)">
            <summary>
            Remove version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveVersionInfo(System.String)">
            <summary>
            Remove version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetLiteralProperty(System.String)">
            <summary>
            Gets the values for a property which is restricted to literals
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetLiteralProperty(System.Uri)">
            <summary>
            Gets the values for a property which is restricted to literals
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetResourceProperty(System.String)">
            <summary>
            Gets the values for a property which can be any node type
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetResourceProperty(System.Uri)">
            <summary>
            Gets the values for a property which can be any node type
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ToString">
            <summary>
            Gets the String representation of the Resource
            </summary>
            <returns></returns>
            <remarks>
            This is either the first label (if any are declared) or the string representation of the <see cref="T:VDS.RDF.INode">INode</see> that this resource wraps
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.op_Explicit(VDS.RDF.Ontology.OntologyResource)~VDS.RDF.Graph">
            <summary>
            Casts a Resource into a Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            Equivalent to doing a SPARQL DESCRIBE query on this resource
            </remarks>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Resource">
            <summary>
            Gets the Resource that this Ontology Resource refers to
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Graph">
            <summary>
            Gets the Graph that this Ontology Resource is from
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.VersionInfo">
            <summary>
            Gets the Version Information for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Comment">
            <summary>
            Gets the Comment(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Label">
            <summary>
            Gets the Label(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.SeeAlso">
            <summary>
            Gets the See Also(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.SameAs">
            <summary>
            Gets the Same As('s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.IsDefinedBy">
            <summary>
            Gets the Is Defined By(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.DifferentFrom">
            <summary>
            Gets the Different From(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Types">
            <summary>
            Gets the rdf:type's for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithSubject">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Subject
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithObject">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Object
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithPredicate">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Predicate
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Triples">
            <summary>
            Gets all the Triples where the Resource occurs in any position
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Gets an Individual from the Graph
            </summary>
            <param name="resource">Resource that represents the Individual</param>
            <param name="graph">Graph the Individual is in</param>
            <remarks>
            Requires that an individual (a resource which is the subject of at least one triple where the predicate is <strong>rdf:type</strong>) is already present in the Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Gets/Creates an Individual from the Graph
            </summary>
            <param name="resource">Resource that represents the Individual</param>
            <param name="resourceClass">Class to create/add the Individual to</param>
            <param name="graph">Graph the Individual is in</param>
            <remarks>
            Allows for creating new Individuals in the Graph or adding existing resources to another Class.  If the resource for the Individual or the given Class are new then they will be added to the Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.IntialiseClasses">
            <summary>
            Helper method which finds all the Types given for this Resource
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Gets whether the Individual belongs to a specific class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(VDS.RDF.INode)">
            <summary>
            Gets whether the Individual belongs to a class identified by the given resource
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(System.Uri)">
            <summary>
            Gets whether the Individual belongs to a class identified by the given URI
            </summary>
            <param name="class">Class URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.Individual.Classes">
            <summary>
            Gets all the Classes that this resource belongs to
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.UnicodeSpecsHelper">
            <summary>
            Helper Class which defines some Test Functions for testing the Unicode Category of Characters
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetter(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetterOrDigit(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter or Digit
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetterModifier(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter Modifier
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsDigit(System.Char)">
            <summary>
            Checks whether a given Character is considered a Digit
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.ConvertToChar(System.String)">
            <summary>
            Converts a Hex Escape into the relevant Unicode Character
            </summary>
            <param name="hex">Hex code</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultsType">
            <summary>
            Represents the type of the SPARQL Results Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.Boolean">
            <summary>
            The Result Set represents a Boolean Result
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.VariableBindings">
            <summary>
            The Result Set represents a set of Variable Bindings
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.Unknown">
            <summary>
            The Result Set represents an unknown result
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultSet">
            <summary>
            Class for representing Sparql Result Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._results">
            <summary>
            Lists of Sparql Results
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._variables">
            <summary>
            Lists of Variables in the Result Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._result">
            <summary>
            Boolean Result
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._empty">
            <summary>
            Indicates whether the Result Set is Empty and can have Results safely loaded into it
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor">
            <summary>
            Creates an Empty Sparql Result Set
            </summary>
            <remarks>Useful where you need a possible guarentee of returning an result set even if it proves to be empty and also necessary for the implementation of Result Set Parsers.</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor(System.Boolean)">
            <summary>
            Creates a Sparql Result Set for the Results of an ASK Query with the given Result value
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Creates a SPARQL Result Set for the Results of a Query with the Leviathan Engine
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Result Set
            </summary>
            <param name="var">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.AddResult(VDS.RDF.Query.SparqlResult)">
            <summary>
            Adds a Result to the Result Set
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.SetResult(System.Boolean)">
            <summary>
            Sets the Boolean Result for the Result Set
            </summary>
            <param name="result">Boolean Result</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.SetEmpty(System.Boolean)">
            <summary>
            Sets whether the Result Set is empty
            </summary>
            <param name="empty">Whether the Result Set is empty</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.GetEnumerator">
            <summary>
            Gets an Enumerator for the Results List
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an Enumerator for the Results List
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.Equals(System.Object)">
            <summary>
            Determines whether two Result Sets are equal
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <remarks>
            Experimental and not yet complete
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.Dispose">
            <summary>
            Disposes of a Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.ResultsType">
            <summary>
            Gets the Type of the Results Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Result">
            <summary>
            Gets the Result of an ASK Query
            </summary>
            <remarks>Result Set is deemed to refer to an ASK query if the Variables list is empty since an ASK Query result has an empty &lt;head&gt;.  It is always true for any other Query type where one/more variables were requested even if the Result Set is empty.</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Count">
            <summary>
            Gets the number of Results in the Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.IsEmpty">
            <summary>
            Gets whether the Result Set is empty and can have Results loaded into it
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Results">
            <summary>
            Gets the List of Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Item(System.Int32)">
            <summary>
            Index directly into the Results
            </summary>
            <param name="index">Index of the Result you wish to retrieve</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Variables">
            <summary>
            Gets the Variables used in the Result Set
            </summary>
        </member>
        <member name="T:VDS.RDF.MimeTypesHelper">
            <summary>
            Helper Class containing arrays of MIME Types for the various RDF Concrete Syntaxes and Content Negotation Methods
            </summary>
            <remarks>
            The first type in each array is the canonical type that should be used
            </remarks>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTurtleExtension">
            <summary>
            Default File Extension for Turtle Files
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultRdfXmlExtension">
            <summary>
            Default File Extension for RDF/XML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNotation3Extension">
            <summary>
            Default File Extension for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNTriplesExtension">
            <summary>
            Default File Extension for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultJsonExtension">
            <summary>
            Default File Extension for Json formats
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultSparqlXmlExtension">
            <summary>
            Default File Extension for Sparql XML Results Format
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTriGExtension">
            <summary>
            Default File Extension for TriG
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNQuadsExtension">
            <summary>
            Default File Extension for NQuads
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTriXExtension">
            <summary>
            Default File Extension for TriX
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultCsvExtension">
            <summary>
            Default File Extension for CSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTsvExtension">
            <summary>
            Default File Extension for TSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultHtmlExtension">
            <summary>
            Default File Extension for HTML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultXHtmlExtension">
            <summary>
            Default File Extension for XHTML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Any">
            <summary>
            MIME Type for accept any content Type
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.WWWFormURLEncoded">
            <summary>
            MIME Type for URL Encoded WWW Form Content used when POSTing over HTTP
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Turtle">
            <summary>
            MIME Types for Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.RdfXml">
            <summary>
            MIME Types for RDF/XML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Notation3">
            <summary>
            MIME Types for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.NTriples">
            <summary>
            MIME Types for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.NQuads">
            <summary>
            MIME Types for NQuads
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.TriG">
            <summary>
            MIME Types for TriG
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.TriX">
            <summary>
            MIME Types for TriX
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Json">
            <summary>
            MIME Types for RDF/Json
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Sparql">
            <summary>
            MIME Types for Sparql Result Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Csv">
            <summary>
            MIME Types for CSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Tsv">
            <summary>
            MIME Types for TSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Html">
            <summary>
            MIME Types for HTML
            </summary>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetCanonicalType(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets the Canonical Type from a set of MIME Types where it is assumed the first type in the list is the Canonical Type
            </summary>
            <param name="mimeTypes">MIME Types</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a Custom HTTP Accept Header containing the given selection of MIME Types
            </summary>
            <param name="mimeTypes">Enumeration of MIME Types to use</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> No validation is done on MIME Types so it is possible to generated a malformed header using this function
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a Custom HTTP Accept Header containing the given selection of MIME Types where those MIME Types also appear in the list of supported Types
            </summary>
            <param name="mimeTypes">Enumeration of MIME Types to use</param>
            <param name="supportedTypes">Enumeration of supported MIME Types</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> No validation is done on MIME Types so it is possible to generated a malformed header using this function
            </para>
            <para>
            Use this function when you wish to generate a Custom Accept Header where the URI to which you are making requests supports a set range of URIs (given in the <paramref name="mimeTypes"/> parameter) where that range of types may exceed the range of types actually supported by the library or your response processing code.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(VDS.RDF.IRdfReader)">
            <summary>
            Creates a Custom HTTP Accept Header containing only the Accept Types supported by a specific parser
            </summary>
            <param name="parser">RDF Parser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.String[],System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="ctypes">String array of accepted Content Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            For writers which support <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see> they will be instantiated with the Compression Level specified by <see cref="P:VDS.RDF.Options.DefaultCompressionLevel">Options.DefaultCompressionLevel</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            For writers which support <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see> they will be instantiated with the Compression Level specified by <see cref="P:VDS.RDF.Options.DefaultCompressionLevel">Options.DefaultCompressionLevel</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsReader">ISparqlResultsReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParser(System.String,System.Boolean)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsReader">ISparqlResultsReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <param name="allowPlainTextResults">Whether you allow Sparql Boolean results in text/plain format</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.String[],System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="ctypes">String array of accepted Content Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.String[],System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="ctypes">String array of accepted Content Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetMimeType(System.String)">
            <summary>
            Selects the appropriate MIME Type for the given File Extension if the File Extension is a standard extension for an RDF format
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(System.String)">
            <summary>
            Selects the appropriate File Extension for the given MIME Type
            </summary>
            <param name="mimeType">MIME Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(VDS.RDF.IRdfWriter)">
            <summary>
            Selects the appropriate File Extension for the given RDF Writer
            </summary>
            <param name="writer">RDF Writer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(VDS.RDF.IStoreWriter)">
            <summary>
            Selects the appropriate File Extension for the given Store Writer
            </summary>
            <param name="writer">Store Writer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used when you want to ask for content in RDF formats (except Sparql Results)
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpSparqlAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for querying Sparql Endpoints where the response will be a Sparql Result Set format
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfOrSparqlAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data may be RDF or a Sparql Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfDatasetAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data will be an RDF dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfOrDatasetAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data may be RDF or an RDF dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedRdfMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for RDF Graphs
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedSparqlMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for SPARQL Results
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedRdfOrSparqlMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for RDF Graphs or SPARQL Results
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TriXWriter">
            <summary>
            Class for serialzing Triple Stores in the TriX format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TriXWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves a Store in TriX format
            </summary>
            <param name="store">Store to save</param>
            <param name="parameters">Parameters indicating a Stream to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriXWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Writing.TriXWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext">
            <summary>
            Writer Context for Store Writers which do multi-threaded writing
            </summary>
            <remarks>
            Provides a queue for queuing the URIs of Graphs from the Store that need writing and a thread safe way of retrieving the next Uri to be written from the Queue
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Creates a new Threaded Store Writer Context with default settings
            </summary>
            <param name="store">Store to be written</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Threaded Store Writer Context with custom settings
            </summary>
            <param name="store">Store to be written</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.Add(System.Uri)">
            <summary>
            Adds a Uri to the list of URIs for Graphs that are waiting to be written
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.GetNextURI">
            <summary>
            Gets the next Uri for a Graph that is waiting to be written
            </summary>
            <returns>Uri of next Graph to be written</returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.NamespaceMap">
            <summary>
            Gets the NamespaceMap used for reducing URIs to QNames since there may only be one shared map written to the output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.QNameMapper">
            <summary>
            Gets the QName Mapper
            </summary>
            <remarks>
            Must be manually initialised by the user
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.GenericStoreWriterContext">
            <summary>
            Writer Context for Store Writers which write using a <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>
            </summary>
            <remarks>
            Provides a queue for queuing the URIs of Graphs from the Store that need writing and a thread safe way of retrieving the next Uri to be written from the Queue
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.GenericIOParams)">
            <summary>
            Creates a new Generic Store Writer Context
            </summary>
            <param name="store">Triple Store that will be written to the underlying Store</param>
            <param name="parameters">Generic IO Parameters</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.Add(System.Uri)">
            <summary>
            Adds a Uri to the list of URIs for Graphs that are waiting to be written
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.GetNextURI">
            <summary>
            Gets the next Uri for a Graph that is waiting to be written
            </summary>
            <returns>Uri of next Graph to be written</returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.Store">
            <summary>
            Gets the Triple Store that is being written to the underlying Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.Manager">
            <summary>
            Gets the IO Manager for the underlying store
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.Threads">
            <summary>
            Gets the number of Threads to use for operations that can be multi-threaded
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.GenericStoreWriterContext.Parameters">
            <summary>
            Gets the Generic IO Parameters
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.WildcardGraphHandler">
            <summary>
            HTTP Handler for serving Graphs in ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to serve a Graph at a base URL with any URL under that being handled by this Handler.  The Graph is served to the user in one of their acceptable MIME types if possible, if they don't accept any MIME type we can serve then they get a 406 Not Acceptable
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Graph to be served:
            <code>
            &lt;dotnetrdf:/folder/graph/*&gt; a dnr:HttpHandler ;
                                              dnr:type "VDS.RDF.Web.WildcardGraphHandler" ;
                                              dnr:usingGraph _:graph .
                                            
            _:graph a dnr:Graph ;
                    dnr:type "VDS.RDF.Graph" ;
                    dnr:fromFile "yourGraph.rdf" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.WildcardGraphHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.WildcardGraphHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handlers configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Web.ProtocolHandler">
            <summary>
            HTTP Handler for adding SPARQL Uniform HTTP Protocol for RDF Graph Management endpoints to ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to create a Protocol endpoint at a specific fixed URL, if you want to allow URIs relative to this URI to be used to refer to Graphs then use the <see cref="T:VDS.RDF.Web.WildcardProtocolHandler">WildcardProtocolHandler</see> instead
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Protocol Endpoint:
            <code>
            &lt;dotnetrdf:/folder/protocol&gt; a dnr:HttpHandler ;
                                               dnr:type "VDS.RDF.Web.ProtocolHandler" ;
                                               dnr:protocolProcessor _:proc .
                                            
            _:proc a dnr:SparqlHttpProtocolProcessor ;
                   dnr:type "VDS.RDF.Update.Protocol.LeviathanProtocolProcessor" ;
                   dnr:usingStore _:store .
                   
            _:store a dnr:TripleStore ;
                    dnr:type "VDS.RDF.TripleStore" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Web.BaseSparqlHttpProtocolHandler">
            <summary>
            Abstract Base Class for creating SPARQL Uniform HTTP Protocol Handler implementations
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.BaseSparqlHttpProtocolHandler._config">
            <summary>
            Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHttpProtocolHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes requests made to the Uniform HTTP Protocol endpoint and invokes the appropriate methods on the Protocol Processor that is in use
            </summary>
            <param name="context">HTTP Context</param>
            <remarks>
            <para>
            Implementations may override this if necessary - if the implementation is only providing additional logic such as authentication, ACLs etc. then it is recommended that the override applies its logic and then calls the base method since this base method will handle much of the error handling and sending of appropriate HTTP Response Codes.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHttpProtocolHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHttpProtocolHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="P:VDS.RDF.Web.BaseSparqlHttpProtocolHandler.IsReusable">
            <summary>
            Indicates that the Handler is reusable
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.ProtocolHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.ProtocolHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Web.BaseSparqlQueryHandler">
            <summary>
            Abstract Base class for Handlers which provide SPARQL Query endpoints
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.BaseSparqlQueryHandler._config">
            <summary>
            Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes a SPARQL Query Request
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a Query
            </summary>
            <param name="query">Query</param>
            <returns></returns>
            <remarks>
            <para>
            Implementations should override this method if their behaviour requires more than just invoking the configured Query processor
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.ProcessResults(System.Web.HttpContext,System.Object)">
            <summary>
            Internal Helper function which returns the Results back to the Client in one of their accepted formats
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="result">Results of the Sparql Query</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.HandleErrors(System.Web.HttpContext,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.HandleErrors(System.Web.HttpContext,System.String,System.String,System.Exception,System.Int32)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
            <param name="statusCode">HTTP Status Code to return</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.ShowQueryForm(System.Web.HttpContext)">
            <summary>
            Generates a Sparql Query Form
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlQueryHandler.GetPermissionAction(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Determines the Permission Action for a SPARQL Query
            </summary>
            <param name="query">Query</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Web.BaseSparqlQueryHandler.IsReusable">
            <summary>
            Returns that the Handler is reusable
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.DatasetFileManager">
            <summary>
            Allows you to treat an RDF Dataset File - NQuads, TriG or TriX - as a read-only generic store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Dataset File Manager
            </summary>
            <param name="filename">File to load from</param>
            <param name="async">Whether to load asynchronously</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Initialise(System.String)">
            <summary>
            Internal helper method for loading the data
            </summary>
            <param name="filename">File to load from</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Query(System.String)">
            <summary>
            Makes a query against the in-memory copy of the Stores data
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Dataset
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Dataset
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="g">Graph to save</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Always thrown since this Manager provides a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Dispose">
            <summary>
            Disposes of the Manager
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.ToString">
            <summary>
            Gets the String representation of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.UpdateSupported">
            <summary>
            Returns that Updates are not supported since this is a read-only connection
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.IsReady">
            <summary>
            Returns that the Manager is ready if the underlying file has been loaded
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.IsReadOnly">
            <summary>
            Returns that the Manager is read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.SubQueryPattern">
            <summary>
            Class for representing Sub-queries which occur as part of a SPARQL query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.#ctor(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new Sub-query pattern which represents the given sub-query
            </summary>
            <param name="subquery">Sub-query</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Sub-query in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.ToString">
            <summary>
            Gets the string representation of the sub-query
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.IsAcceptAll">
            <summary>
            Returns that the Pattern is not an accept all since it is a Sub-query
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletHelper">
            <summary>
            Helper class provided constants and helper methods for use with Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceServerDescription">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceKBDescription">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceRealize">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceNamespaces">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceQuery">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceConsistency">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainUnsat">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainInstance">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceClassify">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceSearch">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainSubclass">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainInconsistent">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplain">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainProperty">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction">
            <summary>
            Abstract Base Class for Unary Trigonometric Functions in the Leviathan Function Library
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction._func">
            <summary>
            Trigonometric function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Func{System.Double,System.Double})">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
            <param name="func">Trigonometric Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer value of the Function applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal value of the Function applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double value of the Function applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryLeviathanTrigonometricFunction.ToString">
            <summary>
            Gets the string representation of the Function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction">
            <summary>
            Represents the Leviathan lfn:degrees-to-radians() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Degrees to Radians Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer value of the Function applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal value of the Function applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double value of the Function applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanDegreesToRadiansFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction">
            <summary>
            Represents the Leviathan lfn:radians-to-degrees() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Radians to Degrees Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction.IntegerValueInternal(System.Int64)">
            <summary>
            Gets the Integer value of the Function applied to an Integer
            </summary>
            <param name="l">Integer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction.DecimalValueInternal(System.Decimal)">
            <summary>
            Gets the Decimal value of the Function applied to a Decimal
            </summary>
            <param name="d">Decimal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction.DoubleValueInternal(System.Double)">
            <summary>
            Gets the Double value of the Function applied to a Double
            </summary>
            <param name="d">Double</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanRadiansToDegreesFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanSineFunction">
            <summary>
            Represents the Leviathan lfn:sin() or lfn:sin-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSineFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanCosineFunction">
            <summary>
            Represents the Leviathan lfn:cos() or lfn:cos-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosineFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanTangentFunction">
            <summary>
            Represents the Leviathan lfn:tan() or lfn:tan-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanTangentFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanSecantFunction">
            <summary>
            Represents the Leviathan lfn:sec() or lfn:sec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSecantFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanCosecantFunction">
            <summary>
            Represents the Leviathan lfn:cosec() or lfn:cosec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCosecantFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanCotangentFunction">
            <summary>
            Represents the Leviathan lfn:cot() or lfn:cot-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCotangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCotangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanCotangentFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Describe.NamedGraphDescription">
            <summary>
            Computes a Description for all the results such that the description is the merge of all the Graphs named with a resulting URI
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Describe.NamedGraphDescription.Describe(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Returns the Graph which is the merge of all the Graphs which are named with URIs contained in the Results
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SelectDistinctGraphs">
            <summary>
            Special Algebra Construct for optimising queries of the form SELECT DISTINCT ?g WHERE {GRAPH ?g {?s ?p ?o}}
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Select Distinct Graphs optimisation
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.OrderBy">
            <summary>
            Represents an Order By clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Order By clause
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Order By clause
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Bindings">
            <summary>
            Represents a BINDINGS modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.#ctor(VDS.RDF.Query.Patterns.BindingsPattern,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new BINDINGS modifier
            </summary>
            <param name="bindings">Bindings</param>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BINDINGS modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Token">
            <summary>
            Static Class which defines the Integer Constants used for Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNKNOWN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PREFIXDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PREFIX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BASEDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FORALL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FORSOME">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.URI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.QNAME">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LONGLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANGSPEC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATATYPE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PLAINLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERALWITHLANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERALWITHDT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GRAPHLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODEWITHID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODECOLLECTION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IMPLIES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IMPLIEDBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EQUALS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DOT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SEMICOLON">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COMMA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HASH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNDERSCORE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HATHAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTSQBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTSQBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTCURLYBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTCURLYBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EXCLAMATION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASSIGNMENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.QUESTION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PATH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDIS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDCUSTOM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDDEF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.VARIABLE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COMMENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASK">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CONSTRUCT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DESCRIBE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SELECT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ORDERBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LIMIT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OFFSET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DISTINCT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.REDUCED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FROM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NAMED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FROMNAMED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.WHERE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GRAPH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OPTIONAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FILTER">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ALL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DESC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HAVING">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GROUPBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EXISTS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTEXISTS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNSAID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MINUS_P">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SERVICE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BINDINGS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNDEF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANGMATCHES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SPARQLDATATYPE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BOUND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SAMETERM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISURI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISIRI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.REGEX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATATYPEFUNC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISBLANK">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRLANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRDT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IRI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COALESCE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.URIFUNC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PLUS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MINUS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DIVIDE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MULTIPLY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GREATERTHAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LESSTHAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GREATERTHANOREQUALTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LESSTHANOREQUALTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTEQUALS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NEGATION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BITWISEOR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COUNT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SUM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AVG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MAX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NMIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NMAX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MEDIAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MODE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GROUPCONCAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SAMPLE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SEPARATOR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LENGTH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.INSERT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DELETE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LOAD">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CLEAR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CREATE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DROP">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SILENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.INTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.WITH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.USING">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DEFAULT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlRdfParser">
            <summary>
            Parser for reading SPARQL Results which have been encoded in the RDF schema for Result Sets and serialized as RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a SPARQL Result Set from RDF contained in the given Stream
            </summary>
            <param name="results">SPARQL Result Set to populate</param>
            <param name="input">Stream to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> which will use simple heuristics to 'guess' the format of the RDF
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Loads a SPARQL Result Set from RDF contained in the given File
            </summary>
            <param name="results">SPARQL Result Set to populate</param>
            <param name="filename">File to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.FileLoader">FileLoader</see> to load the RDF from the file which will attempt to determine the format of the RDF based on the file extension
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Parse(VDS.RDF.Query.SparqlResultSet,VDS.RDF.Graph)">
            <summary>
            Internal method which actually parses the Result Set by traversing the RDF Graph appropriately
            </summary>
            <param name="results">SPARQL Result Set to populate</param>
            <param name="g">RDF Graph of the Result Set</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.DomBasedEventGenerator">
            <summary>
            A DOM Based event generator for RDF/XML parser that uses System.Xml DOM to parse events
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IPreProcessingEventGenerator">
            <summary>
            Interface for event generators which generate all events in one go prior to parsing taking place
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IPreProcessingEventGenerator.GetAllEvents(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Gets all the Events
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.#ctor(System.Xml.XmlDocument)">
            <summary>
            Creates a new DOM Based event generator
            </summary>
            <param name="document">XML Document</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new DOM Based event generator
            </summary>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.#ctor(System.String)">
            <summary>
            Creates a new DOM Based event generator
            </summary>
            <param name="file">Input File</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.GetAllEvents(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Gets all events from the XML DOM
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.GenerateEventTree(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,System.Xml.XmlNode)">
            <summary>
            Given an XML Node that is the Root of the RDF/XML section of the Document Tree creates the RootEvent and generates the rest of the Event Tree by recursive calls to the <see cref="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.GenerateEvents(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,System.Xml.XmlNode,VDS.RDF.Parsing.Events.IRdfXmlEvent)">GenerateEvents</see> method
            </summary>
            <param name="context">Parser Context</param>
            <param name="docEl">XML Node that is the Root of the RDF/XML section of the Document Tree</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.GenerateEvents(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,System.Xml.XmlNode,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Given an XML Node creates the relevant RDF/XML Events for it and recurses as necessary
            </summary>
            <param name="context">Parser Context</param>
            <param name="node">The Node to create Event(s) from</param>
            <param name="parent">The Parent Node of the given Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.IsIgnorableNode(System.Xml.XmlNode)">
            <summary>
            Checks whether a given XML Node can be discarded as it does not have any equivalent Event in the RDF/XML Syntax model
            </summary>
            <param name="node">XML Node to test</param>
            <returns>True if the Node can be ignored</returns>
            <remarks>Comment and Text Nodes are ignored.  Text Nodes will actually become Text Events but we'll access the Text using the InnerText property of the Element Nodes instead</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.DomBasedEventGenerator.FlattenEventTree(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IRdfXmlEvent,System.Int32)">
            <summary>
            Takes the Event Tree and Flattens it into a Queue as per the rules laid out in the RDF/XML Specification
            </summary>
            <param name="context">Parser Context</param>
            <param name="evt">Event which is the Root of the Tree (not necessarily a RootEvent)</param>
            <param name="nesting">A numeric value used for Parser Tracing to indicate nesting levels of the Event Tree</param>
        </member>
        <member name="T:VDS.RDF.Ontology.ReasonerGraph">
            <summary>
            Represents a Graph with a reasoner attached
            </summary>
            <remarks>
            <para>
            This class wraps an existing Graph and applies the given reasoner to it materialising the Triples in this Graph.  The original Graph itself is not modified but can be accessed if necessary using the <see cref="P:VDS.RDF.Ontology.ReasonerGraph.BaseGraph">BaseGraph</see> property
            </para>
            <para>
            Any changes to this Graph (via <see cref="M:VDS.RDF.IGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">Assert()</see> and <see cref="M:VDS.RDF.IGraph.Retract(VDS.RDF.Triple[])">Retract()</see>) affect this Graph - specifically the set of materialised Triples - rather than the original Graph around which this Graph is a wrapper
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyGraph">
            <summary>
            Represents a Graph with additional methods for extracting ontology based information from it
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.#ctor">
            <summary>
            Creates a new Ontology Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology resource in the Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource(System.Uri)">
            <summary>
            Gets/Creates an ontology resource in the Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource">
            <summary>
            Gets/Creates an anonymous ontology resource in the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology class in the Graph
            </summary>
            <param name="resource">Class Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass(System.Uri)">
            <summary>
            Gets/Creates an ontology class in the Graph
            </summary>
            <param name="resource">Class Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass">
            <summary>
            Gets/Creates an anonymous ontology class in the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyProperty(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology property in the Graph
            </summary>
            <param name="resource">Property Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyProperty(System.Uri)">
            <summary>
            Gets/Creates an ontology property in the Graph
            </summary>
            <param name="resource">Property Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(VDS.RDF.INode)">
            <summary>
            Gets an existing individual in the Graph
            </summary>
            <param name="resource">Individual Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets/Creates an individual in the Graph of the given class
            </summary>
            <param name="resource">Individual Resource</param>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(System.Uri)">
            <summary>
            Gets an existing individual in the Graph
            </summary>
            <param name="resource">Individual Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(System.Uri,System.Uri)">
            <summary>
            Gets/Creates an individual in the Graph of the given class
            </summary>
            <param name="resource">Individual Resource</param>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.#ctor(VDS.RDF.IGraph,VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Creates a new Reasoner Graph which is a wrapper around an existing Graph with a reasoner applied and the resulting Triples materialised
            </summary>
            <param name="g">Graph</param>
            <param name="reasoner">Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.#ctor(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Inference.IInferenceEngine})">
            <summary>
            Creates a new Reasoner Graph which is a wrapper around an existing Graph with multiple reasoners applied and the resulting Triples materialised
            </summary>
            <param name="g">Graph</param>
            <param name="reasoners">Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.Initialise">
            <summary>
            Internal method which initialises the Graph by applying the reasoners and setting the Node and Triple collections to be union collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.ReasonerGraph.BaseGraph">
            <summary>
            Gets the Base Graph which the reasoning is based upon
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyProperty">
            <summary>
            Class for representing a property in an Ontology
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Property for the given resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.#ctor(System.Uri,VDS.RDF.IGraph)">
            <summary>
            Creates a new RDFS Ontology Property for the given resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(VDS.RDF.INode)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(System.Uri)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearDomains">
            <summary>
            Clears all domains for the property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(VDS.RDF.INode)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(System.Uri)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(VDS.RDF.INode)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(System.Uri)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearRanges">
            <summary>
            Clears all ranges for the property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(VDS.RDF.INode)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(System.Uri)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.INode)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(System.Uri)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as an equivalent property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearEquivalentProperties">
            <summary>
            Clears all equivalent properties for this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.INode)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(System.Uri)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as an equivalent property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.INode)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(System.Uri)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as an inverse property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearInverseProperties">
            <summary>
            Removes all inverse properties for this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.INode)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(System.Uri)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as an inverse property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.INode)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(System.Uri)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as a super-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearSubProperties">
            <summary>
            Clears all sub-properties of this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.INode)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(System.Uri)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as a super-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.INode)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(System.Uri)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as a sub-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearSuperProperties">
            <summary>
            Removes all super-properties of this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.INode)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(System.Uri)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as a sub-property of the given property
            </remarks>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.Domains">
            <summary>
            Gets all the Classes which are in the properties Domain
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.Ranges">
            <summary>
            Gets all the Classes which are in this properties Range
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.EquivalentProperties">
            <summary>
            Gets all the equivalent properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.SubProperties">
            <summary>
            Gets the sub-properties of this property (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.SuperProperties">
            <summary>
            Gets the super-properties of this property (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.InverseProperties">
            <summary>
            Gets all the inverse properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.UsedBy">
            <summary>
            Gets all the resources that use this property
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterCompressionLevel">
            <summary>
            Class containing constants for possible Compression Levels
            </summary>
            <remarks>These are intended as guidance only, Writer implementations are free to interpret these levels as they desire or to ignore them entirely and use their own levels</remarks>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.None">
            <summary>
            No Compression should be used (-1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Minimal">
            <summary>
            Minimal Compression should be used (0)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Default">
            <summary>
            Default Compression should be used (1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Medium">
            <summary>
            Medium Compression should be used (3)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.More">
            <summary>
            More Compression should be used (5)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.High">
            <summary>
            High Compression should be used (10)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterErrorMessages">
            <summary>
            Class containing constants for standardised Writer Error Messages
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Graph Literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Unknown Node Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Subjects
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Blank Node Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnreducablePropertyURIUnserializable">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing URIs which cannot be reduced to a URIRef or QName as required by the serialization
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.MalformedCollectionWithMultipleFirsts">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing collections where a collection item has more than one rdf:first triple
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputError">
            <summary>
            Error messages produced when errors occur in a multi-threaded writing process
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Graph Literals are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Unknown Node Types are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Subjects are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Blank Node Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputFailure(System.String)">
            <summary>
            Gets an Error message indicating that a multi-threading writer process failed
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.TripleSegment">
            <summary>
            Indicates which Segment of a Triple Node Output is being generated for
            </summary>
            <remarks>Used by Writers to ensure restrictions on which Nodes can appear where in the syntax are enforced</remarks>
        </member>
        <member name="T:VDS.RDF.Writing.OutputRDFCollection">
            <summary>
            Class used to store Collections as part of the writing process for Compressing Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.OutputRDFCollection.#ctor(System.Boolean)">
            <summary>
            Creates a new Instance of a Collection
            </summary>
            <param name="explicitCollection">Whether the collection is explicit (specified using square bracket notation) or implicit (specified using normal parentheses)</param>
        </member>
        <member name="P:VDS.RDF.Writing.OutputRDFCollection.IsExplicit">
            <summary>
            Gets whether this is an Explicit collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NodeFormat">
            <summary>
            Possible Output Formats for Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.NTriples">
            <summary>
            Format for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.Turtle">
            <summary>
            Format for Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.Notation3">
            <summary>
            Format for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.UncompressedTurtle">
            <summary>
            Format for Uncompressed Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.UncompressedNotation3">
            <summary>
            Format for Uncompressed Notation 3
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterHelper">
            <summary>
            Helper methods for writers
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterHelper.StoreDefaultGraphURIs">
            <summary>
            Array of Default Graph URIs used by parsers which parse RDF dataset formats
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsValidBlankNodeID(System.String)">
            <summary>
            Determines whether a Blank Node ID is valid as-is when serialised in NTriple like syntaxes
            </summary>
            <param name="id">ID to test</param>
            <returns></returns>
            <remarks>If false is returned then the writer will alter the ID in some way</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsDefaultGraph(System.Uri)">
            <summary>
            Determines whether a given Uri refers to one of the Default Graph URIs assigned to the default Graph when parsing from some RDF dataset syntax
            </summary>
            <param name="u">Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.FindCollections(VDS.RDF.IGraph,VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method which finds Collections expressed in the Graph which can be compressed into concise collection syntax constructs in some RDF syntaxes
            </summary>
            <param name="g">Graph to find collections in</param>
            <param name="triplesDone">Triple Collection in which Triples that have been output are to be listed</param>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.FindCollections(VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext)">
            <summary>
            Helper method which finds Collections expressed in the Graph which can be compressed into concise collection syntax constructs in some RDF syntaxes
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.EncodeForXml(System.String)">
            <summary>
            Encodes values for use in XML
            </summary>
            <param name="value">Value to encode</param>
            <returns>
            The value with any ampersands escaped to &amp;
            </returns>
        </member>
        <member name="T:VDS.RDF.UriNode">
            <summary>
            Class for representing Uri Nodes
            </summary>
            <remarks>
            As of the 0.2.x API we removed the LocalName and Namespace properties since these were causing issues when Nodes were moved between Graphs
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.#ctor(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Internal Only Constructor for Uri Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="uri">Uri for the Node</param>
        </member>
        <member name="M:VDS.RDF.UriNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for Uri Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="qname">QName for the Node</param>
            <remarks>
            This Constructor tries to resolve the QName using the NamespaceMapper and Base Uri of the Graph it is in.  Exceptions may occur if we cannot resolve the QName correctly.
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.Equals(System.Object)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if the string form of their URIs match using Ordinal string comparison
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="other">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if the string form of their URIs match using Ordinal string comparison
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.ToString">
            <summary>
            Gets a String representation of a Uri as a plain text Uri
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UriNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of Compare To for Uri Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Uri Nodes are greater than Blank Nodes and Nulls, they are less than Literal Nodes and Graph Literal Nodes.
            <br /><br />
            Uri Nodes are ordered based upon lexical ordering of the string value of their URIs
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.CompareTo(VDS.RDF.UriNode)">
            <summary>
            Implementation of Compare To for URI Nodes
            </summary>
            <param name="other">URI Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="P:VDS.RDF.UriNode.Uri">
            <summary>
            Gets the Uri for this Node
            </summary>
        </member>
        <member name="P:VDS.RDF.UriNode.StringUri">
            <summary>
            Gets the Uri for this Node as a String
            </summary>
            <remarks>Computed at instantiation for efficiency, used in Equals implementation</remarks>
        </member>
        <member name="T:VDS.RDF.Writing.TriGWriter">
            <summary>
            Class for writing a Triple Store in named Graph TriG syntax to a file/stream
            </summary>
            <remarks>
            <para>
            For efficiency the TriG Writer splits it's writing over several threads (currently 4), these threads share a reference to a Context object which gives Global writing context eg. the target <see cref="T:System.IO.TextWriter">TextWriter</see> being written to.  Each thread generates temporary local writing contexts as it goes along, each of these is scoped to writing a specific Graph.  Graphs are written to a <see cref="T:VDS.RDF.Writing.StringWriter">StringWriter</see> so the output for each Graph is built completely and then written in one go to the <see cref="T:System.IO.TextWriter">TextWriter</see> specified as the target of the writing in the global context.
            </para>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call <see cref="M:VDS.RDF.Writing.TriGWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">Save()</see> from several threads with no issue.  See Remarks for potential performance impact of this.</threadsafety>
        </member>
        <member name="T:VDS.RDF.Writing.IHighSpeedWriter">
            <summary>
            Interface for Writers that Support engaging High Speed Write Mode for some Graphs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHighSpeedWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether the Writer can use High Speed Write Mode if the Graph is deemed suitable for this
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves a Store in TriG (Turtle with Named Graphs) format
            </summary>
            <param name="store">Store to save</param>
            <param name="parameters">Parameters indicating a Stream to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in TriG syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateTripleOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Triple as a String in Turtle syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for Nodes in Turtle syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode is permitted
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.TriGWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TriGWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.ITripleContext">
            <summary>
            An Interface for classes which provide Context Information for Triples thus allowing you to create Quads with arbitrary extra information attached to Triples via your Context Objects
            </summary>
            <remarks>
            A Triple Context is simply a name-value pair collection of arbitrary data that can be attached to a Triple.  Internal representation of this is left to the implementor.
            </remarks>
        </member>
        <member name="M:VDS.RDF.ITripleContext.HasProperty(System.String)">
            <summary>
            A Method which will indicate whether the Context contains some arbitrary property
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleContext.Item(System.String)">
            <summary>
            A Property which exposes the arbitrary properties of the Context as an Key Based Index
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BasicTripleContext">
            <summary>
            Class which implements a very basic Triple Context
            </summary>
            <remarks>
            The Name Value collection is represented internally as a Dictionary
            </remarks>
        </member>
        <member name="M:VDS.RDF.BasicTripleContext.#ctor">
            <summary>
            Creates a new Basic Triple Context without a Source
            </summary>
        </member>
        <member name="M:VDS.RDF.BasicTripleContext.HasProperty(System.String)">
            <summary>
            Checks whether a given property is defined in this Context object
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BasicTripleContext.Item(System.String)">
            <summary>
            Gets/Sets the value of a Property
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlQueryType">
            <summary>
            Types of SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Ask">
            <summary>
            Ask
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Construct">
            <summary>
            Constuct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.DescribeAll">
            <summary>
            Describe All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Select">
            <summary>
            Select
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectDistinct">
            <summary>
            Select Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectReduced">
            <summary>
            Select Reduced
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAll">
            <summary>
            Select All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAllDistinct">
            <summary>
            Select All Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAllReduced">
            <summary>
            Select All Reduced
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlSpecialQueryType">
            <summary>
            Types of Special SPARQL Query which may be optimised in special ways by the libraries SPARQL Engines
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.DistinctGraphs">
            <summary>
            The Query is of the form SELECT DISTINCT ?g WHERE {GRAPH ?g {?s ?p ?o}}
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.NotApplicable">
            <summary>
            The Query has no applicable special optimisation
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.SelectAll">
            <summary>
            The Query is of the form SELECT * WHERE {?s ?p ?o}
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlEngine">
            <summary>
            Available SPARQL Engines
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlEngine.Labyrinth">
            <summary>
            Labyrinth is the original SPARQL engine which is more mature but not fully SPARQL algebra compliant
            </summary>
            <remarks>
            <para>
            Due to being obsolete now the Leviathan engine has matured significantly the Labyrinth engine was removed for the Version 0.3.0 release
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.SparqlEngine.Leviathan">
            <summary>
            Leviathan is the newer and more powerful SPARQL engine which is based directly on the SPARQL algebra
            </summary>
            <remarks>
            <para>
            From Version 0.3.0 onwards Leviathan is the only SPARQL engine included in the library but the API has been enhanced so end users can introduce their own SPARQL engines or modify parts of the engines behaviour as they desire.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlQuery">
            <summary>
            Class for representing SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.#ctor">
            <summary>
            Creates a new SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.#ctor(System.Boolean)">
            <summary>
            Creates a new SPARQL Query
            </summary>
            <param name="subquery">Whether the Query is a Sub-query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.IsProjectionVariable(System.String)">
            <summary>
            Checks whether a Variable is a Projection Variable
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ProjectionVariable(System.String)">
            <summary>
            Gets the Projection Expression for a Projection Variable
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.SetQueryType(VDS.RDF.Query.SparqlQueryType)">
            <summary>
            Sets the Query Type
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(System.String,System.Boolean)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="name">Variable Name</param>
            <param name="isResultVar">Does the Variable occur in the Output Result Set/Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(VDS.RDF.Query.SparqlVariable)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="var">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddDescribeVariable(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Describe Variable to the Query
            </summary>
            <param name="var">Variable/Uri/QName Token</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddDefaultGraph(System.Uri)">
            <summary>
            Adds a Default Graph Uri
            </summary>
            <param name="u">Uri</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddNamedGraph(System.Uri)">
            <summary>
            Adds a Named Graph Uri
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Execute(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Executes the SPARQL Query against the given Triple Store
            </summary>
            <param name="data">Triple Store</param>
            <returns>Either a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the type of query executed</returns>
            <remarks>
            Obsolete method from the removed Labyrinth engine left in the API to allow existing code to be switched over gracefully to using the Evaluate() method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Evaluates the SPARQL Query against the given Triple Store
            </summary>
            <param name="data">Triple Store</param>
            <returns>
            Either a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the type of query executed
            </returns>
            <remarks>
            This method uses the more advanced and powerful Leviathan engine to evaluate queries
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Process(VDS.RDF.Query.ISparqlQueryProcessor)">
            <summary>
            Processes the Query using the given Query Processor
            </summary>
            <param name="processor">SPARQL Query Processor</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Optimise">
            <summary>
            Applies optimisation to a Query if it has not already been optimised
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.RewriteDescribeBNodes(VDS.RDF.Triple,System.Collections.Generic.Dictionary{System.String,VDS.RDF.INode},VDS.RDF.Graph)">
            <summary>
            Helper method which rewrites Blank Node IDs for Describe Queries
            </summary>
            <param name="t">Triple</param>
            <param name="mapping">Mapping of IDs to new Blank Nodes</param>
            <param name="g">Graph of the Description</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ToString">
            <summary>
            Generates a String representation of the Query
            </summary>
            <returns></returns>
            <remarks>This method may not return a complete representation of the Query depending on the Query it is called on as not all the classes which can be included in a Sparql query currently implement ToString methods</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ToAlgebra">
            <summary>
            Converts the Query into it's SPARQL Algebra representation (as represented in the Leviathan API)
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.BaseUri">
            <summary>
            Gets/Sets the Base Uri for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.DefaultGraphs">
            <summary>
            Gets the Default Graph URIs for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.NamedGraphs">
            <summary>
            Gets the Named Graph URIs for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Variables">
            <summary>
            Gets the Variables used in the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.DescribeVariables">
            <summary>
            Gets the Variables, QNames and URIs used in the Describe Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.QueryType">
            <summary>
            Gets the type of the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.SpecialType">
            <summary>
            Gets the Special Type of the Query (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.RootGraphPattern">
            <summary>
            Gets the top level Graph Pattern of the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.ConstructTemplate">
            <summary>
            Gets/Sets the Construct Template for a Construct Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.OrderBy">
            <summary>
            Gets/Sets the Ordering for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.GroupBy">
            <summary>
            Gets/Sets the Grouping for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Having">
            <summary>
            Gets/Sets the Having Clause for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Bindings">
            <summary>
            Gets/Sets the Bindings Clause for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Describer">
            <summary>
            Gets/Sets the <see cref="T:VDS.RDF.Query.Describe.ISparqlDescribe">ISparqlDescribe</see> which provides the Describe algorithm you wish to use
            </summary>
            <remarks>
            By default this will be the <see cref="T:VDS.RDF.Query.Describe.ConciseBoundedDescription">ConciseBoundedDescription</see> (CBD) algorithm.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Limit">
            <summary>
            Gets the Result Set Limit for the Query
            </summary>
            <remarks>Values less than zero are counted as -1 which indicates no limit</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Offset">
            <summary>
            Gets/Sets the Result Set Offset for the Query
            </summary>
            <remarks>Values less than zero are treated as 0 which indicates no offset</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Timeout">
            <summary>
            Gets/Sets the Query Execution Timeout in Milliseconds
            </summary>
            <remarks>
            <para>
            This Timeout (typically) only applies when executing the Query in memory.  If you have an instance of this class and pass its string representation (using <see cref="M:VDS.RDF.Query.SparqlQuery.ToString">ToString()</see>) you will lose the timeout information as this is not serialisable in SPARQL syntax.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.PartialResultsOnTimeout">
            <summary>
            Gets/Sets whether Partial Results should be returned in the event of Query Timeout
            </summary>
            <remarks>
            <para>
            Partial Results (typically) only applies when executing the Query in memory.  If you have an instance of this class and pass its string representation (using <see cref="M:VDS.RDF.Query.SparqlQuery.ToString">ToString()</see>) you will lose the partial results information as this is not serialisable in SPARQL syntax.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.QueryTime">
            <summary>
            Gets how long the Query took in Milliseconds
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.QueryTimeTicks">
            <summary>
            Gets how long the Query took in Ticks
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsAggregate">
            <summary>
            Gets whether the Query has an Aggregate as its Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsOptimised">
            <summary>
            Gets whether Optimisation has been applied to the query
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NTriplesTokeniser">
            <summary>
            Tokeniser for NTriples RDF Syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseTokeniser">
            <summary>
            Abstract Base Class for Tokeniser which handles the Position tracking
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ITokeniser">
            <summary>
            Interface for Tokenisers
            </summary>
            <remarks>
            A Tokeniser is a class that takes an input stream and produces textual tokens from it for use in token based parsers
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokeniser.GetNextToken">
            <summary>
            Causes the Tokeniser to attempt to retrieve the next Token
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if a valid Token cannot be parsed</exception>
            <exception cref="T:System.IO.IOException">Thrown if there is a problem reading the Input Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Constructor for the BaseTokeniser which takes in a TextReader that the Tokeniser will generate Tokens from
            </summary>
            <param name="reader">TextReader to generator Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.GetNextToken">
            <summary>
            Gets the Next available Token from the Input
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Parser Exception if a valid Token cannot be retrieved</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartNewToken">
            <summary>
            Informs the Helper that you wish to start reading a new Token
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Peek">
            <summary>
            Peeks at the next Character
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeCharacter">
            <summary>
            Consumes a single Character into the Output Buffer and increments the Position Counters
            </summary>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the caller tries to read beyond the end of the Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeNewLine(System.Boolean)">
            <summary>
            Consumes a New Line (which may be a single \n or \r or the two characters following each other)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.SkipCharacter">
            <summary>
            Skips a single Character and increments the Position Counters
            </summary>
            <remarks>Use when you are reading characters into some local buffer and not the global token buffer, used in String escaping</remarks>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the caller tries to read beyond the end of the Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.DiscardWhiteSpace">
            <summary>
            Helper function which discards White Space which the Tokeniser doesn't care about and increments position counters correctly
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.HandleEscapes(VDS.RDF.Parsing.Tokens.TokeniserEscapeMode)">
            <summary>
            Handles the standard escapes supported in all the  UTF-8 based RDF serializations
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.IsHexDigit(System.Char)">
            <summary>
            Determines whether a given Character can be valid as a Hex Digit
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Error(System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors
            </summary>
            <param name="detail">The Error Message</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.UnexpectedCharacter(System.Char,System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors about unexpected characters
            </summary>
            <param name="c">Unexpected Character</param>
            <param name="expected">Message detailing what was expected (may be empty if no explicit expectation)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Format">
            <summary>
            Gets/Sets the Format that this Tokeniser is used for
            </summary>
            <remarks>The value set here will replace any instances of {0} specified in inputs to the <see cref="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Error(System.String)">Error()</see> function allowing messages regarding certain syntaxes not being valid in a given format to be provided</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Value">
            <summary>
            Gets the value of the Output Buffer
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Length">
            <summary>
            Gets the current length of the Output Buffer
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.CurrentLine">
            <summary>
            Gets the Current Line in the Input Stream
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.CurrentPosition">
            <summary>
            Gets the Current Position in the Input Stream
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartLine">
            <summary>
            Gets the Start Line in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartPosition">
            <summary>
            Gets the Start Position in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.EndLine">
            <summary>
            Gets the End Line in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.EndPosition">
            <summary>
            Gets the End Position in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.LastTokenType">
            <summary>
            Gets/Sets the Last Token Type
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(VDS.RDF.Parsing.BlockingStreamReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.GetNextToken">
            <summary>
            Gets the next available Token from the Input Stream
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.NQuadsMode">
            <summary>
            Gets/Sets whether the output should be altered slightly to support NQuads parsing
            </summary>
            <remarks>
            <para>
            This is used internally to alter how DataTypes get tokenised, normally these are just returned as a <see cref="T:VDS.RDF.Parsing.Tokens.UriToken">UriToken</see> since a Literal can only occur as the Object in NTriples and so if we see a Uri after a Literal it must be it's datatype and not part of another Triple.
            </para>
            <para>
            In the case of NQuads a <see cref="T:VDS.RDF.Parsing.Tokens.UriToken">UriToken</see> may follow a Literal as the Context of that Triple and not its datatype so it's important to distinguish by using a <see cref="T:VDS.RDF.Parsing.Tokens.DataTypeToken">DataTypeToken</see> instead
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.TurtleWriter">
            <summary>
            Class for generating RDF in Turtle Syntax
            </summary>
            <remarks>
            Similar in speed to the <see cref="T:VDS.RDF.Writing.CompressingTurtleWriter">CompressingTurtleWriter</see> but doesn't use the full Blank Node and Collection syntax compressions
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to a File
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">Filename to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph using an arbitrary <see cref="T:System.IO.TextWriter">TextWriter</see>
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Writer to save using</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.GenerateOutput(VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Graph
            </summary>
            <param name="context">Context for writing the Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates the Output for a Node in Turtle Syntax
            </summary>
            <param name="context">Context for writing the Graph</param>
            <param name="n">Node to generate Output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.OnWarning(System.String)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.Writing.TurtleWriter.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.TurtleWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TurtleWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether the Writer is allowed to use High Speed write mode
            </summary>
            <remarks>High Speed Write Mode is engaged when the Writer determines that the contents of the Graph are not well suited to Turtle syntax compressions.  Usually the writer compresses triples into groups by Subject using Predicate-Object lists to output the Triples relating to each Subject.  If the number of distinct Subjects is greater than 75% of the Triples in the Graph then High Speed write mode will be used, in High Speed mode all Triples are written fully and no grouping of any sort is done.</remarks>
        </member>
        <member name="E:VDS.RDF.Writing.TurtleWriter.Warning">
            <summary>
            Event which is raised when a non-fatal issue with the Graph being serialized is encountered
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlRdfWriter">
            <summary>
            Class for saving SPARQL Result Sets in the RDF serialization in the RDF format of your choice (default Turtle)
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsWriter">
            <summary>
            Interface for Writer classes which serialize Sparql Result Sets into concrete results set syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves the Result Set to the given File
            </summary>
            <param name="results">Result Set to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.#ctor">
            <summary>
            Creates a new SPARQL RDF Writer which will save Result Sets in the RDF serialization using Turtle syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.#ctor(VDS.RDF.IRdfWriter)">
            <summary>
            Creates a new SPARQL RDF Writer which will save Result Sets in the RDF serialization in your chosen RDF Syntax
            </summary>
            <param name="writer">RDF Writer to use</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves the SPARQL Result Set to the given File
            </summary>
            <param name="results">Result Set to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the SPARQL Result Set to the given Stream
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Method which generates the RDF Graph of a SPARQL Result Set
            </summary>
            <param name="results">Result Set</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.FileSparqlHandlerConfiguration">
            <summary>
            Class for storing File Sparql Handler Configuration
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.InferencingSparqlHandlerConfiguration">
            <summary>
            Class for storing Sparql Handler configuration where Reasoners are supported
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.InferencingSparqlHandlerConfiguration._reasoners">
            <summary>
            Queue of Reasoners that should be applied to the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.InferencingSparqlHandlerConfiguration._ruleGraphs">
            <summary>
            Queue of URIs for associated Rules Graph used to intialise the Reasoners
            </summary>
            <remarks>
            Nulls are used for Reasoners that have no associated Rules Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.InferencingSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new Inferencing Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.InferencingSparqlHandlerConfiguration.HasReasoners">
            <summary>
            Gets whether there are any Reasoners loaded in the Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.FileSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new File Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.FileSparqlHandlerConfiguration.TripleStore">
            <summary>
            Gets the Triple Store that queries are executed against
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SparqlHttpProtocolConnector">
            <summary>
            Class for connecting to any store that implements the SPARQL Uniform HTTP Protocol for Managing Graphs
            </summary>
            <remarks>
            <para>
            The <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL Uniform HTTP Protocol for Managing Graphs</a> is defined as part of SPARQL 1.1 and is currently a working draft so implementations are not guaranteed to be fully compliant with the draft and the protocol may change in the future.
            </para>
            <para>
            <strong>Note:</strong> While this connector supports the update of a Graph the Uniform HTTP Protocol only allows for the addition of data to an existing Graph and not the removal of data, therefore any calls to <see cref="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> that would require the removal of Triple(s) will result in an error.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Uniform HTTP Protocol Connector
            </summary>
            <param name="serviceUri">URI of the Protocol Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Protocol Server
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Protocol Server
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Protocol Server
            </summary>
            <param name="g">Graph to save</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph on the Protocol Server
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            <strong>Note:</strong> The SPARQL Uniform HTTP Protocol for Graph Management only supports the addition of Triples to a Graph and does not support removal of Triples from a Graph.  If you attempt to remove Triples then an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph on the Protocol Server
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            <strong>Note:</strong> The SPARQL Uniform HTTP Protocol for Graph Management only supports the addition of Triples to a Graph and does not support removal of Triples from a Graph.  If you attempt to remove Triples then an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.Dispose">
            <summary>
            Disposes of the Connection
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.ToString">
            <summary>
            Gets a String representation of the connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateSupported">
            <summary>
            Gets that Updates are supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.IsReady">
            <summary>
            Gets that the Store is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.IsReadOnly">
            <summary>
            Gets that the Store is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.UnsupportedService">
            <summary>
            Represents some Service provided by a Pellet Server which the library does not explicitly support
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.UnsupportedService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Unsupported Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BoundFunction">
            <summary>
            Class representing the SPARQL BOUND() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BoundFunction.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new Bound() function expression
            </summary>
            <param name="varExpr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BoundFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BoundFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.DataTypeFunction">
            <summary>
            Class representing the SPARQL Datatype() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.DataTypeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Datatype() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.DataTypeFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.DataTypeFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.DataTypeFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IriFunction">
            <summary>
            Class representing the SPARQL IRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IriFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IriFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IsBlankFunction">
            <summary>
            Class representing the Sparql IsBlank() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsBlankFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsBlank() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsBlankFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsBlankFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IsIriFunction">
            <summary>
            Class representing the Sparql IsIRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsIriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsIRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsIriFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsIriFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IsLiteralFunction">
            <summary>
            Class representing the Sparql IsLiteral() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsLiteralFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsLiteral() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsLiteralFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsLiteralFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IsUriFunction">
            <summary>
            Class representing the Sparql IsURI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsURI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IsUriFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LangFunction">
            <summary>
            Class representing the Sparql Lang() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Lang() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LangMatchesFunction">
            <summary>
            Class representing the Sparql LangMatches() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangMatchesFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new LangMatches() function expression
            </summary>
            <param name="term">Expression to obtain the Language of</param>
            <param name="langRange">Expression representing the Language Range to match</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangMatchesFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LangMatchesFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.SameTermFunction">
            <summary>
            Class representing the Sparql SameTerm() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SameTermFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SameTerm() function expression
            </summary>
            <param name="term1">First Term</param>
            <param name="term2">Second Term</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SameTermFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SameTermFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.StrFunction">
            <summary>
            Class representing the Sparql Str() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Str() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.StrDtFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrDtFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRDT() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="dtExpr">Datatype Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrDtFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrDtFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrDtFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.StrLangFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrLangFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRLANG() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="langExpr">Language Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrLangFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrLangFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.StrLangFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.RegexFunction">
            <summary>
            Class representing the Sparql Regex() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
            <param name="options">Regular Expression Options</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.ConfigureOptions(VDS.RDF.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.RegexFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.RegexFunction.Variables">
            <summary>
            Gets the enumeration of Variables involved in this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BaseMultiset">
            <summary>
            Abstract Base Class for representing Multisets
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Join combines two multisets that are not disjoint
            </summary>
            <param name="other">Multiset to join with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Left Join combines two multisets where the join is predicated on an arbitrary expression
            </summary>
            <param name="other">Multiset to join with</param>
            <param name="expr">Expression on which the Join is predicated</param>
            <returns></returns>
            <remarks>
            Used for doing OPTIONALs
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Exists Join is the equivalent of Left Join where the Join is predicated on the existence/non-existince of an appropriate join candidate in the other multiset
            </summary>
            <param name="other">Multiset to join with</param>
            <param name="mustExist">Whether a valid join candidate must exist in the other multiset for sets from this multiset to be kept</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Minus Join is a special type of Join which only preserves sets from this Multiset which cannot be joined to the other Multiset
            </summary>
            <param name="other">Multiset to join with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Product combines two multisets that are disjoint
            </summary>
            <param name="other">Multiset to join with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Union combines two concatenates two mutlisets
            </summary>
            <param name="other">Multiset to concatenate with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Determines whether the Multiset contains the given Value for the given Variable
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ContainsVariable(System.String)">
            <summary>
            Determines whether the Multiset contains the given Variable
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Determines whether the Mutliset is disjoint with the given Multiset
            </summary>
            <param name="other">Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Add(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Adds a Set to the Mutliset
            </summary>
            <param name="s">Set to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Multiset
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set (by ID) from the Multiset
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Sort(System.Collections.Generic.IComparer{VDS.RDF.Query.Algebra.Set})">
            <summary>
            Sorts the Multiset
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Trim">
            <summary>
            Trims the Multiset of Temporary Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Trim(System.String)">
            <summary>
            Trims the Multiset by removing all Values for the given Variable
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.IsEmpty">
            <summary>
            Returns whether the Multiset is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Count">
            <summary>
            Gets the Count of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Variables">
            <summary>
            Gets the Variables in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Sets">
            <summary>
            Gets the Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.SetIDs">
            <summary>
            Gets the IDs of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Item(System.Int32)">
            <summary>
            Retrieves the Set with the given ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.FileLoader">
            <summary>
            A Class for loading RDF Files into Graphs/Triple Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.FileLoader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads the contents of the given File into a Graph providing the RDF format can be determined
            </summary>
            <param name="g">Graph to load into</param>
            <param name="filename">File to load from</param>
            <remarks>
            <para>
            The <see cref="T:VDS.RDF.Parsing.FileLoader">FileLoader</see> first attempts to select a RDF Parser by examining the file extension to select the most likely MIME type for the file.  This assumes that the file extension corresponds to one of the recognized file extensions for a RDF format the library supports.  If this suceeds then a parser is chosen and will be used to attempt to parse the input.
            </para>
            <para>
            Should this fail then the contents of the file will be read into a String, the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> is then used to attempt to parse it.  The <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> uses some simple rules to guess which format the input is likely to be and chooses a parser based on it's guess.
            </para>
            <para>
            <strong>Note:</strong> FileLoader will assign the Graph a file Uri prior to attempting Parsing, any Base Uri specified in the RDF contained in the file will override this Uri.
            </para>
            <para>
            The File Uri assigned will always be an absolute Uri for the File
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.FileLoader.Load(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Loads the contents of the given File into a Graph using the given RDF Parser
            </summary>
            <param name="g">Graph to load into</param>
            <param name="filename">File to load fro,</param>
            <param name="parser">Parser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.FileLoader.Load(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Loads the contents of the given File into a Triple Store providing the RDF dataset format can be determined
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="filename">File to load from</param>
            <remarks>
            The <see cref="T:VDS.RDF.Parsing.FileLoader">FileLoader</see> attempts to select a Store Parser by examining the file extension to select the most likely MIME type for the file.  This assume that the file extension corresponds to one of the recognized file extensions for a RDF dataset format the library supports.  If this suceeds then a parser is chosen and used to parse the input file.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.FileLoader.OnWarning(System.String)">
            <summary>
            Raises warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.FileLoader.OnStoreWarning(System.String)">
            <summary>
            Raises Store Warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Parsing.FileLoader.Warning">
            <summary>
            Event which is raised when the parser invoked by the FileLoader detects a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.FileLoader.StoreWarning">
            <summary>
            Event which is raised when the Store parser invoked by the FileLoader detects a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.EventQueue">
            <summary>
            Represents a Queue of <see cref="T:VDS.RDF.Parsing.Events.IRdfXmlEvent">IRdfXmlEvent</see>'s for use by RDF/XML parsers
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.EventQueue._events">
            <summary>
            Queue of Events
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.#ctor">
            <summary>
            Creates a new Event Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.#ctor(VDS.RDF.Parsing.Events.IEventGenerator)">
            <summary>
            Creates a new Event Queue with the given Event Generator
            </summary>
            <param name="generator">Event Generator</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.Dequeue">
            <summary>
            Dequeues and returns the next event in the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.Enqueue(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Adds an event to the end of the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.Peek">
            <summary>
            Peeks and returns the next event in the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue.Clear">
            <summary>
            Clears the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.EventQueue.Count">
            <summary>
            Gets the number of events currently in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.EventQueue.Events">
            <summary>
            Gets the underlying Queue of Events
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.StreamingEventQueue">
            <summary>
            Represents a Queue of <see cref="T:VDS.RDF.Parsing.Events.IRdfXmlEvent">IRdfXmlEvent</see>'s which are streamed from an instance of a <see cref="T:VDS.RDF.Parsing.Events.IJitEventGenerator">IJitEventGenerator</see> for use by RDF/XML parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue.#ctor(VDS.RDF.Parsing.Events.IJitEventGenerator)">
            <summary>
            Creates a new Streaming Event Queue
            </summary>
            <param name="generator">Event Generator</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue.Enqueue(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Adds an event to the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue.Dequeue">
            <summary>
            Gets the next event from the Queue and removes it from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue.Peek">
            <summary>
            Gets the next event from the Queue while leaving the Queue unchanged
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.StreamingEventQueue.Count">
            <summary>
            Gets the Count of events in the queue
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleIndexType">
            <summary>
            Possible Triple Index types
            </summary>
            <remarks>
            <para>
            Index types are given Integer values with the lowest being the least useful index and the highest being most useful index.
            </para>
            <para>
            When used to sort Patterns as part of query optimisation the patterns are partially ordered on the usefullness of their index since more useful indexes are considered more likely to return fewer results which will help restrict the query space earlier in the execution process.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.NoVariables">
            <summary>
            No Index should be used as the Pattern does not use Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.None">
            <summary>
            No Index should be used as the Pattern is three Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Subject">
            <summary>
            Subject Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Predicate">
            <summary>
            Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Object">
            <summary>
            Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectPredicate">
            <summary>
            Subject-Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.PredicateObject">
            <summary>
            Predicate-Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectObject">
            <summary>
            Subject-Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SpecialFilter">
            <summary>
            The Pattern is actually a FILTER
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SpecialAssignment">
            <summary>
            The Pattern is actually a LET assignment
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SpecialSubQuery">
            <summary>
            The Pattern is actually a Sub-query
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SpecialPropertyPath">
            <summary>
            The Pattern is actually a Property Path
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleIndexSorter">
            <summary>
            A Comparer which sorts based on Triple Index Type
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleIndexSorter.Compare(VDS.RDF.TripleIndexType,VDS.RDF.TripleIndexType)">
            <summary>
            Compares two Triple Index types to see which is greater
            </summary>
            <param name="x">First Index type</param>
            <param name="y">Second Index type</param>
            <returns></returns>
            <remarks>
            Implemented by converting to Integers and then using the Integer comparison function
            </remarks>
        </member>
        <member name="T:VDS.RDF.QueryableGraph">
            <summary>
            Class for representing Graphs which can be directly queried using SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.#ctor">
            <summary>
            Creates a new Queryable Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Graph
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Graph
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParseType">
            <summary>
            Possible RDF/XML Parse Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.None">
            <summary>
            No specific Parse Type is specified (Default Parsing Rules will be used)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Literal">
            <summary>
            Literal Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Resource">
            <summary>
            Resource Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Collection">
            <summary>
            Collection Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Other">
            <summary>
            Other Parse Type
            </summary>
            <remarks>This is never used since any other Parse Type encountered is assumed to be Literal as per the RDF/XML Specification</remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParserMode">
            <summary>
            Possible RDF/XML Parser Modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParserMode.DOM">
            <summary>
            Uses DOM Based parsing
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParserMode.Streaming">
            <summary>
            Uses Streaming Based parsing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParser">
            <summary>
            Parser for RDF/XML syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.#ctor">
            <summary>
            Creates a new RDF/XML Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.#ctor(VDS.RDF.Parsing.RdfXmlParserMode)">
            <summary>
            Creates a new RDF/XML Parser which uses the given parsing mode
            </summary>
            <param name="mode">RDF/XML Parse Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Reads RDF/XML syntax from some Stream into the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Reads RDF/XML syntax from some File into the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="filename">Filename of File containg XML/RDF</param>
            <remarks>Simply opens a Stream for the File then calls the other version of Load to do the actual parsing</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IGraph,System.Xml.XmlDocument)">
            <summary>
            Reads RDF/XML from the given XML Document
            </summary>
            <param name="g">Graph to load into</param>
            <param name="document">XML Document</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Parse(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Function which does the actual Parsing by invoking the various steps of the Parser
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ProcessEventQueue(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Starts the Parsing of the flattened Event Tree by calling the appropriate Grammar Production based on the type of the First Event in the Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionDoc(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RootEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'doc'
            </summary>
            <param name="context">Parser Context</param>
            <param name="root">Root Event to start applying Productions from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionRDF(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.ElementEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'RDF'
            </summary>
            <param name="context">Parser Context</param>
            <param name="element">RDF Element to apply Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionNodeElementList(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'nodeElementList'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events to apply the Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionNodeElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'nodeElement'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Node Element and its Children to apply the Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionPropertyElementList(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'propertyEltList'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events to apply the Production to</param>
            <param name="parent">Parent Event (ie. Node) of the Property Elements</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'propertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionResourcePropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'resourcePropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Resource Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionLiteralPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'literalPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Literal Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeLiteralPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeLiteralPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Literal Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeResourcePropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeResourcePropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Resource Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeCollectionPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeCollectionPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Collection Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionEmptyPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.ElementEvent,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'emptyPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="element">Element Event for the Empty Property Element</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ApplyNamespaces(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.ElementEvent)">
            <summary>
            Applies the Namespace Attributes of an Element Event to the Namespace Map
            </summary>
            <param name="context">Parser Context</param>
            <param name="evt">Element Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Resolve(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.UriReferenceEvent,System.String)">
            <summary>
            Resolves a Uri Reference into a Uri Node against a given Base Uri
            </summary>
            <param name="context">Parser Context</param>
            <param name="uriref">Uri Reference to Resolve</param>
            <param name="baseUri">Base Uri to Resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Reify(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.UriNode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Reifies a Triple
            </summary>
            <param name="context">Parser Context</param>
            <param name="uriref">Uri Reference for the Reified Triple</param>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.QueueJump(VDS.RDF.Parsing.Events.IEventQueue,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which inserts an Element back on the front of a Queue
            </summary>
            <param name="eventlist">Queue to insert onto the Front of</param>
            <param name="evt">Event to put on the front of the Queue</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ListExpand(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Applies List Expansion to the given Event
            </summary>
            <param name="evt">Element to apply List Expansion to</param>
            <returns>Uri Reference for the List Item</returns>
            <remarks>List Expansion only works on Element Events</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ValidateID(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,System.String,VDS.RDF.INode)">
            <summary>
            Validates that an ID is correctly formed and has only been used once in the context of a given Subject
            </summary>
            <param name="context">Parser Context</param>
            <param name="id">ID to Validate</param>
            <param name="subj">Subject that the ID pertains to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ProductionTrace(System.String)">
            <summary>
            Tracing function used when Parse Tracing is enabled
            </summary>
            <param name="production"></param>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfXmlParser.TraceParsing">
            <summary>
            Controls whether Parser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.RdfXmlParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.Event">
            <summary>
            Static Classes which define the Event Types for XML Events
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Root">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Clear">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Element">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.EndElement">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Attribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.NamespaceAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.LanguageAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.ParseTypeAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.XmlBaseAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Text">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.UriReference">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.QName">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.BlankNodeID">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.Literal">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.Event.TypedLiteral">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RootEvent">
            <summary>
            Event representing the Root Node of the Document
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseEvent">
            <summary>
            Abstract Base Class for IRdfXmlEvent implementations
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEvent.#ctor(System.Int32,System.String)">
            <summary>
            Creates an Event and fills in its Values
            </summary>
            <param name="eventType">Type of the Event</param>
            <param name="sourceXML">Source XML that generated the Event</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEvent.EventType">
            <summary>
            Gets the Type for this Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEvent.SourceXml">
            <summary>
            Gets the XML that this Event was generated from
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RootEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Root Event
            </summary>
            <param name="baseUri">Base Uri of the Document</param>
            <param name="sourceXml">Source XML of the Document</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RootEvent.DocumentElement">
            <summary>
            Gets/Sets the ElementEvent that represents the actual DocumentElement
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RootEvent.Children">
            <summary>
            Gets all the Child ElementEvents of the Document Root
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RootEvent.BaseUri">
            <summary>
            Gets the Base Uri of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RootEvent.Language">
            <summary>
            Gets the Language of the Node
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.ElementEvent">
            <summary>
            Event representing a Node from the XML Document
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ElementEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Element Event
            </summary>
            <param name="qname">QName of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXml">Source XML of the XML Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ElementEvent.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates new Element Event
            </summary>
            <param name="localname">Local Name of the XML Node</param>
            <param name="ns">Namespace Prefix of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXML">Source XML of the XML Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ElementEvent.SetUri(VDS.RDF.Parsing.Events.UriReferenceEvent)">
            <summary>
            Method which sets the Uri for this Element Event
            </summary>
            <param name="u">Uri Reference to set Uri from</param>
            <remarks>This can only be used on Elements which are rdf:li and thus need expanding into actual list elements according to List Expansion rules.  Attempting to set the Uri on any other Element Event will cause an Error message.</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ElementEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.LocalName">
            <summary>
            Gets the Local Name of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.Namespace">
            <summary>
            Gets the Namespace of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.QName">
            <summary>
            Gets the QName of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.Children">
            <summary>
            Gets the Child Element Events 
            </summary>
            <remarks>These correspond to the Child Nodes of the XML Node</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.BaseUri">
            <summary>
            Gets/Sets the Base Uri of the XML Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.Attributes">
            <summary>
            Gets the Attribute Events
            </summary>
            <remarks>These correspond to the Attributes of the XML Node (with some exceptions as defined in the RDF/XML specification)</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.NamespaceAttributes">
            <summary>
            Gets the Namespace Attribute Events
            </summary>
            <remarks>
            These correspond to all the Namespace Attributes of the XML Node
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.ListCounter">
            <summary>
            Gets/Sets the List Counter
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.Language">
            <summary>
            Gets/Sets the Language of this Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.Subject">
            <summary>
            Gets/Sets the Subject Event of this Event
            </summary>
            <remarks>Will be assigned according to the Parsing rules during the Parsing process and later used to generate a Subject Node</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.SubjectNode">
            <summary>
            Gets/Sets the Subject Node of this Event
            </summary>
            <remarks>Will be created from the Subject at some point during the Parsing process</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ElementEvent.ParseType">
            <summary>
            Gets/Sets the Parse Type for this Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.EndElementEvent">
            <summary>
            An Event for representing the End of Elements
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EndElementEvent.#ctor">
            <summary>
            Creates a new EndElementEvent
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.AttributeEvent">
            <summary>
            An Event for representing Attributes of XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.AttributeEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="qname">QName of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXML">Source XML of the Attribute</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.AttributeEvent.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="localname">Local Name of the Attribute</param>
            <param name="ns">Namespace Prefix of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXML">Source XML of the Attribute</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.AttributeEvent.LocalName">
            <summary>
            Gets the Local Name of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.AttributeEvent.Namespace">
            <summary>
            Gets the Namespace Prefix of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.AttributeEvent.QName">
            <summary>
            Gets the QName of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.AttributeEvent.Value">
            <summary>
            Gets the Value of the Attribute
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.NamespaceAttributeEvent">
            <summary>
            An Event for representing Namespace Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.NamespaceAttributeEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Namespace Attribute Event
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.NamespaceAttributeEvent.Prefix">
            <summary>
            Gets the Namespace Prefix
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.NamespaceAttributeEvent.Uri">
            <summary>
            Gets the Namespace Uri
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.LanguageAttributeEvent">
            <summary>
            An Event for representing Language Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.LanguageAttributeEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Language Attribute Event
            </summary>
            <param name="lang">Language</param>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.LanguageAttributeEvent.Language">
            <summary>
            Gets the Language
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.ParseTypeAttributeEvent">
            <summary>
            An Event for representing rdf:parseType Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ParseTypeAttributeEvent.#ctor(VDS.RDF.Parsing.RdfXmlParseType,System.String)">
            <summary>
            Creates a new Parse Type Attribute Event
            </summary>
            <param name="type">Parse Type</param>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.ParseTypeAttributeEvent.ParseType">
            <summary>
            Gets the Parse Type
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.XmlBaseAttributeEvent">
            <summary>
            An Event for representing xml:base attributes of XML Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.XmlBaseAttributeEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new XML Base Attribute
            </summary>
            <param name="baseUri">Base URI</param>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.XmlBaseAttributeEvent.BaseUri">
            <summary>
            Gets the Base URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.TextEvent">
            <summary>
            Event for representing plain text content (XML Text Nodes)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.TextEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Text Node
            </summary>
            <param name="value">Textual Content of the XML Text Node</param>
            <param name="sourceXML">Source XML of the Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.TextEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.TextEvent.Value">
            <summary>
            Gets the Textual Content of the Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.UriReferenceEvent">
            <summary>
            Event for representing URIRefs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.UriReferenceEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new URIRef Event from a URIRef in an XML Attribute value or similar
            </summary>
            <param name="identifier">URIRef</param>
            <param name="sourceXML">Source XML of the URIRef</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.UriReferenceEvent.Identifier">
            <summary>
            Gets the URIRef
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.QNameEvent">
            <summary>
            Event for representing QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.QNameEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new QName Event
            </summary>
            <param name="qname">QName</param>
            <param name="sourceXML">Source XML of the QName</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.QNameEvent.QName">
            <summary>
            Gets the QName
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BlankNodeIDEvent">
            <summary>
            Event for representing the need for a Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BlankNodeIDEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Blank Node ID Event for a named Blank Node
            </summary>
            <param name="identifier">Node ID for the Blank Node</param>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BlankNodeIDEvent.#ctor(System.String)">
            <summary>
            Creates a new Blank Node ID Event for an anonymous Blank Node
            </summary>
            <param name="sourceXML">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BlankNodeIDEvent.Identifier">
            <summary>
            Gets the Blank Node ID (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.PlainLiteralEvent">
            <summary>
            An Event for representing Plain Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.PlainLiteralEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Plain Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="language">Language Specifier of the Literal</param>
            <param name="sourceXML">Source XML of the Event</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.PlainLiteralEvent.Value">
            <summary>
            Gets the Value of the Plain Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.PlainLiteralEvent.Language">
            <summary>
            Gets the Langugage Specifier of the Plain Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.TypedLiteralEvent">
            <summary>
            An Event for representing Typed Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.TypedLiteralEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Typed Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="datatype">DataType Uri of the Literal</param>
            <param name="sourceXML">Source XML of the Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.TypedLiteralEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.TypedLiteralEvent.Value">
            <summary>
            Gets the Value of the Typed Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.TypedLiteralEvent.DataType">
            <summary>
            Gets the DataType of the Typed Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.ClearQueueEvent">
            <summary>
            An Event for representing that the Event Queue should be cleared of previously queued events
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.ClearQueueEvent.#ctor">
            <summary>
            Creates a new Clear Queue Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TurtleTokeniser">
            <summary>
            A Class for Reading an Input Stream and generating Turtle Tokens from it
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TurtleTokeniser.ValidPlainLiteralsPattern">
            <summary>
            Pattern for Valid Plain (Unquoted) Literal Formats
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(VDS.RDF.Parsing.BlockingStreamReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetDirectiveToken">
            <summary>
            Internal Helper method which attempts to get a Directive Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetPrefixToken">
            <summary>
            Internal Helper method which attempts to get a Prefix Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetQNameToken">
            <summary>
            Internal Helper method which attempts to get a QName Token
            </summary>
            <returns></returns>
            <remarks>In fact this function may return a number of Tokens depending on the characters it finds.  It may find a QName, Plain Literal, Blank Node QName (with ID) or Keyword.  QName &amp; Keyword Validation is carried out by this function</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetLanguageSpecToken">
            <summary>
            Internal Helper method which attempts to get a Language Specifier Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetDataTypeToken">
            <summary>
            Internal Helper method which attempts to get a Date Type Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetCommentToken">
            <summary>
            Internal Helper method which attempts to get a Comment Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.IsValidPlainLiteral(System.String)">
            <summary>
            Determines whether a given String is a valid Plain Literal
            </summary>
            <param name="value">The String to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.RdfXmlTreeWriter">
            <summary>
            Class for generating RDF/XML Concrete Syntax
            </summary>
            <remarks>
            <para>
            This is a non-streaming Writer which generates an XML DOM Tree and then saves it to a Stream
            </para>
            <para>
            Since this Writer is non-streaming it may be slower particularly for large Graphs since it has to build the entire XML DOM Tree for the output before it can be saved to disk.  While this may be a slight disadvantage this writer is capable of applying more of the RDF/XML syntax compressions than the standard streaming <see cref="T:VDS.RDF.Writing.RdfXmlWriter">RdfXmlWriter</see> because it can alter the parts of the DOM Tree it has already generated.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.ICompressingWriter">
            <summary>
            Interface for Writers that Support varying levels of Syntax Compression
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.ICompressingWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level that the Writer is using
            </summary>
            <remarks>Compression Level is an arbitrary figure that the Writer can interpret as it wants, implementations of this interface should state in the XML Comments for this property what the different values mean.  The Standard Compression levels provided by the <see cref="T:VDS.RDF.Writing.WriterCompressionLevel">WriterCompressionLevel</see> enumeration are intended as guides and Writers may interpret these as they desire.</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlTreeWriter.#ctor">
            <summary>
            Creates a new RDF/XML Tree Writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlTreeWriter.#ctor(System.Int32)">
            <summary>
            Creates a new RDF/XML Tree Writer using the given Compression Level
            </summary>
            <param name="compressionLevel">Compression Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlTreeWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph as RDF/XML to the given File
            </summary>
            <param name="g">Graph to Save</param>
            <param name="filename">Filename of the File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlTreeWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph as RDF/XML to the given Stream
            </summary>
            <param name="g">Graph to Save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlTreeWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method for handling raising of the <see cref="E:VDS.RDF.Writing.RdfXmlTreeWriter.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlTreeWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level
            </summary>
            <remarks>Uses the same Compression Levels as the <see cref="T:VDS.RDF.Writing.RdfXmlWriter">RdfXmlWriter</see></remarks>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlTreeWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether the RDF/XML output should be pretty printed
            </summary>
            <remarks>Controls whether the RDF/XML produced is indented to be human readable, enabled by default</remarks>
        </member>
        <member name="E:VDS.RDF.Writing.RdfXmlTreeWriter.Warning">
            <summary>
            Event which is raised when the Writer detects a non-fatal issue with the Graph being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.ExactClassSelector">
            <summary>
            Selector which finds all Triples where the Subject is of a given Class
            </summary>
        </member>
        <member name="T:VDS.RDF.ISelector`1">
            <summary>
            Interface for defining arbitrary Selectors for Selecting Nodes and Triples from Graphs
            </summary>
            <typeparam name="T">Type to perform Selection upon</typeparam>
        </member>
        <member name="M:VDS.RDF.ISelector`1.Accepts(`0)">
            <summary>
            Method which determines whether an Object of the given Type is accepted by this Selector
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExactClassSelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new ExactClassSelector for the given Graph with the given Target Class
            </summary>
            <param name="g"></param>
            <param name="targetClass"></param>
        </member>
        <member name="M:VDS.RDF.Query.ExactClassSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdf:type and the Object is the Target Class that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SubClassSelector">
            <summary>
            Selector which finds all Triples which define SubClasses of the given Class
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SubClassSelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new SubClassSelector for the given Graph with the given Target Class
            </summary>
            <param name="g"></param>
            <param name="targetClass"></param>
        </member>
        <member name="M:VDS.RDF.Query.SubClassSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdfs:subClassOf and the Object is the Target Class that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SuperClassSelector">
            <summary>
            Selector which finds all Triples where define SuperClasses of the given Class
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SuperClassSelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new SuperClassSelector for the given Graph with the given Target Class
            </summary>
            <param name="g"></param>
            <param name="targetClass"></param>
        </member>
        <member name="M:VDS.RDF.Query.SuperClassSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdfs:subClassOf and the Subject is the Target Class that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.ClassSelector">
            <summary>
            Selector which finds all Triples where the Subject is of a given Class (or subclass thereof)
            </summary>
            <remarks>
            This Class will not automatically apply the standard RDF Schema class hierarchy unless it has been defined in the Graph explicitly
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.ClassSelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new Class Selector for the given Graph and Target Class
            </summary>
            <param name="g">Graph to infer Class Hierarchy from</param>
            <param name="targetClass">Target Class which you want to find all Sub Classes of</param>
        </member>
        <member name="M:VDS.RDF.Query.ClassSelector.InferSubClasses(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Helper method which performs Inference on the Graph to determine all subclasses of the Target Class
            </summary>
            <param name="g">Graph to perform inference on</param>
            <param name="parent">The Class to find SubClasses of</param>
            <remarks>This method is called when the Selector is instantiated and will be called recursively till it has found all SubClasses defined within the given Graph</remarks>
        </member>
        <member name="M:VDS.RDF.Query.ClassSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdf:type and the Object is the Target Class that this Selector was instantiated with (or subclass thereof)
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.WideningClassSelector">
            <summary>
            Selector which finds all Triples where the Subject is of a given Class (or superclass thereof)
            </summary>
            <remarks>
            This Class will not automatically apply the standard RDF Schema class hierarchy unless it has been defined in the Graph explicitly
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.WideningClassSelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new Widening Class Selector for the given Graph and Target Class
            </summary>
            <param name="g">Graph to infer Class Hierarchy from</param>
            <param name="targetClass">Target Class which you want to find all Super Classes of</param>
        </member>
        <member name="M:VDS.RDF.Query.WideningClassSelector.InferSuperClasses(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Helper method which performs Inference on the Graph to determine all superclasses of the Target Class
            </summary>
            <param name="g">Graph to perform inference on</param>
            <param name="parent">The Class to find SuperClasses of</param>
            <remarks>This method is called when the Selector is instantiated and will be called recursively till it has found all SuperClasses defined within the given Graph</remarks>
        </member>
        <member name="M:VDS.RDF.Query.WideningClassSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdf:type and the Object is the Target Class that this Selector was instantiated with (or superclass thereof)
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasExactPropertySelector">
            <summary>
            Selector which finds all Triples where the Predicate is a given Property
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasExactPropertySelector.#ctor(VDS.RDF.UriNode)">
            <summary>
            Creates a new HasExactPropertySelector which will select Triples with the given Property as the Predicate
            </summary>
            <param name="targetProperty">The Property Triples to be selected must contain as their Predicate</param>
        </member>
        <member name="M:VDS.RDF.Query.HasExactPropertySelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the Target Property that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SubPropertySelector">
            <summary>
            Selector which finds all Triples where the Subject is defined as a SubProperty of a given Property
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SubPropertySelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new SubPropertySelector for the given Graph with the given Target Property
            </summary>
            <param name="g">Graph selection will occur in</param>
            <param name="targetProperty">Property you wish to select upon</param>
        </member>
        <member name="M:VDS.RDF.Query.SubPropertySelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is rdfs:subPropertyOf and the Object is the Target Property that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertySelector">
            <summary>
            Selector which finds all Triples where the Predicate is a given Property (or subproperty thereof)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertySelector.#ctor(VDS.RDF.Graph,VDS.RDF.UriNode)">
            <summary>
            Creates a new Has Property Selector for the given Graph and Target Property
            </summary>
            <param name="g">Graph to infer Property hierarchy</param>
            <param name="targetProperty">Target Property which you wish to find all sub properties of</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertySelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the Target Property (or subproperty thereof) that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.IDependentSelector`1">
            <summary>
            Interface for defining arbitrary Selectors which are dependant on the Results of a previous Selector
            </summary>
            <typeparam name="T">Type to perform Selection upon</typeparam>
        </member>
        <member name="M:VDS.RDF.IDependentSelector`1.Initialise(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Method used to initialise this Selector with the results of the previous Selector
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.PatternItem">
            <summary>
            Class for representing Node Patterns in Sparql Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.PatternItem._context">
            <summary>
            Binding Context for Pattern Item
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the Pattern Item accepts the given Node in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Node based on this Pattern for the given Set
            </summary>
            <param name="s">Set</param>
            <param name="preserveBNodes">Whether Blank Node IDs should be preserved</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.BindingContext">
            <summary>
            Sets the Binding Context for the Pattern Item
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.VariableName">
            <summary>
            Gets the Variable Name if this is a Variable Pattern or null otherwise
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.Repeated">
            <summary>
            Gets/Sets whether the Variable is repeated in the Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.VariablePattern">
            <summary>
            Pattern which matches Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.#ctor(System.String)">
            <summary>
            Creates a new Variable Pattern
            </summary>
            <param name="name">Variable name including the leading ?/$</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is a valid value for the Variable in the current Binding Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="s">Set</param>
            <param name="preserveBNodes">Whether BNode IDs should be preserved</param>
            <returns>The Node which is bound to this Variable in this Solution</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.ConstructInternal(VDS.RDF.INode,System.Boolean)">
            <summary>
            Constructs a Node based on the given Node
            </summary>
            <param name="value">Node</param>
            <param name="preserveBNodes">Whether BNode IDs should be preserved</param>
            <returns></returns>
            <remarks>
            Adjusts the ID of Blank Nodes appropriately
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.ToString">
            <summary>
            Gets the String representation of this pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.VariablePattern.VariableName">
            <summary>
            Gets the Name of the Variable this Pattern matches
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.NodeMatchPattern">
            <summary>
            Pattern which matches specific Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Node Match Pattern
            </summary>
            <param name="n">Exact Node to match</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node matches the Node this pattern was instantiated with
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="s">Set</param>
            <returns>The Node this pattern matches on</returns>
            <param name="preserveBNodes">Whether Blank Node IDs should be preserved</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.ToString">
            <summary>
            Gets a String representation of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.NodeMatchPattern.Node">
            <summary>
            Gets the Node that this Pattern matches
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BlankNodePattern">
            <summary>
            Pattern which matches Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.#ctor(System.String)">
            <summary>
            Creates a new Pattern representing a Blank Node
            </summary>
            <param name="name">Blank Node ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is a valid value for the Temporary Variable
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.Construct(VDS.RDF.Query.Algebra.Set,System.Boolean)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="s">Set</param>
            <param name="preserveBNodes">Whether Blank Node IDs should be preserved</param>
            <returns>A Blank Node whose ID is based on the ID of the Blank Node in the pattern and the Set ID of the Solution</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.ToString">
            <summary>
            Gets the String representation of this Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BlankNodePattern.ID">
            <summary>
            Gets the Blank Node ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BlankNodePattern.VariableName">
            <summary>
            Gets the Temporary Variable Name of this Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.BaseOrderBy">
            <summary>
            Base Class for implementing Sparql ORDER BYs
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">
            <summary>
            Interface for classes that represent SPARQL ORDER BY clauses
            </summary>
            <remarks>A SPARQL Order By clause provides a list of orderings, when parsed into the dotNetRDF model this is represented as a single <see cref="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">ISparqlOrderBy</see> for the first term in the clause chained to <see cref="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">ISparqlOrderBy</see>'s for each subsequent term via the <see cref="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Child">Child</see> property.</remarks>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Child">
            <summary>
            Gets/Sets the Child Ordering that applies if the two Objects are considered equal
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Context">
            <summary>
            Sets the Evaluation Context for the Order By
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Descending">
            <summary>
            Sets whether the Ordering is Descending
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._child">
            <summary>
            Holds the Child Order By (if any)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._context">
            <summary>
            Stores the Evaluation Context
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._modifier">
            <summary>
            Modifier used to make ordering Descending
            </summary>
            <remarks>Implementations derived from this class should multiply their comparison results by the modifier to automatically provide Ascending/Descending order</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.BaseOrderBy.Compare(VDS.RDF.Query.Algebra.Set,VDS.RDF.Query.Algebra.Set)">
            <summary>
            Abstract Compare method which derived classes should implement their ordering in
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.BaseOrderBy.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Child">
            <summary>
            Gets/Sets the Child Order By
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Context">
            <summary>
            Sets the Evaluation Context for the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Descending">
            <summary>
            Sets the Ordering to Descending
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.OrderByVariable">
            <summary>
            An ORDER BY which orders on the values bound to a particular variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.#ctor(System.String)">
            <summary>
            Creates a new Ordering based on the Value of a given Variable
            </summary>
            <param name="name">Variable to order upon</param>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.Compare(VDS.RDF.Query.Algebra.Set,VDS.RDF.Query.Algebra.Set)">
            <summary>
            Compares Sets on the basis of their values for the Variable the class was instaniated with
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.OrderByExpression">
            <summary>
            An ORDER BY which orders based on the values of a Sparql Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Order By using the given Expression
            </summary>
            <param name="expr">Expression to order by</param>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.Compare(VDS.RDF.Query.Algebra.Set,VDS.RDF.Query.Algebra.Set)">
            <summary>
            Orders the sets based on the values resulting from evaluating the expression for both solutions
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.TurtleSpecsHelper">
            <summary>
            Helper function relating to the Turtle Specifications
            </summary>
            <remarks>Not currently used in the actual <see cref="T:VDS.RDF.Parsing.Tokens.TurtleTokeniser">TurtleTokeniser</see> or <see cref="T:VDS.RDF.Parsing.TurtleParser">TurtleParser</see> but is used for the new <see cref="T:VDS.RDF.Parsing.Tokens.TriGTokeniser">TriGTokeniser</see></remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidIntegerPattern">
            <summary>
            Pattern for Valid Integers in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidDecimalPattern">
            <summary>
            Pattern for Valid Decimals in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidDoublePattern">
            <summary>
            Pattern for Valid Doubles in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.LongLiteralsPattern">
            <summary>
            Pattern for determining whether a given String should be serialized as a Long Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidPlainLiteral(System.String)">
            <summary>
            Determines whether a given String is a valid Plain Literal
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidInteger(System.String)">
            <summary>
            Determines whether a given String is a valid Integer
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidDecimal(System.String)">
            <summary>
            Determines whether a given String is a valid Decimal
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidDouble(System.String)">
            <summary>
            Determines whether a given String is a valid Double
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidQName(System.String)">
            <summary>
            Determines whether a given String is a valid QName
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsLongLiteral(System.String)">
            <summary>
            Determines whether a given String should be serialized as a Long Literal
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.InferPlainLiteralType(VDS.RDF.Parsing.Tokens.PlainLiteralToken)">
            <summary>
            Infers the Type of a Plain Literal
            </summary>
            <param name="p">Plain Literal to infer the Type of</param>
            <returns>A Uri  representing the XML Scheme Data Type for the Plain Literal</returns>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfSpecsHelper">
            <summary>
            Helper class with useful constants relating to the RDF Specification
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListFirst">
            <summary>
            URI for rdf:first
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListRest">
            <summary>
            URI for rdf:rest
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListNil">
            <summary>
            URI for rdf:nil
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfType">
            <summary>
            URI for rdf:type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfXmlLiteral">
            <summary>
            URI for rdf:XMLLiteral
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.ValidLangSpecifiersPattern">
            <summary>
            Pattern for Valid Language Specifiers
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper._validLangSpecifier">
            <summary>
            Regular Expression for Valid Language Specifiers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfSpecsHelper.IsValidLangSpecifier(System.String)">
            <summary>
            Determines whether a given String is a valid Language Specifier
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.TalisTripleStore">
            <summary>
            Class for representing a Talis Platform Store and executing queries against it
            </summary>
            <remarks>
            <para>
            No data is automatically loaded into this class when it is instantiated, it acts as a queryable view onto the remote Talis Store specified by the given <see cref="T:VDS.RDF.Storage.TalisPlatformConnector">TalisPlatformConnector</see>
            </para>
            <para>
            Currently Graphs added/removed from this Class do not affect the Talis Store unless they are <see cref="T:VDS.RDF.TalisGraph">TalisGraph</see> instances in which case changes to <strong>those Graphs only</strong> are persisted to the Talis Store.
            </para>
            <para>
            If you wish to alter the Store you must use either work exclusively with <see cref="T:VDS.RDF.TalisGraph">TalisGraph</see> instances or manipulate the Store directly using the <see cref="T:VDS.RDF.Storage.TalisPlatformConnector">TalisPlatformConnector</see>.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.BaseTripleStore">
            <summary>
            Abstract Base Class for a Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.ITripleStore">
            <summary>
            Interface for Triple Stores
            </summary>
            <remarks>A Triple Store may be a representation of some storage backed actual store or just a temporary collection of Graphs created for working with.  Note that an implementation is not required to provide a definitive view of a Triple Store and may only provide a limited/partial snapshot of the underlying store.  Check the documentation for the various implementations to see what type of view of a Triple Store they actually provide.</remarks>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Controls whether the Graph should be merged with an existing Graph of the same Uri if it already exists in the Triple Store</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph into the Triple Store by dereferencing the Graph Uri to get the RDF and then load the resulting Graph into the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to be added</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store by dereferencing the Graph Uri to get the RDF and then load the resulting Graph into the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to be added</param>
            <param name="mergeIfExists">Controls whether the Graph should be merged with an existing Graph of the same Uri if it already exists in the Triple Store</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Triple Store
            </summary>
            <param name="graphUri">Graph Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.HasGraph(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri is in this Triple Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Graph(System.Uri)">
            <summary>
            Gets a Graph from the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to retrieve</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.ITripleStore.IsEmpty">
            <summary>
            Gets whether a TripleStore is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleStore.Graphs">
            <summary>
            Gets the Graph Collection of Graphs in this Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleStore.Triples">
            <summary>
            Gets all the Triples in the Triple Store which are currently loaded in memory (see remarks)
            </summary>
            <remarks>Since a Triple Store object may represent only a snapshot of the underlying Store evaluating this enumerator may only return some of the Triples in the Store and may depending on specific Triple Store return nothing.</remarks>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore._graphs">
            <summary>
            Collection of Graphs that comprise the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store using the chosen Merging Behaviour
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph into the Triple Store which is retrieved from the given Uri
            </summary>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store which is retrieved from the given Uri using the chosen Merging Behaviour
            </summary>
            <param name="graphUri">Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to Remove</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.HasGraph(System.Uri)">
            <summary>
            Checks whether a Graph with the given Base Uri exists in the Triple Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns>True if the Graph exists in the Triple Store</returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Graph(System.Uri)">
            <summary>
            Gets the Graph with the given Uri
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Dispose">
            <summary>
            Disposes of the Triple Store
            </summary>
            <remarks>Derived classes must override this to implement required disposal actions</remarks>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.IsEmpty">
            <summary>
            Gets whether the Triple Store is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.Graphs">
            <summary>
            Gets the Collection of Graphs that comprise this Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.Triples">
            <summary>
            Gets all the Triples in the Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.INativelyQueryableStore">
            <summary>
            Interface for Triple Stores which can be queried natively i.e. the Stores provide their own Sparql implementations
            </summary>
            <remarks>
            A Natively Queryable store will typically not load its Graphs and Triples into memory as this is generally unecessary.
            </remarks>
        </member>
        <member name="M:VDS.RDF.INativelyQueryableStore.ExecuteQuery(System.String)">
            <summary>
            Executes a Sparql Query on the Triple Store
            </summary>
            <param name="query">Sparql Query as unparsed String</param>
            <returns></returns>
            <remarks>
            This assumes that the Store has access to some native Sparql query processor on/at the Store which will be used to return the results.  Implementations should parse the returned result into a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or <see cref="T:VDS.RDF.Graph">Graph</see>.
            </remarks>
        </member>
        <member name="M:VDS.RDF.TalisTripleStore.#ctor(VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new Talis Triple Store
            </summary>
            <param name="connector">Connection to a Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisTripleStore.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Talis Triple Store
            </summary>
            <param name="storeName">Name of the Talis Store</param>
            <param name="username">Username for the Talis Store</param>
            <param name="password">Password for the Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisTripleStore.#ctor(System.String)">
            <summary>
            Creates a new Talis Triple Store
            </summary>
            <param name="storeName">Name of the Talis Store</param>
            <remarks>This constructor creates a connection to the Talis platform which does not use authentication, this means that the Store must be world readable in order for queries to be executed.</remarks>
        </member>
        <member name="M:VDS.RDF.TalisTripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a Sparql Query on the Triple Store
            </summary>
            <param name="query">Sparql Query as unparsed String</param>
            <returns></returns>
            <remarks>
            This method invokes the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Query(System.String)">Query</see> method of the <see cref="T:VDS.RDF.Storage.TalisPlatformConnector">TalisPlatformConnector</see> which invokes the Sparql service of the Talis Store specified by the connector.  This means that only the Metabox of the Talis Store is queried and therefore any queries containing FROM and FROM NAMED clauses may fail since the Talis API states that these clauses are not supported.
            </remarks>
        </member>
        <member name="M:VDS.RDF.TalisTripleStore.Dispose">
            <summary>
            Disposes of a Talis Store
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlXsltWriter">
            <summary>
            Class for generating arbitrary XML Output from SPARQL Result Sets by transforming the XML Results Format via an XSLT stylesheet
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlXmlWriter">
            <summary>
            Class for saving Sparql Result Sets to the Sparql Results XML Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves the Result Set to the given File in the Sparql Results XML Format
            </summary>
            <param name="results">Result Set to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream in the Sparql Results XML Format
            </summary>
            <param name="results"></param>
            <param name="output"></param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Method which generates the Sparql Query Results XML Format serialization of the Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXsltWriter.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL XSLT Writer
            </summary>
            <param name="stylesheetUri">Stylesheet URI</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXsltWriter.#ctor(System.String)">
            <summary>
            Creates a new SPARQL XSLT Writer
            </summary>
            <param name="stylesheetUri">Stylesheet URI</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXsltWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves a SPARQL Result Set to the given File
            </summary>
            <param name="results">Result Set</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXsltWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves a SPARQL Result Set to the given Text Writer
            </summary>
            <param name="results">Result Set</param>
            <param name="output">Text Writer to write to</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfJsonWriter">
            <summary>
            Class for generating RDF/Json Concrete Syntax
            </summary>
            <remarks>
            <p>
            Uses the Json.Net library by <a href="http://james.newtonking.com">James Newton-King</a> to output RDF/Json according to the specification located on the <a href="http://n2.talis.com/wiki/RDF_JSON_Specification">Talis n2 Wiki</a>
            </p>
            <p>
            Since RDF/Json doesn't contain any Namespace information a Graph serialized to RDF/Json and then re-parsed generally cannot be output to a format that requires Namespacing (eg. RDF/XML)
            </p>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph in RDF/Json syntax to the given File
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">Filename to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to an arbitrary output stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.GenerateOutput(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Internal method which generates the RDF/Json Output for a Graph
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method for raising the Warning event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfJsonWriter.PrettyPrintMode">
            <summary>
            Gets/Sets Pretty Print Mode for the Writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.RdfJsonWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvWriter">
            <summary>
            Class for generating CSV output from RDF Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to CSV format
            </summary>
            <param name="g">Graph</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to CSV format
            </summary>
            <param name="g">Graph</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.GenerateNodeOutput(System.IO.TextWriter,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Node Output for the given Node
            </summary>
            <param name="output">Text Writer</param>
            <param name="n">Node</param>
            <param name="segment">Triple Segment</param>
        </member>
        <member name="E:VDS.RDF.Writing.CsvWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error while outputting CSV
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvStoreWriter">
            <summary>
            Class for generating CSV output from RDF Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves a Triple Store to CSV Format
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="parameters">A set of <see cref="T:VDS.RDF.Storage.Params.StreamParams">StreamParams</see></param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in CSV syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.BaseWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for the given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="segment">Triple Segment</param>
        </member>
        <member name="E:VDS.RDF.Writing.CsvStoreWriter.Warning">
            <summary>
            Event which is raised when a non-fatal error occurs while outputting CSV
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvStoreWriter.SaveGraphsDeletegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext">
            <summary>
            Writer Context for Threaded SQL Store Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.ThreadedSqlIOParams)">
            <summary>
            Creates a new Threaded SQL Store Writer Context
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="params">Threaded SQL IO Parameters</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.IThreadedSqlIOManager,System.Int32,System.Boolean)">
            <summary>
            Creates a new Threaded SQL Store Writer Context
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="manager">SQL IO Manager</param>
            <param name="threads">Number of threads to use</param>
            <param name="clearIfExists">Whether to clear graphs if they already exist</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.IThreadedSqlIOManager)">
            <summary>
            Creates a new Threaded SQL Store Writer Context
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="manager">SQL IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the queue of Graphs to be written
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.GetNextGraph">
            <summary>
            Gets the Next Graph to be written
            </summary>
            <returns>Next Graph to write or null if all Graphs have been written</returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.Store">
            <summary>
            Gets the Triple Store that is being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.Threads">
            <summary>
            Gets the number of threads to use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.Manager">
            <summary>
            Gets the SQL IO Manager in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext.ClearIfExists">
            <summary>
            Gets whether to clear graphs if they exist
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.AverageAggregate">
            <summary>
            Class representing AVG Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Average Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AverageAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.CountAggregate">
            <summary>
            Class representing COUNT Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new COUNT Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Count Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.CountDistinctAggregate">
            <summary>
            Class representing COUNT(DISTINCT ?x) Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountDistinctAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new COUNT(DISTINCT ?x) Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountDistinctAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new COUNT DISTINCT Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountDistinctAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountDistinctAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.CountAllAggregate">
            <summary>
            Class representing COUNT(*) Aggregate Function
            </summary>
            <remarks>
            Differs from a COUNT in that it justs counts rows in the results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllAggregate.#ctor">
            <summary>
            Creates a new COUNT(*) Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.CountAllDistinctAggregate">
            <summary>
            Class representing COUNT(DISTINCT *) Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllDistinctAggregate.#ctor">
            <summary>
            Creates a new COUNT(DISTINCT*) Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllDistinctAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.CountAllDistinctAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.GroupConcatAggregate">
            <summary>
            Class representing GROUP_CONCAT Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Should a distinct modifer be applied</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.GroupConcatAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.MaxAggregate">
            <summary>
            Class representing MAX Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="distinct">Distinct Modifier</param>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Max Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MaxAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.MinAggregate">
            <summary>
            Class representing MIN Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Min Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.MinAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.SampleAggregate">
            <summary>
            Class representing the SAMPLE aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SampleAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SAMPLE Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SampleAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the SAMPLE Aggregate
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SampleAggregate.ToString">
            <summary>
            Gets the String representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.SumAggregate">
            <summary>
            Class representing SUM Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Boolean)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Sum Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.SumAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Web.SchemaHandler">
            <summary>
            Handler for serving Schemas mapped to different URIs within your web application
            </summary>
            <remarks>
            <para>
            A single instance of the SchemaHandler can be registered per application.  It's configuration specifies a number of RDF files which contain Schemas.  When a request comes in on a Uri which is mapped to the Handler the Handler will look for that Uri defined as having <em>rdf:type</em> of <em>rdfs:Class</em> or <em>rdf:Property</em> in any of the schemas.  If it finds the Uri in one of the schemas it serves that Graph in a format supported by the requesting client.
            </para>
            <para>
            You register one/more Schemas to the Handler using the following configuration variable.  The <strong>X</strong> in these examples indicate a 1 based index:
            <ul>
                <li><strong>SchemaX</strong> - Registers the Schema contained in the file with the Handler</li>
            </ul>
            For example:
            <code>
            &lt;add key="Schema1" value="MySchema.rdf" /&gt;
            &lt;add key="Schema2" value="MyOtherSchema.ttl" /&gt;
            </code>
            Format of the RDF in each file is determined based upon the file extension.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.SchemaHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes requests by looking for Schemas that either have the requested Uri as their Base Uri or that have a Class/Property defined in them with that Uri
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="M:VDS.RDF.Web.SchemaHandler.LoadInternal(System.Web.HttpContext)">
            <summary>
            Loads the Schema files specified in the Configuration
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="P:VDS.RDF.Web.SchemaHandler.IsReusable">
            <summary>
            Returns that this Handler is reusable
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.BaseGraphHandlerConfiguration">
            <summary>
            Abstract Base class for Graph Handler configurations
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Resource.BaseGraphHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Graph Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Resource.BaseGraphHandlerConfiguration.Graph">
            <summary>
            Gets the Graph being served
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.GraphHandlerConfiguration">
            <summary>
            Basic implementation of a Graph Handler configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Resource.GraphHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Graph Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="T:VDS.RDF.Web.BaseSparqlUpdateHandler">
            <summary>
            Abstract Base Class for creating SPARQL Update Handler implementations
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.BaseSparqlUpdateHandler._config">
            <summary>
            Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes SPARQL Update requests
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.ProcessUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes SPARQL Updates
            </summary>
            <param name="cmd">Update Command</param>
            <remarks>
            <para>
            Implementations should override this method if their behaviour requires more than just invoking the configured Update processor
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.ShowUpdateForm(System.Web.HttpContext)">
            <summary>
            Generates a SPARQL Update Form
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.HandleErrors(System.Web.HttpContext,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Update Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="update">SPARQL Update</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlUpdateHandler.GetPermissionAction(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Gets the Permission action for the SPARQL Update Command
            </summary>
            <param name="cmd">Update Command</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Web.BaseSparqlUpdateHandler.IsReusable">
            <summary>
            Gets that the Handler is reusable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction">
            <summary>
            Represents the ARQ afn:substring() function which is a sub-string with Java semantics
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
            <param name="endExpr">Expression giving an index at which to end the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.ArqSubstringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction">
            <summary>
            Represents the ARQ afn:strjoin() function which is a string concatenation function with a separator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new ARQ String Join function
            </summary>
            <param name="sepExpr">Separator Expression</param>
            <param name="expressions">Expressions to concatentate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.ArqStringJoinFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqNowFunction">
            <summary>
            Represents the ARQ afn:now() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NodeExpressionTerm">
            <summary>
            Class for representing Node Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.NodeExpressionTerm._node">
            <summary>
            Node this Term represents
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.NodeExpressionTerm._ebv">
            <summary>
            Effective Boolean Value of this Term
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NodeExpressionTerm.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Node Expression
            </summary>
            <param name="n">Node</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NodeExpressionTerm.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Node that this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NodeExpressionTerm.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NodeExpressionTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.NodeExpressionTerm.Variables">
            <summary>
            Gets an Empty Enumerable since a Node Term does not use variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNowFunction.#ctor">
            <summary>
            Creates a new ARQ Now function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNowFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns>
            Returns a constant Literal Node which is a Date Time typed Literal
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNowFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNowFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqSha1SumFunction">
            <summary>
            Represents the ARQ afn:sha1sum() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSha1SumFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ SHA1 Sum function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqSha1SumFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.LeviathanFunctionFactory">
            <summary>
            Expression Factory which generates Leviathan Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.LeviathanFunctionsNamespace">
            <summary>
            Leviathan Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.MD5Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Sha256Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Random">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSin">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSinInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCos">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigTan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigTanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCotan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCotanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.DegreesToRadians">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.RadiansToDegrees">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Log">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Ln">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.E">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Ten">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Power">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Square">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Cube">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.SquareRoot">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Root">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Pythagoras">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Cartesian">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Factorial">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Reciprocal">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.All">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Any">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.None">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.NumericMin">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.NumericMax">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Mode">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Median">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an Leviathan Function expression if the function Uri correseponds to a supported Leviathan Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction">
            <summary>
            Abstract base class for SPARQL Functions which operate on Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction._varTerm">
            <summary>
            Variable Expression Term that the Set function applies to
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction._set">
            <summary>
            Set that is used in the function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Creates a new SPARQL Set function
            </summary>
            <param name="varTerm">Variable Expression Term</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.SparqlSetFunction.Variables">
            <summary>
            Gets the Variable the function applies to
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.SparqlInFunction">
            <summary>
            Class representing the SPARQL IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlInFunction.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Creates a new SPARQL IN function
            </summary>
            <param name="varTerm">Variable Expression Term</param>
            <param name="set">Set</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.SparqlNotInFunction">
            <summary>
            Class representing the SPARQL NOT IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlNotInFunction.#ctor(VDS.RDF.Query.Expressions.VariableExpressionTerm,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Creates a new SPARQL NOT IN function
            </summary>
            <param name="varTerm">Variable Expression Term</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.SparqlNotInFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Set">
            <summary>
            Represents one possible set of values which is a solution to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor">
            <summary>
            Creates a new Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.Algebra.Set,VDS.RDF.Query.Algebra.Set)">
            <summary>
            Creates a new Set which is the Join of the two Sets
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.SparqlResult)">
            <summary>
            Creates a new Set from a SPARQL Result
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.Patterns.BindingTuple)">
            <summary>
            Creates a new Set from a Binding Tuple
            </summary>
            <param name="tuple">Tuple</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Add(System.String,VDS.RDF.INode)">
            <summary>
            Adds a Value for a Variable to the Set
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the Set
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.ContainsVariable(System.String)">
            <summary>
            Checks whether the Set contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.ToString">
            <summary>
            Gets the String representation of the Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Equals(System.Object)">
            <summary>
            Gets whether a Set is equal to another Set
            </summary>
            <param name="obj">Object to compare against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Equals(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Gets whether the Set is equal to another set
            </summary>
            <param name="other">Set to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.GetHashCode">
            <summary>
            Gets the Hash Code of the Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Item(System.String)">
            <summary>
            Retrieves the Value in this set for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Variables">
            <summary>
            Gets the Variables in the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Values">
            <summary>
            Gets the Values in the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.ID">
            <summary>
            Gets/Sets the ID of the Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.UriLoaderCache">
            <summary>
            Provides caching services to the <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> class
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.#ctor">
            <summary>
            Creates a new Cache which uses the system temporary directory as the cache location
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.#ctor(System.String)">
            <summary>
            Creates a new Cache which uses the given directory as the cache location
            </summary>
            <param name="dir">Directory</param>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.Initialise">
            <summary>
            Initialises the Cache as required
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.Clear">
            <summary>
            Clears the Cache
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.HasETag(System.Uri)">
            <summary>
            Is there an ETag for the given URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.GetETag(System.Uri)">
            <summary>
            Gets the ETag for the given URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no ETag for the given URI</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.RemoveETag(System.Uri)">
            <summary>
            Remove the ETag record for the given URI
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.HasLocalCopy(System.Uri,System.Boolean)">
            <summary>
            Is there a locally cached copy of the Graph from the given URI which is not expired
            </summary>
            <param name="u">URI</param>
            <param name="requireFreshness">Whether the local copy is required to meet the Cache Freshness (set by the Cache Duration)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.GetLocalCopy(System.Uri)">
            <summary>
            Gets the path to the locally cached copy of the Graph from the given URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
            <remarks>
            This method does not do any cache expiry calculations on the file.  This is due to the fact that we'll store local copies of Graphs for which we have ETags and when using ETags we rely on the servers knowledge of whether the resource described by the URI has changed rather than some arbitrary caching duration that we/the user has set to use.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoaderCache.ToCache(System.Uri,VDS.RDF.IGraph,System.String)">
            <summary>
            Caches a Graph in the Cache
            </summary>
            <param name="retrieved">URI from which the Graph was retrieved</param>
            <param name="g">Graph</param>
            <param name="etag">ETag</param>
        </member>
        <member name="P:VDS.RDF.Parsing.UriLoaderCache.CacheDuration">
            <summary>
            Gets/Sets how long results should be cached
            </summary>
            <remarks>
            This only applies to downloaded URIs where an ETag is not available, where ETags are available proper ETag based caching is used
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.UriLoaderCache.CacheDirectory">
            <summary>
            Gets/Sets the Cache Directory that is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.IRdfAVocabulary">
            <summary>
            Interface for RDFa Vocabularies
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.HasTerm(System.String)">
            <summary>
            Gets whether a Vocabulary contains a Term
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.ResolveTerm(System.String)">
            <summary>
            Resolves a Term in the Vocabulary
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.AddTerm(System.String,System.String)">
            <summary>
            Adds a Term to the Vocabulary
            </summary>
            <param name="term">Term</param>
            <param name="uri">URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.AddNamespace(System.String,System.String)">
            <summary>
            Adds a Namespace to the Vocabulary
            </summary>
            <param name="prefix">Prefix</param>
            <param name="nsUri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.Merge(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Merges another Vocabulary into this one
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.VocabularyUri">
            <summary>
            Gets/Sets the Vocabulary URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.Mappings">
            <summary>
            Gets the Term Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.Namespaces">
            <summary>
            Gets the Namespace Mappings
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.XHtmlRdfAVocabulary">
            <summary>
            Vocabulary for XHTML+RDFa (and HTML+RDFa)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.XHtmlRdfAVocabulary.HasTerm(System.String)">
            <summary>
            Gets whether the Vocabulary contains a Term
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XHtmlRdfAVocabulary.ResolveTerm(System.String)">
            <summary>
            Resolves a Term in the Vocabulary
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XHtmlRdfAVocabulary.AddTerm(System.String,System.String)">
            <summary>
            Adds a Term to the Vocabulary
            </summary>
            <param name="term">Term</param>
            <param name="uri">URI</param>
            <exception cref="T:System.NotSupportedException">Thrown since this vocabulary is fixed and cannot be changed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.XHtmlRdfAVocabulary.AddNamespace(System.String,System.String)">
            <summary>
            Adds a Namespace to the Vocabulary
            </summary>
            <param name="prefix">Prefix</param>
            <param name="nsUri">Namespace URI</param>
            <exception cref="T:System.NotSupportedException">Thrown since this vocabulary is fixed and cannot be changed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.XHtmlRdfAVocabulary.Merge(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Merges another Vocabulary into this one
            </summary>
            <param name="vocab">Vocabulary</param>
            <exception cref="T:System.NotSupportedException">Thrown since this vocabulary is fixed and cannot be changed</exception>
        </member>
        <member name="P:VDS.RDF.Parsing.XHtmlRdfAVocabulary.Mappings">
            <summary>
            Gets the Term Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.XHtmlRdfAVocabulary.Namespaces">
            <summary>
            Gets the Namespace Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.XHtmlRdfAVocabulary.VocabularyUri">
            <summary>
            Gets/Sets the Vocabulary URI
            </summary>
            <exception cref="T:System.NotSupportedException">Set throws this since this vocabulary is fixed and cannot be changed</exception>
        </member>
        <member name="T:VDS.RDF.Parsing.TermMappings">
            <summary>
            Represents a dynamic vocabulary for RDFa
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor">
            <summary>
            Creates a new set of Term Mappings
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor(System.String)">
            <summary>
            Creates a new set of Term Mappings with the given Vocabulary URI
            </summary>
            <param name="vocabUri">Vocabulary URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Creates a new set of Term Mappings from the given Vocabulary
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.Merge(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Merges another Vocabulary into this one
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.HasTerm(System.String)">
            <summary>
            Gets whether the Vocabulary contains a Term
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.ResolveTerm(System.String)">
            <summary>
            Resolves a Term in the Vocabulary
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.AddNamespace(System.String,System.String)">
            <summary>
            Adds a Namespace to the Vocabulary
            </summary>
            <param name="prefix">Prefix</param>
            <param name="nsUri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.AddTerm(System.String,System.String)">
            <summary>
            Adds a Term to the Vocabulary
            </summary>
            <param name="term">Term</param>
            <param name="uri">URI</param>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.Mappings">
            <summary>
            Gets the Term Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.Namespaces">
            <summary>
            Gets the Namespace Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.VocabularyUri">
            <summary>
            Gets/Sets the Vocabulary URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyClass">
            <summary>
            Class for representing a class in an Ontology
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new representation of a Class in the given Ontology Mode
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.INode)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(System.Uri)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a super-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearSubClasses">
            <summary>
            Removes all sub-classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.INode)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(System.Uri)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class from being a super-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.INode)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(System.Uri)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a sub-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearSuperClasses">
            <summary>
            Removes all super-classes
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.INode)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(System.Uri)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class as a sub-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.INode)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(System.Uri)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as an equivalent class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearEquivalentClasses">
            <summary>
            Removes all equivalent classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.INode)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(System.Uri)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.INode)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(System.Uri)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a disjoint class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearDisjointClasses">
            <summary>
            Removes all disjoint classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.INode)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(System.Uri)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class as a disjoint class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.CreateIndividual(System.Uri)">
            <summary>
            Gets/Creates an Individual of this class
            </summary>
            <param name="resource">Resource identifying the individual</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.Equals(System.Object)">
            <summary>
            Gets whether this Class is equal to another Class
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.SubClasses">
            <summary>
            Gets the sub-classes of this class (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.SuperClasses">
            <summary>
            Gets the super-classes of this class (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.EquivalentClasses">
            <summary>
            Gets the equivalent classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.DisjointClasses">
            <summary>
            Gets the disjoint classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.Instances">
            <summary>
            Gets the instances (individuals) of this class
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.PermissionModel">
            <summary>
            Possible permission models
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.DenyAllow">
            <summary>
            If the action appears in the deny list it is denied unless it is in the allow list, otherwise it is allowed
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.AllowDeny">
            <summary>
            If the action appears in the allow list it is allowed unless it is in the deny list, otherwise it is denied
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.AllowAny">
            <summary>
            All actions are allowed
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.DenyAny">
            <summary>
            All actions are denied
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.IPermission">
            <summary>
            Interface for Permission
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.IPermission.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for a specific action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.Permission">
            <summary>
            Represents a action that can be allowed/denied
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.Permission.#ctor(System.String)">
            <summary>
            Creates a new Permission for the given Action
            </summary>
            <param name="action">Action</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.Permission.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for the given action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.PermissionSet">
            <summary>
            Represents a set of Permissions that can be allowed/denied
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.#ctor(System.String)">
            <summary>
            Creates a new Permissions Set
            </summary>
            <param name="action">Action</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Permissions Set
            </summary>
            <param name="actions">Actions</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for the given action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.XmlSpecsHelper">
            <summary>
            Static Helper Class which contains a set of Functions which model Name and Character validations as laid
            out in the W3C XML and XML Namespaces specification
            </summary>
            <remarks>
            These are needed in the XML/RDF Parser
            
            Also contains the Date Time format string used to format .Net's DateTime type into a String whose format conforms to the XML Schema Datatypes specification
            
            
            </remarks>
            <seealso>http://www.w3.org/TR/REC-xml/</seealso>
            <seealso>http://www.w3.org/TR/REC-xml-names/</seealso>
            <seealso>http://www.w3.org/TR/xmlschema-2/</seealso>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.NamespaceXml">
            <summary>
            Namespace for XML
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.NamespaceXmlNamespaces">
            <summary>
            Namespace for XML Namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDateTimeFormat">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:dateTime
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeAnyUri">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeBase64Binary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeBoolean">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDate">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDateTime">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDecimal">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDouble">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeFloat">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeHexBinary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNonNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNonPositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypePositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeString">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.SupportedTypes">
            <summary>
            Array of Constants for Data Types that are supported by the Literal Node CompareTo method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsName(System.String)">
            <summary>
            Returns whether a String is a Name as defined by the W3C XML Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNCName(System.String)">
            <summary>
            Returns whether a String is a NCName as defined by the W3C XML Namespaces Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml-names/#NT-NCName</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNCNameStartChar(System.Char)">
            <summary>
            Returns whether a Character is a NCNameStartChar as defined by the W3C XML Namespaces Specification
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml-names/#NT-NCNameStartChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNCNameChar(System.Char)">
            <summary>
            Returns whether a Character is a NCNameChar as defined by the W3C XML Namespaces Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml-names/#NT-NCNameChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNameChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNameStartChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsLetter(System.Char)">
            <summary>
            Returns whether a Character is a Letter as defined by the W3C XMLSpecification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-Letter</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsBaseChar(System.Char)">
            <summary>
            Returns whether a Character is a BaseChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-BaseChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsIdeographic(System.Char)">
            <summary>
            Returns whether a Character is an Ideographic as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-Ideographic</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsSupportedType(System.String)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsSupportedType(System.Uri)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetSupportedDataType(VDS.RDF.INode)">
            <summary>
            Gets the Data Type Uri of the given Node if it has a supported type
            </summary>
            <param name="n">Node</param>
            <returns></returns>
            <remarks>
            <para>
            Only <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see>'s can have a Data Type
            </para>
            <para>
            The function only returns the Data Type Uri (as a String) if the Data Type of the Literal is one of the supported Data Types
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.IInMemoryQueryableStore">
            <summary>
            Interface for Triple Stores which can be queried in memory using either <see cref="T:VDS.RDF.ISelector`1">ISelector&lt;T&gt;"</see> or the SPARQL implementation contained in this library
            </summary>
            <remarks>
            <para>
            An in memory Triple Store will typically load most of the Graphs and consequently Triples contained within it into Memory as the in memory SPARQL implementation only operates over the part of the Triple Store loaded in memory.  This being said there is no reason why an in memory store can't provide a Snapshot view of an underlying store to allow only the relevant parts of Store to be loaded and queried (the <see cref="T:VDS.RDF.OnDemandTripleStore">OnDemandTripleStore</see> does just this)
            </para>
            <para>
            All the Selection Methods which do not specify a subset of Graphs on such a Triple Store <strong>should</strong> operate over the <see cref="P:VDS.RDF.IInMemoryQueryableStore.QueryTriples">QueryTriples</see> enumerable
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.Contains(VDS.RDF.Triple)">
            <summary>
            Returns whether a given Triple is contained anywhere in the Query Triples
            </summary>
            <param name="t">Triple to check for existence of</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Nodes that meet the criteria of a given ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from all the Query Triples
            </summary>
            <param name="firstSelector">First Selector in the Chain</param>
            <param name="selectorChain">Dependent Selectors which form the rest of the Chain</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from all the Query Triples
            </summary>
            <param name="selectorChain">Chain of Independent Selectors</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Selects all Triples which meet the criteria of an ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Object Node meets the criteria of an ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Predicate meets the criteria of an ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Subject meets the criteria of an ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples meeting the criteria of an ISelector can be found from all the Query Triples
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Predicate pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Predicate-Object pair from all the Query Triples
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Object pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetNodes(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Nodes that meet the criteria of a given ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from a Subset of Graphs in the Triple Store where the results of each Selector influence the next selector and selection at each stage is over the selected subset of Graphs
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="firstSelector">First Selector in the Chain</param>
            <param name="selectorChain">Dependent Selectors which form the rest of the Chain</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from a Subset of Graphs in the Triple Store where each Selector is independent and selection at each stage is over the results of the previous selection stages
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selectorChain">Chain of Independent Selectors</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Selects all Triples which meet the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Object Node meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Predicate meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Subject meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.TriplesExist(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples meeting the criteria of an ISelector can be found from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as an unparsed string</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>API Change: </strong> In previous versions of this library implementations were responsible for configuring the default and active graphs themselves.  From 0.3.0 onwards this requirement has been removed and this is now handled directly by the Query itself by invoking the <see cref="M:VDS.RDF.IInMemoryQueryableStore.SetActiveGraph(VDS.RDF.IGraph)">SetActiveGraph()</see> and <see cref="M:VDS.RDF.IInMemoryQueryableStore.SetDefaultGraph(VDS.RDF.IGraph)">SetDefaultGraph()</see> methods as appropriate.
            </para>
            <para>
            <s>Implementations of this should configure the Default and Active Graphs of the Triple Store as required by the Query before invoking the Query's <see cref="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IInMemoryQueryableStore)">Evaluate</see> method to run the actual Query</s>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as a <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> instance</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>API Change: </strong> In previous versions of this library implementations were responsible for configuring the default and active graphs themselves.  From 0.3.0 onwards this requirement has been removed and this is now handled directly by the Query itself by invoking the <see cref="M:VDS.RDF.IInMemoryQueryableStore.SetActiveGraph(VDS.RDF.IGraph)">SetActiveGraph()</see> and <see cref="M:VDS.RDF.IInMemoryQueryableStore.SetDefaultGraph(VDS.RDF.IGraph)">SetDefaultGraph()</see> methods as appropriate.
            </para>
            <para>
            <s>Implementations of this should configure the Default and Active Graphs of the Triple Store as required by the Query before invoking the Query's <see cref="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IInMemoryQueryableStore)">Evaluate</see> method to run the actual Query</s>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.SetDefaultGraph(VDS.RDF.IGraph)">
            <summary>
            Sets the Default Graph for the SPARQL Query
            </summary>
            <param name="g">Default Graph</param>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.SetActiveGraph(VDS.RDF.IGraph)">
            <summary>
            Sets the Active Graph for the SPARQL Query
            </summary>
            <param name="g">Active Graph</param>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph for the SPARQL query
            </summary>
            <param name="graphUri">Uri of the Active Graph</param>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.SetActiveGraph(System.Collections.Generic.List{System.Uri})">
            <summary>
            Sets the Active Graph for the SPARQL query
            </summary>
            <param name="graphUris">URIs of the Graphs which form the Active Graph</param>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ResetActiveGraph">
            <summary>
            Sets the Active Graph for the SPARQL query to be the previous Active Graph
            </summary>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="P:VDS.RDF.IInMemoryQueryableStore.QueryTriples">
            <summary>
            Gets the Set of Triples that are queries over by a Sparql Query
            </summary>
            <remarks>This set may be altered during the course of query execution by the query</remarks>
        </member>
        <member name="T:VDS.RDF.IUpdateableTripleStore">
            <summary>
            Interface for Triple Stores which support SPARQL Update as per the SPARQL 1.1 specifications
            </summary>
            <remarks>
            <para>
            A Store which supports this may implement various access control mechanisms which limit what operations are actually permitted
            </para>
            <para>
            It is the responsibility of the Store class to ensure that commands are permissible before invoking them
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes an Update against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command(s)</param>
            <remarks>
            As per the SPARQL 1.1 Update specification the command string may be a sequence of commands
            </remarks>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a single Update Command against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command</param>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of Update Commands against the Triple Store
            </summary>
            <param name="updates">SPARQL Update Command Set</param>
        </member>
        <member name="T:VDS.RDF.IInferencingTripleStore">
            <summary>
            Interface for Triple Stores which can have a <see cref="!:InferenceEngine">InferenceEngine</see> attached to them
            </summary>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.AddInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Adds an Inference Engine to the Triple Store
            </summary>
            <param name="reasoner">Reasoner to add</param>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.RemoveInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Removes an Inference Engine from the Triple Store
            </summary>
            <param name="reasoner">Reasoner to remove</param>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.ClearInferenceEngines">
            <summary>
            Clears all Inference Engines from the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.ApplyInference(VDS.RDF.IGraph)">
            <summary>
            Applies Inference to the given Graph
            </summary>
            <param name="g">Graph to apply inference to</param>
            <remarks>
            Allows you to apply Inference to a Graph even if you're not putting that Graph into the Store
            </remarks>
        </member>
        <member name="T:VDS.RDF.Web.SqlResourceHandler">
            <summary>
            A SQL Resource Handler attempts to retrieve any Uri it is invoked at as a Graph from the underlying Store
            </summary>
            <remarks>
            <para>
            This Handler supports only one handler of this type being registered (multiple Handlers can be registered but their configuration will be shared if they get it from the same Web.config file)
            </para>
            <para>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the type of the handler like so:
            <code>&lt;add key="VDS.RDF.Web.SqlResourceHandler" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </para>
            <para>
            The Handler supports the same Database Configuration variables as the <see cref="T:VDS.RDF.Web.SparqlHandler">SparqlHandler</see> and supports the following Configuration variables for itself:
            </para>
            <ul>
            <li><strong>LookupMode</strong> (<em>Optional</em>) - Sets how the Handler looks up URIs it is invoked with.  This should be one of the values from the <see cref="T:VDS.RDF.Web.SQLResourceLookupMode">SQLResourceLookupMode</see> enumeration, see the enumeration documentation for how each mode behaves.  Default is <see cref="F:VDS.RDF.Web.SQLResourceLookupMode.Graph">Graph</see></li>
            </ul>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Web.BaseResourceHandler">
            <summary>
            A Base HTTP Handler for serving Resources at URIs on your server
            </summary>
            <remarks>
            Handlers derived from this currently support only 1 Handler per Web Application but that should hopefully change at some point in the 0.3.x releases
            </remarks>
        </member>
        <member name="F:VDS.RDF.Web.BaseResourceHandler._rewriteRules">
            <summary>
            List of Uri Rewriting Rules for Resource URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.BaseResourceHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Handles the Resource Request
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseResourceHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Determines the Cache Key and Config Prefix of the Handler and calls the <see cref="M:VDS.RDF.Web.BaseResourceHandler.LoadConfigInternal(System.Web.HttpContext,System.String,System.String)">LoadConfigInternal</see> method, also loads in the URL Rewriting Rules
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseResourceHandler.LoadConfigInternal(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Abstract Configuration Loading method which will be called by the <see cref="M:VDS.RDF.Web.BaseResourceHandler.LoadConfig(System.Web.HttpContext)">LoadConfig()</see> method and should be used to do derived class specific Configuration loading
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="cacheKey">Cache Key</param>
            <param name="prefix">Config Variable Prefix</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseResourceHandler.RewriteURI(System.String)">
            <summary>
            Applies the Uri Rewriting Rules to the given Uri
            </summary>
            <param name="uri">Uri to rewrite</param>
            <returns></returns>
            <remarks>May be overridden in derived classes to provide more powerful Uri rewriting</remarks>
        </member>
        <member name="P:VDS.RDF.Web.BaseResourceHandler.IsReusable">
            <summary>
            Indicates that the Handler is reusable
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.SqlResourceHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Handles a Request for a Resource by retrieving it from the underlying SQL Store
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="M:VDS.RDF.Web.SqlResourceHandler.LoadConfigInternal(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Loads the Handler specific Configuration for this Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="cacheKey">Cache Key</param>
            <param name="prefix">Config Variable Prefix</param>
        </member>
        <member name="T:VDS.RDF.Web.SparqlHandler">
            <summary>
            A HTTP Handler for Sparql Queries which uses the libraries in-memory Sparql implementation against a SQL backed Store
            </summary>
            <remarks>
            <p>
            <strong>Warning:</strong> This class is now considered obsolete since it is renamed to <see cref="!:SqlSparqlHandler">SqlSparqlHandler</see> from the 0.3.0 release onwards in order to more clearly indicate its function and differentiate it from the other SPARQL Handlers in the API.  Please switch your existing code to use <see cref="!:SqlSparqlHandler">SqlSparqlHandler</see>
            </p>
            <p>
            This Handler supports registering the Handler multiple times in one Web application with each able to use its own settings.
            </p>
            <p>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the virtual path of the handler like so:
            <code>&lt;add key="/virtualRoot/sparql/" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </p>
            <p>
            The following Configuration Variables are supported in addition to those supported by the <see cref="T:VDS.RDF.Web.BaseSparqlHandler">BaseSparqlHandler</see>:
            </p>
            <ul>
            <li><strong>DBType</strong> (<em>Required for non-Microsoft SQL Server Stores</em>) - Sets the Database Type to use, defaults to Microsoft SQL Server if not set</li>
            <li><strong>DBServer</strong> (<em>Required</em>) - Sets the Database Server for the underlying Store</li>
            <li><strong>DBName</strong> (<em>Required</em>) - Sets the Database Name for the underlying Store</li>
            <li><strong>DBUser</strong> (<em>Required</em>) - Sets the Database Username for the underlying Store</li>
            <li><strong>DBPassword</strong> (<em>Required</em>) - Sets the Database Password for the underlying Store</li>
            <li><strong>DBPort</strong> (<em>Optional for Non-Native Virtuoso Stores</em>) - Sets the Database Port for the underlying Store, defaults to the Virtuoso default port of 1111</li>
            <li><strong>LoadMode</strong> (<em>Optional</em>) - Controls how and when the Handler should load the store into memory.  The value of this should be one of the values from <see cref="T:VDS.RDF.Web.SparqlLoadMode">SparqlLoadMode</see>, see the API for the enumeration for information on how each mode behaves.  Defaults to <see cref="F:VDS.RDF.Web.SparqlLoadMode.OnDemand">OnDemand</see></li>
            <li>
                You can attach one/more Inference Engines to the Store using the following configuration variables.  The <strong>X</strong> in these examples indicate a 1 based index:
                <ul>
                    <li><strong>ReasonerX</strong> (<em>Optional</em>) - Adds an instance of the given <see cref="!:IInferenceEngine">IInferenceEngine</see> implementing class specified by a fully qualified type name as a Reasoner to the Store</li>
                    <li><strong>ReasonerAssemblyX</strong> (<em>Optional</em>) - Specifies the name of the assembly that the Reasoner type is located in, if this variable is not specified it is assumed that the Reasoner is a type from dotNetRDF</li>
                    <li><strong>ReasonerRulesGraphX</strong> (<em>Optional</em>) - Specifies the Uri of the Graph that is used to initialise the Reasoner</li>
                </ul>
                For example:
                <code>
                &lt;add key="Reasoner1" value="VDS.RDF.Query.Inference.StaticRdfsReasoner" /&gt;
                &lt;add key="ReasonerRulesGraph1" value="http://example.org/myClassSchema" /&gt;
                </code>
            </li>
            <li>
                You can also attach one/more Custom Expression Factories to the Store using the following configuration variables.  The <strong>X</strong> in these examples indicate a 1 based index:
                <ul>
                    <li><strong>ExpressionFactoryX</strong> (<em>Optional</em>) - Adds an instance of the given <see cref="T:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory">ISparqlCustomExpressionFactory</see> implementing class specified by a fully qualified type name as a Custom Expression Factory to the SPARQL Parser</li>
                    <li><strong>ExpressionFactoryAssemblyX</strong> (<em>Optional</em>) - Specifies the name of the assembly that the Custom Expression Factory type is located in, if this variable is not specified it is assumed that the Factory is a type from dotNetRDF</li>
                </ul>
                For example:
                <code>
                &lt;add key="ExpressionFactory1" value="VDS.RDF.Query.Expressions.ArqFunctionFactory" /&gt;
                </code>
                A Custom Expression Factory allows you to create a means to define your own custom extension functions and have them executed as part of queries made using this Handler.  For details on how to do this take a look at the <a href="http://www.dotnetrdf.org/content.asp?pageID=SPARQL%20Extension%20Functions">online documentation</a>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Web.BaseSparqlHandler">
            <summary>
            Abstract Base class for creating SPARQL Query Handler implementations
            </summary>
            <remarks>
            <p>
            This Handler supports registering the Handler multiple times in one Web application with each able to use its own settings.
            </p>
            <p>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the virtual path of the handler like so:
            <code>&lt;add key="/virtualRoot/sparql/" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </p>
            <p>
            The following Configuration Variables are supported on all Sparql Handlers:
            </p>
            <ul>
            <li><strong>DefaultGraph</strong> (<em>Optional</em>) - Sets the Default Graph Uri for queries which don't specify a Default Graph, defaults to the empty string which indicates no default graph is used for the query unless explicitly set with a FROM clause</li>
            <li><strong>DefaultTimeout</strong> (<em>Optional</em>) - Sets the Default Query Execution Timeout in milliseconds, queries which take longer than this time to execute will be aborted.  Defaults to 30000 (30s)</li>
            <li><strong>DefaultPartialResults</strong> (<em>Optional</em>) - Sets the Default Partial Results on Timeout behaviour for the endpoint, queries which take longer than the timeout can return partial results.  Defaults to false (Disabled)</li>
            <li><strong>DefaultQueryFile</strong> (<em>Optional</em>) - Sets a relative path to a File containing the Default Query that should be displayed in the Query Form which is generated if a user accesses the endpoint Uri without making a Query.  By default no default query is loaded and nothing will be displayed in the Query box of the Query Form.</li>
            <li><strong>ShowQueryForm</strong> (<em>Optional</em>) - Controls whether users accessing the Endpoint without making a Query are presented with a Query Form.  By default it is enabled, when disabled users are redirected to the Default.aspx page of the Web Application.</li>
            <li><strong>ShowErrors</strong> (<em>Optional</em>) - Controls whether error messages are shown to users or not.  If enabled users will see error messages when their queries fail detailing why they failed, if disabled users recieve a HTTP 500 Internal Server Error response.  Defaults to true (Enabled).  <strong>Note:</strong> Stack Traces from errors are only displayed if using a Debug build of dotNetRDF.</li>
            <li><strong>Stylesheet</strong> (<em>Optional</em>) - Sets a Stylesheet used for the Query Form and for HTML formatted output.  By default no Stylesheet is used</li>
            <li><strong>CacheDuration</strong> (<em>Optional</em>) - Sets the Cache Duration in minutes used for Caching Configuration and Stores, this duration is used for the Sliding Expiration of cached information.  Defaults to 15, only values between 15 and 120 are permitted.</li>
            <li><strong>IntroFile</strong> (<em>Optional</em>) - Sets a relative path to a File containing some Introduction text to be added to your Query Form.  By default no Introduction text is used</li>
            <li><strong>FullIndexing</strong> (<em>Optional</em>) - Sets whether Full Triple Indexing should be used for Handlers which use the libraries in-memory Sparql implementation - this improves query performance by 2-3 times at the cost of increased memory requirements.  Defaults to true (Enabled)</li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes a request to the Sparql Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <remarks>
            Works by calling the <see cref="M:VDS.RDF.Web.BaseSparqlHandler.LoadConfig(System.Web.HttpContext)">LoadConfig</see> method which causes the derived class to load it's configuration and pass it back to this class.  It then retrieves the relevant standard fields from the Querystring and invokes the <see cref="M:VDS.RDF.Web.BaseSparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">ProcessQuery</see> method which the derived class has implemented the actual logic for the Sparql query in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Abstract method for implementation by derived classes which implement the actual logic of loading the relevant Configuration
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">
            <summary>
            Abstract method for implementation by derived classes which implements the actual logic of processing the Query
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="query">Sparql Query</param>
            <param name="userDefaultGraphs">User specified default Graph(s)</param>
            <param name="userNamedGraphs">User specified named Graph(s)</param>
            <param name="timeout">User specified Timeout</param>
            <param name="partialResults">Partial Results setting</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.ProcessResults(System.Web.HttpContext,System.Object)">
            <summary>
            Internal Helper function which returns the Results back to the Client in one of their accepted formats
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="result">Results of the Sparql Query</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.HandleErrors(System.Web.HttpContext,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing Sparql Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.BaseSparqlHandler.ShowQueryForm(System.Web.HttpContext)">
            <summary>
            Generates a Sparql Query Form
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:VDS.RDF.Web.BaseSparqlHandler.IsReusable">
            <summary>
            Indicates that the Handler is not reusable
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.SparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">
            <summary>
            Processes the Sparql Query Request
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="query">Sparql Query</param>
            <param name="userDefaultGraphs">User specified default Graph(s)</param>
            <param name="userNamedGraphs">User specified named Graph(s)</param>
            <param name="timeout">User specified timeout</param>
            <param name="partialResults">Partial Results setting</param>
        </member>
        <member name="M:VDS.RDF.Web.SparqlHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Configuration for the Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SparqlTokeniser">
            <summary>
            A Class for Reading an Input Stream and generating SPARQL Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.#ctor(System.IO.StreamReader,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Syntax Mode to use when parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.#ctor(VDS.RDF.Parsing.BlockingStreamReader,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Syntax Mode to use when parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultBinder">
            <summary>
            Helper Class used in the execution of Sparql Queries
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.#ctor">
            <summary>
            Internal Empty Constructor for derived classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.#ctor(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new Results Binder
            </summary>
            <param name="query">Query this provides Result Binding to</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value bound to a given Variable for a given Binding ID
            </summary>
            <param name="name">Variable Name</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Group(System.Int32)">
            <summary>
            Gets the Group referred to by the given ID
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.IsGroup(System.Int32)">
            <summary>
            Checks whether the given ID refers to a Group
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.SetGroupContext(System.Boolean)">
            <summary>
            Sets the Group Context for the Binder
            </summary>
            <param name="accessContents">Whether you want to access the Group Contents or the Groups themselves</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Dispose">
            <summary>
            Disposes of a Result Binder
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.Variables">
            <summary>
            Gets the Variables that the Binder stores Bindings for
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.BindingIDs">
            <summary>
            Gets the enumeration of valid Binding IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.Groups">
            <summary>
            Gets the set of Groups that result from the Query this Binder provides Binding to
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanResultBinder">
            <summary>
            Results Binder used by Leviathan
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.#ctor(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Creates a new Leviathan Results Binder
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value for a given Variable from the Set with the given Binding ID
            </summary>
            <param name="name">Variable</param>
            <param name="bindingID">Set ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.IsGroup(System.Int32)">
            <summary>
            Determines whether a given ID is for of a Group
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.Group(System.Int32)">
            <summary>
            Returns the Group with the given ID
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.SetGroupContext(System.Boolean)">
            <summary>
            Sets the Group Context for the Binder
            </summary>
            <param name="accessContents">Whether you want to access the Group Contents or the Groups themselves</param>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanResultBinder.Variables">
            <summary>
            Gets the Variables contained in the Input
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanResultBinder.BindingIDs">
            <summary>
            Gets the IDs of Sets
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanLeftJoinBinder">
            <summary>
            Special Temporary Results Binder used during LeftJoin's
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanLeftJoinBinder.#ctor(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Creates a new LeftJoin Binder
            </summary>
            <param name="multiset">Input Multiset</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanLeftJoinBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value for a given Variable from the Set with the given Binding ID
            </summary>
            <param name="name">Variable</param>
            <param name="bindingID">Set ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanLeftJoinBinder.Variables">
            <summary>
            Gets the Variables in the Input Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanLeftJoinBinder.BindingIDs">
            <summary>
            Gets the IDs of Sets
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.GenericReader">
            <summary>
            Class for reading RDF Graphs from an arbitrary Store into arbitrary Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.GenericReader.#ctor(VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance of the Generic Reader which connects to an arbitrary Store using the given Generic Manager
            </summary>
            <param name="manager">Manager for the underlying Store</param>
        </member>
        <member name="M:VDS.RDF.Parsing.GenericReader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Parsing.GenericReader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="T:VDS.RDF.LiteralEqualityMode">
            <summary>
            Possible Literal Equality Mode Settings
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Strict">
            <summary>
            Strict Mode compares Literals according to the official W3C RDF Specification
            </summary>
            <remarks>
            This means Literals are equal if and only if:
            <ol>
            <li>The Lexical Values are identical when compared using Ordinal Comparison</li>
            <li>The Language Tags if present are identical</li>
            <li>The Datatypes if present are identical</li>
            </ol>
            </remarks>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Loose">
            <summary>
            Loose Mode compares Literals based on values (if they have known Datatypes)
            </summary>
            <remarks>
            This means Literals can be equal if they have lexically different values which are equivalent when converted to the Datatype.
            <br/><br/>
            Literals without Datatypes and those whose Datatypes are unknown or not handled by the Library will be compared using lexical equivalence as with <see cref="F:VDS.RDF.LiteralEqualityMode.Strict">Strict</see> mode.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Options">
            <summary>
            Configures Global Static Options for the Library
            </summary>
            <remarks>Some of these are Debug Build only, please see the Remarks on individual members for more detail</remarks>
        </member>
        <member name="P:VDS.RDF.Options.LiteralEqualityMode">
            <summary>
            Gets/Sets the Mode used to compute Literal Equality (Default is <see cref="!:LiteralEqualityMode.Strict">Strict</see> which enforces the W3C RDF Specification)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.QueryExecutionTimeout">
            <summary>
            Gets/Sets the Hard Timeout limit for Sparql Query Execution (in milliseconds)
            </summary>
            <remarks>
            This is used to stop Sparql queries running away and never completing execution, it defaults to 5 mins (300,000 milliseconds)
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.QueryOptimisation">
            <summary>
            Gets/Sets whether Query Optimisation should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.QueryDefaultSyntax">
            <summary>
            Gets/Sets the default syntax used for parsing SPARQL queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.QueryEngine">
            <summary>
            Gets/Sets the engine used for processing SPARQL queries
            </summary>
            <remarks>
            <para>
            The default engine is the <see cref="F:VDS.RDF.Query.SparqlEngine.Leviathan">Leviathan</see> engine
            </para>
            <para>
            As of the 0.3.0 release there will once again be only one SPARQL engine present in the library since the obsolete Labyrinth engine has been removed
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.QueryAllowUnknownFunctions">
            <summary>
            Gets/Sets whether functions that can't be parsed into Expressions should be represented by the <see cref="!:NullExpression">NullExpression</see>
            </summary>
            <remarks>When set to false a Parser Error will be thrown if the Function cannot be parsed into an Expression</remarks>
        </member>
        <member name="P:VDS.RDF.Options.DefaultCompressionLevel">
            <summary>
            Gets/Sets the Default Compression Level used for Writers returned by the <see cref="T:VDS.RDF.MimeTypesHelper">MimeTypesHelper</see> class when the writers implement <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see>
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.FullTripleIndexing">
            <summary>
            Controls whether the <see cref="T:VDS.RDF.IndexedTripleCollection">IndexedTripleCollection</see> will create full indexes for the Triples inserted into it
            </summary>
            <remarks>
            <para>
            By default the <see cref="T:VDS.RDF.IndexedTripleCollection">IndexedTripleCollection</see> creates indexes on Triples based upon Subjects, Predicates and Objects alone.  When full indexing is enabled it also creates indexes based on Subject-Predicate, Predicate-Object and Subject-Object pairs which may improve query speed but will use additional memory.
            </para>
            <para>
            Default setting for Full Indexing is enabled, enabling/disabling it only has an effect on <see cref="T:VDS.RDF.IndexedTripleCollection">IndexedTripleCollection</see> instances instantiated after full indexing was enabled/disabled i.e. existing Graphs in memory using the <see cref="T:VDS.RDF.IndexedTripleCollection">IndexedTripleCollection</see> continue to use the full indexing setting that was present when they were instantiated.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.UriLoaderCaching">
            <summary>
            Gets/Sets whether the <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> uses caching
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.HttpDebugging">
            <summary>
            Gets/Sets whether HTTP Request and Response Information should be output to the Console Standard Out for Debugging purposes
            </summary>
            <remarks>
            <strong>Only available in Debug builds</strong>
            <br /><br />
            This does not guarentee that this information is output to the Console Standard Out, most code that makes HTTP requests should do this but it may vary depending on the Library build and the exact classes used.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.HttpFullDebugging">
            <summary>
            Gets/Sets whether the HTTP Response Stream should be output to the Console Standard Output for Debugging purposes
            </summary>
            <remarks>
            <strong>Only available in Debug builds</strong>
            <br/><br/>
            Only applies if <see cref="P:VDS.RDF.Options.HttpDebugging">HttpDebugging</see> is enabled
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.GenericWriter">
            <summary>
            Class for writing RDF Graphs to an arbitrary Store from an arbitrary Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.GenericWriter.#ctor(VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new instance of the Generic Writer which connects to an arbitrary Store using the given Generic Manager
            </summary>
            <param name="manager">Manager for the underlying Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.GenericWriter.Save(VDS.RDF.IGraph)">
            <summary>
            Saves the Graph into the Store
            </summary>
            <param name="g">Graph to save</param>
        </member>
        <member name="T:VDS.RDF.Writing.GenericStoreWriter">
            <summary>
            Class for writing Triple Stores to an arbitrary store using any <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> implementation
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.GenericStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves the given Triple Store to an arbitrary store
            </summary>
            <param name="store">Store to Save</param>
            <param name="parameters">Parameters for the Store</param>
            <remarks>
            Parameters must be of type <see cref="T:VDS.RDF.Storage.Params.GenericIOParams">GenericIOParams</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.GenericStoreWriter.WriteGraphs(VDS.RDF.Writing.Contexts.GenericStoreWriterContext)">
            <summary>
            Internal Worker method for Writer Threads
            </summary>
            <param name="context">Context for writing the Store</param>
        </member>
        <member name="E:VDS.RDF.Writing.GenericStoreWriter.Warning">
            <summary>
            Event which is raised if there is a non-fatal issue with writing to the underlying Store
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.GenericStoreWriter.WriteGraphsDelegate">
            <summary>
            Delegate for the WriteGraphs method
            </summary>
            <param name="context">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Web.UpdateHandler">
            <summary>
            HTTP Handler for adding SPARQL Update endpoints to ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to create an Update endpoint at a specific fixed URL
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Update Endpoint:
            <code>
            &lt;dotnetrdf:/folder/update&gt; a dnr:HttpHandler ;
                                             dnr:type "VDS.RDF.Web.UpdateHandler" ;
                                             dnr:updateProcessor _:proc .
                                            
            _:proc a dnr:SparqlUpdateProcessor ;
                   dnr:type "VDS.RDF.Update.LeviathanUpdateProcessor" ;
                   dnr:usingStore _:store .
                   
            _:store a dnr:TripleStore ;
                    dnr:type "VDS.RDF.TripleStore" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.UpdateHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.UpdateHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration">
            <summary>
            Abstract Base class for Handler Configuration for SPARQL Servers
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._queryProcessor">
            <summary>
            Query processor
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._updateProcessor">
            <summary>
            Update processor
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._protocolProcessor">
            <summary>
            Protocol processor
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._defaultGraph">
            <summary>
            Default Graph Uri for queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._defaultTimeout">
            <summary>
            Default Timeout for Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._defaultPartialResults">
            <summary>
            Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._supportsTimeout">
            <summary>
            Whether the Handler supports Timeouts
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._supportsPartialResults">
            <summary>
            Whether the Handler supports Partial Results on Timeout
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._timeoutField">
            <summary>
            Querystring Field name for the Timeout setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._partialResultsField">
            <summary>
            Querystring Field name for the Partial Results setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._showQueryForm">
            <summary>
            Whether a Query Form should be shown to the User
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._defaultQuery">
            <summary>
            Default Sparql Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._showUpdateForm">
            <summary>
            Whether Update Form should be shown
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._haltOnError">
            <summary>
            Whether the Handler should stop processing commands if a command errors
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration._defaultUpdate">
            <summary>
            Default Update Text for the Update Form
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Base SPARQL Server Configuration based on information from a Configuration Graph
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.DefaultGraphURI">
            <summary>
            Gets the Default Graph Uri
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.SupportsTimeout">
            <summary>
            Whether the Remote Endpoint supports specifying Query Timeout as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.DefaultTimeout">
            <summary>
            Gets the Default Query Execution Timeout
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.TimeoutField">
            <summary>
            Querystring field name for the Query Timeout for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.SupportsPartialResults">
            <summary>
            Whether the Remote Endpoint supports specifying Partial Results on Timeout behaviour as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.DefaultPartialResults">
            <summary>
            Gets the Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.PartialResultsField">
            <summary>
            Querystring field name for the Partial Results on Timeout setting for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.ShowQueryForm">
            <summary>
            Gets whether the Query Form should be shown to users
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.DefaultQuery">
            <summary>
            Gets the Default Query for the Query Form
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.ShowUpdateForm">
            <summary>
            Gets whether to show the Update Form if no update is specified
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.HaltOnError">
            <summary>
            Gets whether to Halt on Errors
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.DefaultUpdate">
            <summary>
            Gets the Default Update for the Update Form
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.QueryProcessor">
            <summary>
            Gets the SPARQL Query Processor
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.UpdateProcessor">
            <summary>
            Gets the SPARQL Update Processor
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Server.BaseSparqlServerConfiguration.ProtocolProcessor">
            <summary>
            Gets the SPARQL Uniform HTTP Protocol Processor
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Server.SparqlServerConfiguration">
            <summary>
            Concrete implementation of a Handler Configuration for SPARQL Servers
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Server.SparqlServerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new SPARQL Server Configuration from information in a Configuration Graph
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.GenericProtocolProcessor">
            <summary>
            A processor for the SPARQL Uniform HTTP Protocol which operates by performing the desired operations on some arbitrary underlying Store for which an <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> is available
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.GenericProtocolProcessor.#ctor(VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new Generic Protocol Processor
            </summary>
            <param name="manager">Generic IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.GenericProtocolProcessor.ProcessGet(System.Web.HttpContext)">
            <summary>
            Processes a GET operation
            </summary>
            <param name="context">HTTP Context</param>
            <remarks>
            Implemented by making a call to <see cref="M:VDS.RDF.Storage.IGenericIOManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">LoadGraph()</see> on the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.GenericProtocolProcessor.ProcessPost(System.Web.HttpContext)">
            <summary>
            Processes a POST operation
            </summary>
            <param name="context">HTTP Context</param>
            <remarks>
            <para>
            <strong>Warning: </strong> If the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> is read-only then this operation returns a 403 Forbidden.
            </para>
            <para>
            Otherwise this is implemented using <see cref="M:VDS.RDF.Storage.IGenericIOManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> if updates are supported, if not then the Graph has to be loaded, the POSTed data merged into it and then the Graph is saved again.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.GenericProtocolProcessor.ProcessPut(System.Web.HttpContext)">
            <summary>
            Processes a PUT operation
            </summary>
            <param name="context">HTTP Context</param>
            <remarks>
            <para>
            <strong>Warning: </strong> If the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> is read-only then this operation returns a 403 Forbidden.
            </para>
            <para>
            Implemented by calling <see cref="M:VDS.RDF.Storage.IGenericIOManager.SaveGraph(VDS.RDF.IGraph)">SaveGraph()</see> on the underlying manager
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.GenericProtocolProcessor.ProcessDelete(System.Web.HttpContext)">
            <summary>
            Processes a DELETE operation
            </summary>
            <param name="context">HTTP Context</param>
            <remarks>
            <para>
            <strong>Warning: </strong> If the underlying <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> is read-only then this operation returns a 403 Forbidden.
            </para>
            <para>
            The delete operation does not explicitly remove the Graph but simply replaces it with an empty Graph
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.Commands.ClearCommand">
            <summary>
            Represents the SPARQL Update CLEAR command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor(System.Uri)">
            <summary>
            Creates a Command which clears the given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor">
            <summary>
            Creates a Command which clears the Default Graph (if any)
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ClearCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be cleared (or null if the default graph should be cleared)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlEvaluationContext">
            <summary>
            Stores information about the Evaluation of a Query during it's evaluation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Evaluation Context for the given Query over the given Triple Store
            </summary>
            <param name="q">Query</param>
            <param name="data">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.#ctor(VDS.RDF.Query.SparqlResultBinder)">
            <summary>
            Creates a new Evaluation Context which is a Container for the given Result Binder
            </summary>
            <param name="binder"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.StartExecution">
            <summary>
            Starts the Execution Timer
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.EndExecution">
            <summary>
            Ends the Execution Timer
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.CheckTimeout">
            <summary>
            Checks whether Execution should Time out
            </summary>
            <exception cref="T:VDS.RDF.Query.RdfQueryTimeoutException">Thrown if the Query has exceeded the Execution Timeout</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Query">
            <summary>
            Gets the Query that is being evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Data">
            <summary>
            Gets the Triple Store the query is over
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.InputMultiset">
            <summary>
            Gets/Sets the Input Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.OutputMultiset">
            <summary>
            Gets/Sets the Output Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Binder">
            <summary>
            Gets/Sets the Results Binder
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.QueryTime">
            <summary>
            Retrieves the Time in milliseconds the query took to evaluate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.QueryTimeTicks">
            <summary>
            Retrieves the Time in ticks the query took to evaluate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService">
            <summary>
            Represents the Namespace Service provided by a Pellet Server knowledge base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Namespace Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService.GetNamespaces">
            <summary>
            Gets the Namespaces used in the Knowledge Base
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanMD5HashFunction">
            <summary>
            Represents the Leviathan lfn:md5hash() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanMD5HashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan MD5 Hash function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanMD5HashFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.LeviathanSha256HashFunction">
            <summary>
            Represents the Leviathan lfn:sha256hash() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSha256HashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan SHA 256 Hash function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.LeviathanSha256HashFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Minus">
            <summary>
            Represents the Minus join
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Minus join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Minus join by evaluating the LHS and RHS and substracting the RHS results from the LHS
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.ToString">
            <summary>
            Gets the string representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.NQuadsParser">
            <summary>
            Parser for parsing NQuads (NTriples with an additional Context i.e. Named Graphs)
            </summary>
            <remarks>
            <para>
            The Default Graph (if any) will be given the special Uri <strong>nquads:default-graph</strong>
            </para>
            <para>
            NQuads permits Blank Nodes and Literals to be used as Context, since the library only supports Graphs named with URIs these are translated into URIs of the following form:
            </para>
            <pre>
            nquads:bnode:12345678
            </pre>
            <pre>
            nquads:literal:87654321
            </pre>
            <para>
            In these URIs the numbers are the libraries hash codes for the node used as the Context.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.NQuadsParser.DefaultGraphURI">
            <summary>
            Default Graph Uri for default graphs parsed from NQuads input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.Load(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Loads the named Graphs from the NQuads input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="parameters">Parameters indicating the Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.OnWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="P:VDS.RDF.Parsing.NQuadsParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.NQuadsParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.FolderStoreParserContext">
            <summary>
            Parser Context for Folder Store parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.FolderStoreParams)">
            <summary>
            Creates a new Folder Store Parser Context
            </summary>
            <param name="store">Triple Store to parse into</param>
            <param name="params">Folder Store Parameters</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.#ctor(VDS.RDF.ITripleStore,System.String,VDS.RDF.Storage.FolderStoreFormat,System.Int32)">
            <summary>
            Creates a new Folder Store Parser Context
            </summary>
            <param name="store">Triple Store to parse into</param>
            <param name="folder">Folder</param>
            <param name="format">Format</param>
            <param name="threads">Threads to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.#ctor(VDS.RDF.ITripleStore,System.String,VDS.RDF.Storage.FolderStoreFormat)">
            <summary>
            Creates a new Folder Store Parser Context
            </summary>
            <param name="store">Triple Store to parse into</param>
            <param name="folder">Folder</param>
            <param name="format">Format</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.Add(System.String)">
            <summary>
            Adds a filename to the queue of files to be read
            </summary>
            <param name="filename">Filename</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.GetNextFilename">
            <summary>
            Gets the filename of the next file to be read
            </summary>
            <returns>Filename of next Graph to be read</returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.Folder">
            <summary>
            Gets the Folder containing the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.Format">
            <summary>
            Gets/Sets the Format of the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.FolderStoreParserContext.Threads">
            <summary>
            Gets the number of threads to use
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.Ontology">
            <summary>
            Represents the meta-information about an Ontology
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology for the given resource
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(System.Uri)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearBackwardsCompatibleWith">
            <summary>
            Removes all <em>owl:backwardsCompatibleWith</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(System.Uri)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(System.Uri)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearIncompatibleWith">
            <summary>
            Removes all <em>owl:incompatibleWith</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(System.Uri)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(System.Uri)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearImports">
            <summary>
            Removes all <em>owl:imports</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(System.Uri)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(System.Uri)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearPriorVersions">
            <summary>
            Removes all <em>owl:priorVersion</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(System.Uri)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.BackwardsCompatibleWith">
            <summary>
            Gets all the Ontologies that this Ontology is backwards compatible with
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.IncompatibleWith">
            <summary>
            Gets all the Ontologies that this Ontology is incompatible with
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.Imports">
            <summary>
            Gets all the Ontologies that this Ontology imports
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.PriorVersions">
            <summary>
            Gets all the Ontologies that are prior versions of this Ontology
            </summary>
        </member>
        <member name="T:VDS.RDF.BlankNodeMapper">
            <summary>
            Mapper class which creates Blank Node IDs and ensures that auto-assigned and user specified IDs don't collide
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.GetNextID">
            <summary>
            Gets the next available auto-assigned Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.CheckID(System.String@)">
            <summary>
            Checks that an ID can be used as a Blank Node ID remapping it to another ID if necessary
            </summary>
            <param name="id">ID to be checked</param>
            <remarks>
            If the ID is not known it is added to the ID maps.  If the ID is known but is user-assigned then this can be used fine.  If the ID is known and was auto-assigned then it has to be remapped to a different ID.
            </remarks>
        </member>
        <member name="T:VDS.RDF.BlankNodeOutputMapper">
            <summary>
            Mapper class which remaps Blank Node IDs which aren't valid as-is in a given serialization to a new ID
            </summary>
            <remarks>
            This also has to take care of the fact that it's possible that these remapped IDs then collide with existing valid IDs in which case these also have to be remapped
            </remarks>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.#ctor(System.Func{System.String,System.Boolean})">
            <summary>
            Creates a new Blank Node ID mapper
            </summary>
            <param name="validator">Function which determines whether IDs are valid or not</param>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.GetOutputID(System.String)">
            <summary>
            Takes a ID, validates it and returns either the ID or an appropriate remapped ID
            </summary>
            <param name="id">ID to map</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.GetNextID">
            <summary>
            Internal Helper function which generates the new IDs
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BlankNodeIDAssigment">
            <summary>
            Records Blank Node assigments
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNodeIDAssigment.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Blank Node ID Assigment Record
            </summary>
            <param name="id">ID to assign</param>
            <param name="auto">Was the ID auto-assigned</param>
        </member>
        <member name="M:VDS.RDF.BlankNodeIDAssigment.Equals(System.Object)">
            <summary>
            Returns whether a given Object is equal to this Blank Node ID assignment
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BlankNodeIDAssigment.ID">
            <summary>
            Assigned ID
            </summary>
        </member>
        <member name="P:VDS.RDF.BlankNodeIDAssigment.AutoAssigned">
            <summary>
            Whether the ID is auto-assigned
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.QueryProcessorFactory">
            <summary>
            Factory class for producing SPARQL Query Processors from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.QueryProcessorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Query Processor based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.QueryProcessorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.UpdateProcessorFactory">
            <summary>
            Factory class for producing SPARQL Update Processors from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.UpdateProcessorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Update based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.UpdateProcessorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ProtocolProcessorFactory">
            <summary>
            Factory class for producing SPARQL Uniform HTTP Protocol Processors from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ProtocolProcessorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Uniform HTTP Protocol Processor based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ProtocolProcessorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.UserGroup">
            <summary>
            Represents a Group of Users and the permissions they have to perform actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.#ctor">
            <summary>
            Creates a new User Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.#ctor(System.Boolean)">
            <summary>
            Creates a new User Group which may allow guests
            </summary>
            <param name="allowGuest">Are guests allowed?</param>
            <remarks>
            If guests are allowed then this Groups permissions apply to unauthenticated users
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddUser(System.Net.NetworkCredential)">
            <summary>
            Adds a User to the Group
            </summary>
            <param name="credentials">User Credentials</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddAllowedAction(VDS.RDF.Configuration.Permissions.IPermission)">
            <summary>
            Adds an allow action permission to the Group
            </summary>
            <param name="permission">Permission</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddDeniedAction(VDS.RDF.Configuration.Permissions.IPermission)">
            <summary>
            Adds a deny action permission to the Group
            </summary>
            <param name="permission">Permission</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.HasMember(System.String,System.String)">
            <summary>
            Returns whether the Group has a member with the given credentials
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.IsActionPermitted(System.String)">
            <summary>
            Gets whether the Group permits the action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Configuration.Permissions.UserGroup.AllowGuests">
            <summary>
            Gets/Sets whether Guests are allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Configuration.Permissions.UserGroup.PermissionModel">
            <summary>
            Gets/Sets the in-use Permission Model
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleStore">
            <summary>
            Class for representing Triple Stores which are collections of RDF Graphs
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._activeGraph">
            <summary>
            Reference to the Active Graph being used for executing a Sparql Query
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._defaultGraph">
            <summary>
            Default Graph for executing Sparql Queries against
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._activeGraphs">
            <summary>
            Stack of Active Graph References used for executing a Sparql Query when there are nested GRAPH Clauses
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._reasoners">
            <summary>
            List of Reasoners that are applied to Graphs as they are added to the Triple Store
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._storeInferencesExternally">
            <summary>
            Controls whether inferred information is stored in a special Graph or in the original Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._inferenceGraphUri">
            <summary>
            Graph Uri for the special Graph used to store inferred information
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.Contains(VDS.RDF.Triple)">
            <summary>
            Returns whether the Store contains the given Triple within the Query Triples
            </summary>
            <param name="t">Triple to search for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetNodes(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Nodes that meet the criteria of a given ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from all the Query Triples
            </summary>
            <param name="firstSelector">First Selector in the Chain</param>
            <param name="selectorChain">Dependent Selectors which form the rest of the Chain</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from all the Query Triples
            </summary>
            <param name="selectorChain">Chain of Independent Selectors</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Internal Helper method for applying a Selector to a subset of the Triples in the Triple Store
            </summary>
            <param name="triples">Subset of Triples</param>
            <param name="selector">Selector Class to perform the Selection</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Selects all Triples which meet the criteria of an ISelector from all the Query Triples
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Object Node meets the criteria of an ISelector from all Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Predicate meets the criteria of an ISelector from all Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Subject meets the criteria of an ISelector from all Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.TriplesExist(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples meeting the criteria of an ISelector can be found from all Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Predicate pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Predicate-Object pair from all the Query Triples
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Object pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetNodes(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Nodes that meet the criteria of a given ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="selector">A Selector on Nodes</param>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IDependentSelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from a Subset of Graphs in the Triple Store where the results of each Selector influence the next selector and selection at each stage is over the selected subset of Graphs
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="firstSelector">First Selector in the Chain</param>
            <param name="selectorChain">Dependent Selectors which form the rest of the Chain</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Collections.Generic.List{VDS.RDF.ISelector{VDS.RDF.Triple}})">
            <summary>
            Selects all Triples which are selected by a chain of Selectors from a Subset of Graphs in the Triple Store where each Selector is independent and selection at each stage is over the results of the previous selection stages
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selectorChain">Chain of Independent Selectors</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Selects all Triples which meet the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Object Node meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Predicate meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.INode})">
            <summary>
            Selects all Triples where the Subject meets the criteria of an ISelector from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.TriplesExist(System.Collections.Generic.List{System.Uri},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Checks whether any Triples meeting the criteria of an ISelector can be found from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="selector">A Selector on Triples</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a Sparql Query on the Triple Store
            </summary>
            <param name="strSparqlQuery">Sparql Query as unparsed String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as a <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> instance</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.SetDefaultGraph(VDS.RDF.IGraph)">
            <summary>
            Sets the Default Graph for the SPARQL Query
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:VDS.RDF.TripleStore.SetActiveGraph(VDS.RDF.IGraph)">
            <summary>
            Sets the Active Graph for the SPARQL Query
            </summary>
            <param name="g">Active Graph</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph for the SPARQL query
            </summary>
            <param name="graphUri">Uri of the Active Graph</param>
            <remarks>
            Helper function used primarily in the execution of GRAPH Clauses
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.SetActiveGraph(System.Collections.Generic.List{System.Uri})">
            <summary>
            Sets the Active Graph for the Sparql query
            </summary>
            <param name="graphUris">URIs of the Graphs which form the Active Graph</param>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ResetActiveGraph">
            <summary>
            Sets the Active Graph for the Sparql query to be the previous Active Graph
            </summary>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store applying Inference if any Reasoners have been set
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store using the chosen Merging Behaviour and applies inference if any Reasoners have been set
            </summary>
            <param name="g">Graph to Load</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
            <remarks>
            Inference Engines are applied in the order that they were added to the Store
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ApplyInference(VDS.RDF.IGraph)">
            <summary>
            Applies Inference to the given Graph
            </summary>
            <param name="g">Graph to apply inference to</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.AddInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Adds an Inference Engine to the Triple Store
            </summary>
            <param name="reasoner">Reasoner to add</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.RemoveInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Removes an Inference Engine from the Triple Store
            </summary>
            <param name="reasoner">Reasoner to remove</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.ClearInferenceEngines">
            <summary>
            Clears all Inference Engines from the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.Dispose">
            <summary>
            Disposes of a Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes an Update against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command(s)</param>
            <remarks>
            As per the SPARQL 1.1 Update specification the command string may be a sequence of commands
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a single Update Command against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of Update Commands against the Triple Store
            </summary>
            <param name="updates">SPARQL Update Command Set</param>
        </member>
        <member name="P:VDS.RDF.TripleStore.QueryTriples">
            <summary>
            Gets the Set of Triples that are currently being queried over by a SPARQL Query
            </summary>
        </member>
        <member name="T:VDS.RDF.SqlTripleStore">
            <summary>
            Class for representing Triple Stores which are automatically stored to a backing SQL Store as it is modified
            </summary>
        </member>
        <member name="F:VDS.RDF.SqlTripleStore._manager">
            <summary>
            Store Manager which manages the IO to the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.#ctor">
            <summary>
            Empty Constructor for use by derived classes
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Opens a SQL Triple Store using the provided Store Manager, automatically loads all data contained in that Store
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen backing SQL Store</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Opens a SQL Triple Store using the default Manager for a dotNetRDF Store accessible at the given database settings, automatically loads all data contained in that Store
            </summary>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.#ctor(System.String,System.String,System.String)">
            <summary>
            Opens a SQL Triple Store using the default Manager for a dotNetRDF Store accessible at the given database settings, automatically loads all data contained in that Store
            </summary>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the Store is located on the localhost</remarks>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.LoadInternal">
            <summary>
            Internal Method which loads the data from the SQL backed Store when the class is instantiated
            </summary>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store using the desired Merge Behaviour
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph into the Triple Store by retrieving it from the given Uri
            </summary>
            <param name="graphUri">Uri of the Graph to add</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store by retrieving it from the given Uri and using the selected Merge Behaviour
            </summary>
            <param name="graphUri">Uri of the Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.SqlTripleStore.Dispose">
            <summary>
            Disposes of the Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.ThreadedSqlTripleStore">
            <summary>
            Class for representing Triple Stores which are automatically stored to a backing SQL Store as it is modified, use this class with large Stores to load them more efficiently
            </summary>
            <remarks>Uses multi-threaded loading to improve initial Load Times</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager,System.Int32,System.Boolean)">
            <summary>
            Opens a SQL Triple Store using the provided Store Manager, automatically loads all data contained in that Store
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> for your chosen backing SQL Store</param>
            <param name="threads">The Number of Threads to use for Loading (Default is 8)</param>
            <param name="async">Whether loading should be done asynchronously</param>
            <remarks>
            If loading is set to Asynchronous then the Graphs will be loaded in a multi-threaded fashion without waiting for them to load before proceeding.  This means that code can start working immediately with the Triple Store but that the data contained in it may be incomplete.
            <br/>
            The default behaviour is for Synchronous loading which means calling code must wait for the Triple Store to load before it can proceeed.
            </remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager,System.Boolean)">
            <summary>
            Opens a SQL Triple Store using the provided Store Manager, automatically loads all data contained in that Store
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> for your chosen backing SQL Store</param>
            <param name="async">Whether loading should be done asynchronously</param>
            <remarks>Uses the Default 8 Threads for Loading</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager,System.Int32)">
            <summary>
            Opens a SQL Triple Store using the provided Store Manager, automatically loads all data contained in that Store
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> for your chosen backing SQL Store</param>
            <param name="threads">The Number of Threads to use for Loading (Default is 8)</param>
            <remarks>Uses Synchronous Loading</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(VDS.RDF.Storage.IThreadedSqlIOManager)">
            <summary>
            Opens a SQL Triple Store using the provided Store Manager, automatically loads all data contained in that Store
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> for your chosen backing SQL Store</param>
            <remarks>Uses the Default 8 Threads for Loading</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Opens a SQL Triple Store using the default Threaded Manager for a dotNetRDF Store accessible at the given database settings, automatically loads all data contained in that Store
            </summary>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Uses the Default 8 Threads for Loading</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.#ctor(System.String,System.String,System.String)">
            <summary>
            Opens a SQL Triple Store using the default Threaded Manager for a dotNetRDF Store accessible at the given database settings, automatically loads all data contained in that Store
            </summary>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes the Store is on the localhost.  Uses the Default 8 Threads for Loading</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.LoadInternal">
            <summary>
            Internal Method which loads the data from the SQL backed Store when the class is instantiated
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.LoadGraphs">
            <summary>
            Internal Method which performs multi-threaded loading of data
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadedSqlTripleStore.GetNextUri">
            <summary>
            Internal Helper method which manages concurrent access to the queue of URIs of Graphs to be loaded
            </summary>
            <returns>Uri of next Graph to be loaded</returns>
        </member>
        <member name="T:VDS.RDF.Writing.UriRefType">
            <summary>
            Possible URI Reference Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.QName">
            <summary>
            Must be a QName
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.QNameOrUri">
            <summary>
            May be a QName or a URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.UriRef">
            <summary>
            URI Reference
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.Uri">
            <summary>
            URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfXmlWriter">
            <summary>
            Class for generating RDF/XML Concrete Syntax
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> This class is obsoleted and should no longer be used, use <see cref="T:VDS.RDF.Writing.RdfXmlTreeWriter">RdfXmlTreeWriter</see> or <see cref="T:VDS.RDF.Writing.FastRdfXmlWriter">FastRdfXmlWriter</see> instead as these classes provide faster and more accurate writers
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph as RDF/XML to the given File
            </summary>
            <param name="g">Graph to Save</param>
            <param name="filename">Filename of the File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph as RDF/XML to the given
            </summary>
            <param name="g"></param>
            <param name="output"></param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.GenerateOutput(VDS.RDF.IGraph)">
            <summary>
            Internal Helper method which generates the RDF/XML output from a Graph
            </summary>
            <param name="g">Graph being output</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.GeneratePropertyOutput(VDS.RDF.IGraph,VDS.RDF.INode,System.Boolean)">
            <summary>
            Internal Helper method which generates the RDF/XML output for a Node
            </summary>
            <param name="g">Graph being output</param>
            <param name="n">Node to output</param>
            <param name="isPropertyStripe">Is this a Property Strip in the RDF/XML output</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event if an event handler is registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether the RDF/XML output should be pretty printed
            </summary>
            <remarks>Controls whether the RDF/XML produced is indented to be human readable, enabled by default</remarks>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used for the Output
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.RdfXmlWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the Graph being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CompressingTurtleWriter">
            <summary>
            Class for generating Turtle Concrete RDF Syntax which provides varying levels of Syntax Compression
            </summary>
            <remarks>
            Similar in speed to the standard <see cref="T:VDS.RDF.Writing.TurtleWriter">TurtleWriter</see> but capable of using more syntax compressions depending on the Compression level set
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor">
            <summary>
            Creates a new Compressing Turtle Writer which uses the Default Compression Level
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor(System.Int32)">
            <summary>
            Creates a new Compressing Turtle Writer which uses the given Compression Level
            </summary>
            <param name="compressionLevel">Desired Compression Level</param>
            <remarks>See Remarks for this classes <see cref="P:VDS.RDF.Writing.CompressingTurtleWriter.CompressionLevel">CompressionLevel</see> property to see what effect different compression levels have</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to a file using Turtle Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to the given Stream using Turtle Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext)">
            <summary>
            Generates the Turtle Syntax for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateTripleOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Generates Output for Triples as a single "s p o." Triple
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to output</param>
            <returns></returns>
            <remarks>Used only in High Speed Write Mode</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment,System.Int32)">
            <summary>
            Generates Output for Nodes in Turtle syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <param name="indent">Indentation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateCollectionOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Writing.OutputRDFCollection,System.Int32)">
            <summary>
            Internal Helper method which converts a Collection into Turtle Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="c">Collection to convert</param>
            <param name="indent">Indentation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.OnWarning(System.String)">
            <summary>
            Helper method for generating Parser Warning Events
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode should be allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level to be used
            </summary>
            <remarks>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.None">None</see> then High Speed mode will always be used regardless of the input Graph and the <see cref="P:VDS.RDF.Writing.CompressingTurtleWriter.HighSpeedModePermitted">HighSpeedMorePermitted</see> property.
            </para>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.Minimal">Minimal</see> or above then full Predicate Object lists will be used for Triples.
            </para>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.More">More</see> or above then Blank Node Collections and Collection syntax will be used if the Graph contains Triples that can be compressed in that way.</para>
            </remarks>
        </member>
        <member name="E:VDS.RDF.Writing.CompressingTurtleWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the Graph being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlExpressionFactory">
            <summary>
            Factory Class for generating Expressions for Sparql Extension Functions
            </summary>
            <remarks>
            <para>
            Allows for users of the Library to implement and register Custom Expression Factories which can generate Expressions for their own Extension functions which they wish to use in their SPARQL queries.   Custom factories may be globally scoped by registering them with the <see cref="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory)">AddCustomFactory()</see> method or locally by passing them to the three argument constructor of the <see cref="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression})">CreateExpression()</see> method.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionFactory._customFactories">
            <summary>
            List of Custom Expression factories
            </summary>
            <remarks>
            All the standard function libraries (XPath, Leviathan and ARQ) included in dotNetRDF are automatically registered
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <returns></returns>
            <remarks>
            <para>
            Uses only the globally scoped custom expression factories
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <param name="factories">Enumeration of locally scoped expression factories to use</param>
            <returns></returns>
            <remarks>
            <para>
            Globally scoped custom expression factories are tried first and then any locally scoped expression factories are used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory)">
            <summary>
            Registers a Custom Expression Factory
            </summary>
            <param name="factory">A Custom Expression Factory</param>
        </member>
        <member name="T:VDS.RDF.Parsing.BlockingStreamReader">
            <summary>
            A wrapper to a Stream which does all its Read() and Peek() calls using ReadBlock() to handle slow underlying streams (eg Network Streams)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingStreamReader.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new Blocking Stream Reader from a StreamReader
            </summary>
            <param name="reader">Stream Reader to wrap in a Blocking Stream Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingStreamReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Blocking Stream Reader from a Stream
            </summary>
            <param name="stream">Stream to wrap in a Blocking Stream Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingStreamReader.Read">
            <summary>
            Reads a single character from the input Stream and advances the position in the Stream
            </summary>
            <returns>Next character from the Stream or -1 if at the end of the Stream</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingStreamReader.Peek">
            <summary>
            Reads the next character in the input Stream but preserves the position in the Stream
            </summary>
            <returns>Next Character from the Stream or -1 if at the end of the Stream</returns>
        </member>
        <member name="P:VDS.RDF.Parsing.BlockingStreamReader.EndOfStream">
            <summary>
            Gets whether the End of the Stream been reached
            </summary>
            <remarks>Since <see cref="P:System.IO.StreamReader.EndOfStream">StreamReader.EndOfStream</see> cannot be overridden this class only shadows the property.  This means if you use a <see cref="T:VDS.RDF.Parsing.BlockingStreamReader">BlockingStreamReader</see> in a variable typed <see cref="T:System.IO.StreamReader">StreamReader</see> you will hit the end of the Stream one character early which may cause you issues.  If you need a <see cref="T:VDS.RDF.Parsing.BlockingStreamReader">BlockingStreamReader</see> then you must ensure to strongly type it as such</remarks>
        </member>
        <member name="T:VDS.RDF.TalisGraph">
            <summary>
            A Graph which represents the description that an underlying Talis store has of a given Uri from the Metabox or a Private Graph
            </summary>
            <remarks>
            Any Changes to this Graph locally are persisted to the Talis platform using a Background Thread, if a process using this class terminates unexpectedly some changes may be lost.
            </remarks>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new instance of a Talis Graph which contains the description of the given Uri from the given underlying Talis Store
            </summary>
            <param name="resourceUri">Uri of resource to retrieve a Description of</param>
            <param name="connector">Connection to a Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.Uri,VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new instance of a Talis Graph which contains the description of the given Uri from the given underlying Talis Store
            </summary>
            <param name="resourceUri">Uri of resource to retrieve a Description of</param>
            <param name="connector">Connection to a Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Talis Graph which contains the description of the given Uri from the given underlying Talis Store
            </summary>
            <param name="resourceUri">Uri of resource to retrieve a Description of</param>
            <param name="storeName">Name of the Talis Store</param>
            <param name="username">Username for the Talis Store</param>
            <param name="password">Password for the Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.Uri,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Talis Graph which contains the description of the given Uri from the given underlying Talis Store
            </summary>
            <param name="resourceUri">Uri of resource to retrieve a Description of</param>
            <param name="storeName">Name of the Talis Store</param>
            <param name="username">Username for the Talis Store</param>
            <param name="password">Password for the Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,System.String,VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new instance of a Talis Graph which represents the description of a Resource from one of the Private Graphs from the underlying Talis Store
            </summary>
            <param name="privateGraphID">Private Graph</param>
            <param name="connector">Connection to a Talis Store</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Talis Graph which represents the description of a Resource from one of the Private Graphs from the underlying Talis Store
            </summary>
            <param name="privateGraphID">Private Graph</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
            <param name="storeName">Name of the Talis Store</param>
            <param name="username">Username for the Talis Store</param>
            <param name="password">Password for the Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,System.Uri,VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new instance of a Talis Graph which represents the description of a Resource from one of the Private Graphs from the underlying Talis Store
            </summary>
            <param name="privateGraphID">Private Graph</param>
            <param name="connector">Connection to a Talis Store</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.#ctor(System.String,System.Uri,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Talis Graph which represents the description of a Resource from one of the Private Graphs from the underlying Talis Store
            </summary>
            <param name="privateGraphID">Private Graph</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
            <param name="storeName">Name of the Talis Store</param>
            <param name="username">Username for the Talis Store</param>
            <param name="password">Password for the Talis Store</param>
        </member>
        <member name="M:VDS.RDF.TalisGraph.UpdateStore">
            <summary>
            Persists the Change Buffers to the Talis Store using the Talis Platform Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.TalisGraph.Dispose">
            <summary>
            Disposes of a Talis Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.NativeSparqlHandler">
            <summary>
            A HTTP Handler for Sparql Queries which use the Sparql implementation of one the libraries supported Triple Stores which provide their own Sparql implementations
            </summary>
            <remarks>
            <para>
            Effectively acts as a front-end to the Sparql engine of a native Triple Store for which dotNetRDF provides integration
            </para>
            <para>
            This Handler supports registering the Handler multiple times in one Web application with each able to use its own settings.
            </para>
            <para>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the virtual path of the handler like so:
            <code>&lt;add key="/virtualRoot/sparql/" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </para>
            <para>
            The following Configuration Variables are supported in addition to those supported by the <see cref="T:VDS.RDF.Web.BaseSparqlHandler">BaseSparqlHandler</see>:
            </para>
            <ul>
            <li><strong>StoreType</strong> (<em>Required</em>) - Sets the type of Native Store being used, supported values are found in the <see cref="T:VDS.RDF.Web.HandlerStoreTypes">HandlerStoreTypes</see> enumeration.  Any of the backing stores currently supported by dotNetRDF can be used with the Handler</li>
            <li><strong>StoreName</strong> (<em>Required/Optional</em>) - Sets the name of the Store (required for Talis, Sesame and Allegro; optional for Virtuoso; not used for 4store).  Defaults to the default Native Quad Store database <strong>DB</strong> for Virtuoso</li>
            <li><strong>StoreServer</strong> (<em>Optional</em>) - Sets the server that Store is running on, defaults to <strong>localhost</strong>.  For 4store, AllegroGraph and Sesame this is the Base Uri for accessing the server.</li>
            <li><strong>StoreCatalog</strong> (<em>Required/Optional</em>) - Sets the Catalog ID (for use with Allegro only)</li>
            <li><strong>StorePort</strong> (<em>Optional</em>) - Sets the server port that the Store is running on, defaults to <strong>1111</strong> (Only used by Virtuoso).  For 4store, AllegroGraph and Sesame any port information should be included in the Uri set in the <strong>StoreServer</strong> setting</li>
            <li><strong>StoreUser</strong> (<em>Required/Optional</em>) - Sets the Username for connecting to the Store (optional for Talis, Sesame and Allegro; required for Virtuoso; not used for 4store)</li>
            <li><strong>StorePassword</strong> (<em>Required/Optional</em>) - Sets the Password for connecting to the Store (optional for Talis, Sesame and Allegro; required for Virtuoso; not used for 4store)</li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.NativeSparqlHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Configuration for a Native Sparql Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.NativeSparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">
            <summary>
            Process a Sparql Query by executing against the Native Stores Sparql implementation
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="query">Sparql Query</param>
            <param name="userDefaultGraphs">User specified default Graph(s)</param>
            <param name="userNamedGraphs">User specified named Graph(s)</param>
            <param name="timeout">User specified timeout</param>
            <param name="partialResults">Partial Results setting</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.DiskResourceHandlerConfiguration">
            <summary>
            Loads and Stores the Configuration Information for a <see cref="T:VDS.RDF.Web.DiskResourceHandler">DiskResourceHandler</see>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SesameHttpProtocolConnector">
            <summary>
            Class for connecting to any Store that supports the Sesame 2.0 HTTP Communication protocol
            </summary>
            <remarks>
            <para>
            See <a href="http://www.openrdf.org/doc/sesame2/system/ch08.html">here</a> for the protocol specification
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.SesameHttpProtocolConnector._baseUri">
            <summary>
            Base Uri for the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SesameHttpProtocolConnector._store">
            <summary>
            Store ID
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SesameHttpProtocolConnector._username">
            <summary>
            Username for accessing the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SesameHttpProtocolConnector._pwd">
            <summary>
            Password for accessing the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SesameHttpProtocolConnector._hasCredentials">
            <summary>
            Whether the User has provided credentials for accessing the Store using authentication
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.Query(System.String)">
            <summary>
            Makes a Sparql Query against the underlying Store
            </summary>
            <param name="sparqlQuery">Sparql Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>If a Null Uri is specified then the entire contents of the Store will be loaded</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>If an empty Uri is specified then the entire contents of the Store will be loaded</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph into the Store (Warning: Completely replaces any existing Graph with the same URI unless there is no URI - see remarks for details)
            </summary>
            <param name="g">Graph to save</param>
            <remarks>
            If the Graph has no URI then the contents will be appended to the Store, if the Graph has a URI then existing data associated with that URI will be replaced
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.Dispose">
            <summary>
            Disposes of the Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.SesameHttpProtocolConnector.BaseUri">
            <summary>
            Gets the Base URI to the repository
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SesameHttpProtocolConnector.UpdateSupported">
            <summary>
            Returns that Updates are supported on Sesame HTTP Protocol supporting Stores
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SesameHttpProtocolConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SesameHttpProtocolConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.NonNativeVirtuosoManager">
            <summary>
            A <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> implementation which uses a Virtual Database from Virtuoso Universal Server as the backing store
            </summary>
            <threadsafety instance="true">
            <para>
            Designed to be Thread safe for concurrent read and write access
            </para>
            <para>
            <strong>Note:</strong> To ensure correct behaviour for multi-threaded writing you must set the <see cref="P:VDS.RDF.Storage.BaseStoreManager.DisableTransactions">DisableTransactions</see> property to be true.  Classes which are designed specifically to do multi-threaded writing will <em>usually</em> set this automatically.
            </para>
            <para>
            Will only be thread safe for writing if all the classes writing to the database are using a single instance of this Manager.
            </para>
            </threadsafety>
            <remarks>
            Since there is no way of knowing what the underlying Database of a Virtual Database in Virtuoso is this Manager cannot automatically create the dotNetRDF Store since it does not know which SQL Setup script to use.  You <strong>must</strong> configure your virtual database yourself before using this Manager to access it.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Non-Native Virtuoso Manager
            </summary>
            <param name="server">Server</param>
            <param name="port">Port</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Non-Native Virtuoso Manager
            </summary>
            <param name="server">Server</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
            <remarks>Assumes the Database uses the default port of <strong>1111</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Non-Native Virtuoso Manager
            </summary>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
            <remarks>Assumes the Database is on the <strong>localhost</strong> and uses the default port of <strong>1111</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
            <remarks>A Connection and Transaction per Thread are used</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.ExecuteQuery(System.String,System.Data.DataTable)">
            <summary>
            Executes a Query SQL Command against the database and fills the supplied DataTable with the results
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <param name="data">DataTable to fill with results</param>
            <remarks>Allows for queries which wish to strongly type the results for quicker reading</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.NonNativeVirtuosoManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="T:VDS.RDF.Web.QueryHandler">
            <summary>
            HTTP Handler for adding SPARQL Query endpoints to ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to create a Query endpoint at a specific fixed URL
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Query Endpoint:
            <code>
            &lt;dotnetrdf:/folder/query&gt; a dnr:HttpHandler ;
                                            dnr:type "VDS.RDF.Web.QueryHandler" ;
                                            dnr:queryProcessor _:proc .
                                            
            _:proc a dnr:SparqlQueryProcessor ;
                   dnr:type "VDS.RDF.Query.LeviathanQueryProcessor" ;
                   dnr:usingStore _:store .
                   
            _:store a dnr:TripleStore ;
                    dnr:type "VDS.RDF.TripleStore" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.QueryHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.QueryHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration">
            <summary>
            Abstract Base class for SPARQL Query Handlers
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._processor">
            <summary>
            Query Processor to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._defaultGraph">
            <summary>
            Default Graph Uri for queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._defaultTimeout">
            <summary>
            Default Timeout for Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._defaultPartialResults">
            <summary>
            Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._supportsTimeout">
            <summary>
            Whether the Handler supports Timeouts
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._supportsPartialResults">
            <summary>
            Whether the Handler supports Partial Results on Timeout
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._timeoutField">
            <summary>
            Querystring Field name for the Timeout setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._partialResultsField">
            <summary>
            Querystring Field name for the Partial Results setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._showQueryForm">
            <summary>
            Whether a Query Form should be shown to the User
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration._defaultQuery">
            <summary>
            Default Sparql Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Query Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.Processor">
            <summary>
            Gets the Processor used to evaluate queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.DefaultGraphURI">
            <summary>
            Gets the Default Graph Uri
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.SupportsTimeout">
            <summary>
            Whether the Remote Endpoint supports specifying Query Timeout as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.DefaultTimeout">
            <summary>
            Gets the Default Query Execution Timeout
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.TimeoutField">
            <summary>
            Querystring field name for the Query Timeout for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.SupportsPartialResults">
            <summary>
            Whether the Remote Endpoint supports specifying Partial Results on Timeout behaviour as a querystring parameter
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.DefaultPartialResults">
            <summary>
            Gets the Default Partial Results on Timeout behaviour
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.PartialResultsField">
            <summary>
            Querystring field name for the Partial Results on Timeout setting for Remote Endpoints which support it
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.ShowQueryForm">
            <summary>
            Gets whether the Query Form should be shown to users
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.BaseQueryHandlerConfiguration.DefaultQuery">
            <summary>
            Gets the Default Query for the Query Form
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.QueryHandlerConfiguration">
            <summary>
            Basic implementation of a Query Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.QueryHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Protocol Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateSpecsHelper">
            <summary>
            Static Helper class for providing constants, helper functions etc regarding the SPARQL Update specification
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateEvaluationContext">
            <summary>
            Evaluation Context for SPARQL Updates evaluated by the libraries Leviathan SPARQL Engine
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new SPARQL Update Evaluation Context
            </summary>
            <param name="store">In-memory queryable store</param>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.Data">
            <summary>
            Store upon which the Updates are applied
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommandSet">
            <summary>
            Represents a sequence of SPARQL Update Commands to be executed on a Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor">
            <summary>
            Creates a new empty Command Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Creates a new Command Set containing the given Command
            </summary>
            <param name="command">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Update.SparqlUpdateCommand})">
            <summary>
            Creates a new Command Set with the given Commands
            </summary>
            <param name="commands">Commands</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.AddCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Adds a new Command to the end of the sequence of Commands
            </summary>
            <param name="command">Command to add</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command Set using the given Update Processor
            </summary>
            <param name="processor">Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.ToString">
            <summary>
            Gets the String representation of the Command Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.Item(System.Int32)">
            <summary>
            Gets the Command at the given index
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.CommandCount">
            <summary>
            Gets the number of Commands in the set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.Commands">
            <summary>
            Gets the enumeration of Commands in the set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Command Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathDateTimeFunction">
            <summary>
            Abstract Base Class for functions which are Unary functions applied to Date Time objects in the XPath function library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary XPath Date Time function
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathDateTimeFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Abstract method which derived classes must implement to generate the actual numeric value for the function
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.BaseUnaryXPathDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the Function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathYearFromDateTimeFunction">
            <summary>
            Represents the XPath year-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathYearFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Year from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathYearFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathYearFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathMonthFromDateTimeFunction">
            <summary>
            Represents the XPath month-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMonthFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Month from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMonthFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMonthFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathDayFromDateTimeFunction">
            <summary>
            Represents the XPath day-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDayFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Day from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDayFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathDayFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathHoursFromDateTimeFunction">
            <summary>
            Represents the XPath hours-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathHoursFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Hours from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathHoursFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathHoursFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathMinutesFromDateTimeFunction">
            <summary>
            Represents the XPath minutes-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMinutesFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Minutes from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMinutesFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathMinutesFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathSecondsFromDateTimeFunction">
            <summary>
            Represents the XPath seconds-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSecondsFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Seconds from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSecondsFromDateTimeFunction.NumericValueInternal(System.DateTime)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathSecondsFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction">
            <summary>
            Represents the XPath timezone-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Timezone from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPathTimezoneFromDateTimeFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TriGParserContext">
            <summary>
            Parser Context class for TriG Parsers
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TriGParserContext._nsmapper">
            <summary>
            Namespace Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new TriG Parser Context with default settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new TrigG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TriGParserContext.NamespaceMap">
            <summary>
            Gets the Namespace Mapper being used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TriGParserContext.DefaultGraphExists">
            <summary>
            Gets/Sets whether the Default Graph exists
            </summary>
        </member>
        <member name="T:VDS.RDF.VirtuosoTripleStore">
            <summary>
            Class for representing a Virtuoso Native Quad Store and executing queries against it
            </summary>
            <remarks>
            <para>
            No data is automatically loaded into this class when it is instantiated, it acts as a queryable view onto the given Virtuoso Store specified by the given <see cref="!:VirutosoManager">VirtuosoManager</see>
            </para>
            <para>
            Currently Graphs added/removed from this Class do not affect the Virtuoso Store
            </para>
            <para>
            If you wish to alter the Store you must manipulate the Store directly using the <see cref="T:VDS.RDF.Storage.VirtuosoManager">VirtuosoManager</see> or by issuing SPARQL Update commands using the <see cref="M:VDS.RDF.VirtuosoTripleStore.ExecuteUpdate(System.String)">ExecuteUpdate()</see> method.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.#ctor(VDS.RDF.Storage.VirtuosoManager)">
            <summary>
            Creates a new instance of a Virtuoso Triple Store which uses the given <see cref="T:VDS.RDF.Storage.VirtuosoManager">VirtuosoManager</see> to connect to a Virtuoso Triple Store
            </summary>
            <param name="manager">Manager for the connection to Virtuoso</param>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Virtuoso Triple Store using the given parameters
            </summary>
            <param name="server">Server</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <remarks>Uses the default port of <strong>1111</strong> and assume the Quad Store is in the default database which is <strong>DB</strong></remarks>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            Creates a new Virtuoso Triple Store using the given parameters
            </summary>
            <param name="server">Server</param>
            <param name="port">Port</param>
            <param name="db">Database</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as unparsed String</param>
            <returns>
            A <see cref="!:SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> if the query is a normal Sparql Query or a null if the query is a Sparql Update command.
            </returns>
            <remarks>
            <para>
            This method invokes the <see cref="M:VDS.RDF.Storage.VirtuosoManager.Query(System.String)">Query</see> method of the <see cref="T:VDS.RDF.Storage.VirtuosoManager">VirtuosoManager</see> which executes the Sparql query against the store using SPASQL (Sparql+SQL).
            </para>
            <para>
            You can use this method to issue SPARQL Update commands against the Store if the user account you are using to connect has the relevant privilege <strong>SPARQL_UPDATE</strong> granted to them, for new development we recommend you use the <see cref="M:VDS.RDF.VirtuosoTripleStore.ExecuteUpdate(System.String)">ExecuteUpdate()</see> method instead.
            </para>
            <para>
            <strong>Warning:</strong> In rare cases we have been able to crash Virtuoso by issuing malformed Sparql Update commands to it, this appears to be an issue with Virtuoso.
            </para>
            </remarks>
            <exception cref="!:RdfQueryException">Thrown if the query is malformed or the results cannot be processed</exception>
            <exception cref="!:VirtuosoException">Thrown if accessing Virtuoso fails in some way</exception>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.Dispose">
            <summary>
            Disposes of a Virtuoso Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes a SPARQL Update on the Virtuoso store
            </summary>
            <param name="update">SPARQL Update</param>
            <remarks>
            <para>
            <strong>Warning:</strong> In rare cases we have been able to crash Virtuoso by issuing malformed Sparql Update commands to it, this appears to be an issue with Virtuoso.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a SPARQL Update on the Virtuoso store
            </summary>
            <param name="update">SPARQL Update</param>
            <remarks>
            <para>
            <strong>Warning:</strong> In rare cases we have been able to crash Virtuoso by issuing malformed Sparql Update commands to it, this appears to be an issue with Virtuoso.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.VirtuosoTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a SPARQL Update on the Virtuoso store
            </summary>
            <param name="updates">SPARQL Updates</param>
            <remarks>
            <para>
            <strong>Warning:</strong> In rare cases we have been able to crash Virtuoso by issuing malformed Sparql Update commands to it, this appears to be an issue with Virtuoso.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.GraphVizGenerator">
            <summary>
            A Class which creates GraphViz Graphs entirely dynamically
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizGenerator.#ctor(System.String)">
            <summary>
            Creates a new GraphVizGenerator
            </summary>
            <param name="format">Format for the Output</param>
            <remarks>Only use this form if you're certain that dot.exe is in your PATH otherwise the code will throw an error</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizGenerator.#ctor(System.String,System.String)">
            <summary>
            Creates a new GraphVizGenerator
            </summary>
            <param name="format">Format for the Output</param>
            <param name="gvdir">Directory in which GraphViz is installed</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizGenerator.Generate(VDS.RDF.IGraph,System.String,System.Boolean)">
            <summary>
            Generates GraphViz Output for the given Graph
            </summary>
            <param name="g">Graph to generated GraphViz Output for</param>
            <param name="filename">File you wish to save the Output to</param>
            <param name="open">Whether you want to open the Output in the default application (according to OS settings) for the filetype after it is Created</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizGenerator.LocateGraphViz">
            <summary>
            Internal Helper Method for locating the GraphViz Directory using the PATH Environment Variable
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.GraphVizGenerator.Format">
            <summary>
            Gets/Sets the Format for the Output
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.CommonBlankNodeSelector">
            <summary>
            A Selector which finds all Triples containing the given Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.CommonBlankNodeSelector.#ctor(VDS.RDF.BlankNode)">
            <summary>
            Creates a new Common Blank Node Selector based on the given Blank Node
            </summary>
            <param name="blank">Blank Node to Select upon</param>
        </member>
        <member name="M:VDS.RDF.Query.CommonBlankNodeSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts all Triples which have the Blank Node as their Subject or Object
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.NonBlankSelector">
            <summary>
            A Selector which finds all Triples not involving a Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.NonBlankSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts all Triples which don't involve a Blank Node
            </summary>
            <param name="obj">Triple to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.NonBlankNodeSelector">
            <summary>
            A Selector which finds all Nodes which aren't Blank
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.NonBlankNodeSelector.Accepts(VDS.RDF.INode)">
            <summary>
            Accepts all Nodes which aren't a Blank Node
            </summary>
            <param name="obj">Node to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasBlankSelector">
            <summary>
            A Selector which finds all Triples involving a Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasBlankSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples which have at least one Blank Node in them
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResult">
            <summary>
            Class for representing a Row of a Sparql Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.#ctor">
            <summary>
            Creates a new empty SPARQLResult which can only be filled by methods internal to the dotNetRDF Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.#ctor(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Creates a new SPARQL Result from the given Set
            </summary>
            <param name="s">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.Value(System.String)">
            <summary>
            Gets the Value that is bound to the given Variable
            </summary>
            <param name="variable">Variable whose Value you wish to retrieve</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if there is nothing bound to the given Variable Name for this Result</exception>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.SetValue(System.String,VDS.RDF.INode)">
            <summary>
            Internal Only Method for setting the Value of a Result
            </summary>
            <param name="variable">Variable Name</param>
            <param name="value">Value bound to the Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.HasValue(System.String)">
            <summary>
            Checks whether a value is bound to the given Variable for this result
            </summary>
            <param name="variable">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.ToString">
            <summary>
            Displays the Result as a commas separated string of pairs of the form ?var = value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.Equals(System.Object)">
            <summary>
            Override of the Equals method for Results
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <remarks>Used implicitly in applying Distinct and Reduced modifiers to the Result Set</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.GetHashCode">
            <summary>
            Override of the GetHashCode method for Results
            </summary>
            <returns></returns>
            <remarks>Used implicitly in applying Distinct and Reduced modifiers to the Result Set</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.GetEnumerator">
            <summary>
            Enumerates the Bindings of Variable Names to Values in this Result
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the Bindings of Variable Names to Values in this Result
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Item(System.String)">
            <summary>
            Gets the Value that is bound to the given Variable
            </summary>
            <param name="variable">Variable whose Value you wish to retrieve</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if there is nothing bound to the given Variable Name for this Result</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Item(System.Int32)">
            <summary>
            Gets the Value that is bound at the given Index
            </summary>
            <param name="index">Index whose Value you wish to retrieve</param>
            <returns></returns>
            <remarks>
            The order of variables in a Result is not guaranteed in any way
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if there is nothing bound at the given Index</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Count">
            <summary>
            Gets the number of Variables for which this Result contains Bindings
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Variables">
            <summary>
            Gets the set of Variables that are bound in this Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.IsGroundResult">
            <summary>
            Gets whether a Result is a Ground Result
            </summary>
            <remarks>
            A <strong>Ground Result</strong> is a result which is considered to be a fixed fact.  In practise this means it contains no Blank Nodes
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.VirtuosoReader">
            <summary>
            Class for reading RDF Graphs from a Virtuoso Native Quad Store into arbitrary Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.VirtuosoReader.#ctor(VDS.RDF.Storage.VirtuosoManager)">
            <summary>
            Creates a new instance of the Virtuoso Reader which connects to a Virtuoso Native Quad Store using the given Manager
            </summary>
            <param name="manager">Manager for the connection to Virtuoso</param>
        </member>
        <member name="M:VDS.RDF.Parsing.VirtuosoReader.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Virtuoso Reader which connects to a Virtuoso Native Quad Store using the given Manager
            </summary>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that Virtuoso is installed on the local host using the default port 1111</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.VirtuosoReader.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the Virtuoso Reader which connects to a Virtuoso Native Quad Store using the given Manager
            </summary>
            <param name="dbserver">Database Server</param>
            <param name="dbport">Database Port</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
        </member>
        <member name="M:VDS.RDF.Parsing.VirtuosoReader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Native Quad Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Parsing.VirtuosoReader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Native Quad Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="T:VDS.RDF.Parsing.TalisReader">
            <summary>
            Class for reading RDF Graphs describing a given Resource from a Talis Store into arbitrary Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.#ctor(VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Connector
            </summary>
            <param name="connector">Connector</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Store settings
            </summary>
            <param name="storeName">Store Name</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.#ctor(System.String)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Store settings
            </summary>
            <param name="storeName">Store Name</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads the description of a given Resource from the Talis store into the given Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resourceUri">Resource Uri</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads the description of a given Resource from the Talis store into the given Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resourceUri">Resource Uri</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.Load(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Loads the description of a given Resource from a Private Graph in the Talis store into the given Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="privateGraphID">Private Graph ID</param>
            <param name="resourceUri">Resource Uri</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TalisReader.Load(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Loads the description of a given Resource from a Private Graph in the Talis store into the given Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="privateGraphID">Private Graph ID</param>
            <param name="resourceUri">Resource Uri</param>
        </member>
        <member name="T:VDS.RDF.Parsing.StringParser">
            <summary>
            Static Helper Class which allows raw strings of RDF to be parsed directly
            </summary>
            <remarks>
            The API structure for dotNetRDF means that our <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> classes which are our Parsers only have to support parsing from a file or a stream.  For most applications this is fine but there may be occassions when you wish to parse a small fragment of RDF and you don't want to have to put it into a file before you can parse it.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.Parse(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Parses a raw RDF String using the given <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see>
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Raw RDF String</param>
            <param name="reader">Parser to use to read the data</param>
            <remarks>Use this when you have a raw RDF string and you know the syntax the RDF is in</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.Parse(VDS.RDF.IGraph,System.String)">
            <summary>
            Parses a raw RDF String (attempts to auto-detect the format)
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Raw RDF String</param>
            <remarks>
            <p>
            Auto-detection is based on testing the string to see if it contains certain keyword constructs which might indicate a particular syntax has been used.  This detection may not always be accurate and it may choose a parser which is less expressive than the actual syntax e.g. <see cref="T:VDS.RDF.Parsing.TurtleParser">TurtleParser</see> instead of <see cref="T:VDS.RDF.Parsing.Notation3Parser">Notation3Parser</see> as it tends to guess downwards.  
            </p>
            <p>
            For example if you parsed a Notation 3 string that contained Graph Literals but didn't use any of the Notation 3 specific directives like @keywords it would be assumed to be Turtle but then would fail to parse
            </p>
            <p>
            The auto-detection rules used are as follows:
            </p>
            <ol>
            <li>If it contains &lt;?xml and &lt;rdf:RDF then it's most likely RDF/XML</li>
            <li>If it contains &lt;html then it's most likely HTML with possibly RDFa embedded</li>
            <li>
            If it contains @prefix or @base then its Turtle/Notation 3
                <ol>
                <li>If it contains @keywords, @forall or @forsome then it's Notation 3</li>
                <li>Otherwise it's Turtle</li>
                </ol>
            </li>
            <li>If it contains all of a set of terms and symbols that occur in RDF/Json then it's most likely RDF/Json.  These terms are "value","type",{,},[ and ]</li>
            <li>Otherwise try it as NTriples, NTriples has no real distinctive syntax so hard to test if it's NTriples</li>
            </ol>
            </remarks>
        </member>
        <member name="T:VDS.RDF.RdfException">
            <summary>
            Class for representing errors with RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String)">
            <summary>
            Creates a new RDF Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Configuration.DotNetRdfConfigurationException">
            <summary>
            Class for representing errors with dotNetRDF Configuration
            </summary>
            <remarks>
            <para>
            Configuration exceptions are thrown when the user tries to load objects using the <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> and their is insufficient/invalid information to load the desired object
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Ontology.RdfOntologyException">
            <summary>
            Class for representing errors with Ontologies
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String)">
            <summary>
            Creates a new RDF Ontology Exception with the given message
            </summary>
            <param name="errorMsg">Error message</param>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Ontology Exception with the given message and inner exception
            </summary>
            <param name="errorMsg">Error message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfParseException">
            <summary>
            Class for representing errors in parsing RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String)">
            <summary>
            Creates a new RDF Parse Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfThreadedParsingException">
            <summary>
            Class of exceptions that may occur when doing multi-threaded output of RDF
            </summary>
            <remarks>
            <para>
            Used when a process may result in multiple errors from different threads
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfThreadedParsingException.#ctor(System.String)">
            <summary>
            Creates a new Threaded RDF Parsing Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfThreadedParsingException.AddException(System.Exception)">
            <summary>
            Adds an Exception to the list of Inner Exceptions
            </summary>
            <param name="ex">Exception</param>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfThreadedParsingException.InnerExceptions">
            <summary>
            Gets the enumeration of Exceptions
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfParserSelectionException">
            <summary>
            Class for representing errors in selecting an appropriate parser to parse RDF with
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParserSelectionException.#ctor(System.String)">
            <summary>
            Creates a new RDF Parser Selection Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParserSelectionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Parser Selection Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryException">
            <summary>
            Class for representing errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTimeoutException">
            <summary>
            Class for representing Timeout errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Timeout Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfReasoningException">
            <summary>
            Class for representing Exceptions occurring in RDF reasoners
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTerminatedException">
            <summary>
            Class for representing Termination errors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTerminatedException.#ctor">
            <summary>
            Creates a new RDF Query Termination Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryPathFoundException">
            <summary>
            Class for representing Path Found terminations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryPathFoundException.#ctor">
            <summary>
            Creates a new Path Found exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.RdfStorageException">
            <summary>
            Class for representing errors that occur in RDF Storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.RdfStorageException.#ctor(System.String)">
            <summary>
            Creates a new RDF Storage Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Storage.RdfStorageException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Storage Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception which caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Storage.TalisException">
            <summary>
            Class of exceptions that may occur when interacting with the Talis Platform
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.TalisException.#ctor(System.String)">
            <summary>
            Creates a new Talis Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Talis Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateException">
            <summary>
            Class of exceptions that may occur when performing SPARQL Updates
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String)">
            <summary>
            Creates a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String,System.Exception)">
            <summary>
            Createa a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolException">
            <summary>
            Class of exceptions that may occur when using the SPARQL Uniform HTTP Protocol for Graph Management
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Uniform HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new SPARQL Uniform HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException">
            <summary>
            Exception that occurs when a Protocol Processor cannot resolve the URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException.#ctor">
            <summary>
            Creates a new Protocol URI Resolution Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException">
            <summary>
            Exception that occurs when a Protocol Processor is provided with a invalid URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException.#ctor">
            <summary>
            Creates a new Protocol Invalid URI Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfOutputException">
            <summary>
            Class of exceptions that may occur when outputting RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfThreadedOutputException">
            <summary>
            Class of exceptions that may occur when doing multi-threaded output of RDF
            </summary>
            <remarks>
            <para>
            Used when a process may result in multiple errors from different threads
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.#ctor(System.String)">
            <summary>
            Creates a new Threaded RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.AddException(System.Exception)">
            <summary>
            Adds an Exception to the list of Inner Exceptions
            </summary>
            <param name="ex">Exception</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfThreadedOutputException.InnerExceptions">
            <summary>
            Gets the enumeration of Exceptions
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfWriterSelectionException">
            <summary>
            Class for errors in selecting an appropriate Writer to output RDF with
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Extensions">
            <summary>
            Provides useful Extension Methods for use elsewhere in the Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Extensions.AsEnumerable``1(``0)">
            <summary>
            Takes a single item and generates an IEnumerable containing only it
            </summary>
            <typeparam name="T">Type of the enumerable</typeparam>
            <param name="item">Item to wrap in an IEnumerable</param>
            <returns></returns>
            <remarks>
            This method taken from Stack Overflow - see <a href="http://stackoverflow.com/questions/1577822/passing-a-single-item-as-ienumerablet">here</a>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.Subset(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that are accepted by a given Selector
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="selector">Selector to apply</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithSubject(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Subject
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="subject">Subject to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithPredicate(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Predicate
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="predicate">Predicate to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithObject(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Object
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="obj">Object to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetEnhancedHashCode(System.Uri)">
            <summary>
            Gets an Enhanced Hash Code for a Uri
            </summary>
            <param name="u">Uri to get Hash Code for</param>
            <returns></returns>
            <remarks>
            The .Net <see cref="T:System.Uri">Uri</see> class Hash Code ignores the Fragment ID when computing the Hash Code which means that URIs with the same basic URI but different Fragment IDs have identical Hash Codes.  This is perfectly acceptable and sensible behaviour for normal URI usage since Fragment IDs are only relevant to the Client and not the Server.  <strong>But</strong> in the case of URIs in RDF the Fragment ID is significant and so we need in some circumstances to compute a Hash Code which includes this information.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.GetSha256Hash(System.Uri)">
            <summary>
            Gets an SHA256 Hash for a URI
            </summary>
            <param name="u">URI to get Hash Code for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.Assert(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Asserts a new Triple in the Graph
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can assert a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.Retract(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="g">Graph to retract from</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can retract a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.MapTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode})">
            <summary>
            Copies a Triple from one Graph mapping Nodes as appropriate
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">TargetGraph</param>
            <param name="mapping">Mapping of Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ExecuteQuery(VDS.RDF.IGraph,System.String)">
            <summary>
            Executes a SPARQL Query on a Graph
            </summary>
            <param name="g">Graph to query</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on a Graph
            </summary>
            <param name="g">Graph to query</param>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeString(System.Object)">
            <summary>
            Gets either the String representation of the Object or the Empty String if the object is null
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.LiteralExtensions">
            <summary>
            Provides extension methods for converting primitive types in appropriately typed Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Boolean,VDS.RDF.IGraph)">
            <summary>
            Creates a new Boolean typed literal
            </summary>
            <param name="b">Boolean</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTime,VDS.RDF.IGraph)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph/Date Time argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.TimeSpan,VDS.RDF.IGraph)">
            <summary>
            Creates a new duration typed literal
            </summary>
            <param name="t">Time Span</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Decimal,VDS.RDF.IGraph)">
            <summary>
            Creates a new Decimal typed literal
            </summary>
            <param name="d">Decimal</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Double,VDS.RDF.IGraph)">
            <summary>
            Creates a new Double typed literal
            </summary>
            <param name="d">Double</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Single,VDS.RDF.IGraph)">
            <summary>
            Creates a new Float typed literal
            </summary>
            <param name="f">Float</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int16,VDS.RDF.IGraph)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int32,VDS.RDF.IGraph)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int64,VDS.RDF.IGraph)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="l">Integer</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.String,VDS.RDF.IGraph)">
            <summary>
            Creates a new String typed literal
            </summary>
            <param name="s">String</param>
            <param name="g">Graph to create in</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph/String argument is null</exception>
        </member>
        <member name="T:VDS.RDF.Writing.NQuadsWriter">
            <summary>
            Class for serializing a Triple Store in the NQuads (NTriples plus context) syntax
            </summary>
            <remarks>
            <para>
            For efficiency the TriG Writer splits it's writing over several threads (currently 4), these threads share a reference to a Context object which gives Global writing context eg. the target <see cref="T:System.IO.TextWriter">TextWriter</see> being written to.  Each thread generates temporary local writing contexts as it goes along, each of these is scoped to writing a specific Graph.  Graphs are written to a <see cref="T:VDS.RDF.Writing.StringWriter">StringWriter</see> so the output for each Graph is built completely and then written in one go to the <see cref="T:System.IO.TextWriter">TextWriter</see> specified as the target of the writing in the global context.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves a Store in NQuads format
            </summary>
            <param name="store">Store to save</param>
            <param name="parameters">Parameters indicating a Stream to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.TripleToNQuads(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Converts a Triple into relevant NQuads Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.NodeToNTriples(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Converts a Node into relevant NTriples Syntax
            </summary>
            <param name="n">Node to convert</param>
            <param name="context">Writer Context</param>
            <param name="segment">Triple Segment being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.NQuadsWriter.PrettyPrintMode">
            <summary>
            Controls whether Pretty Printing is used
            </summary>
            <remarks>
            For NQuads this simply means that Graphs in the output are separated with Whitespace and comments used before each Graph
            </remarks>
        </member>
        <member name="E:VDS.RDF.Writing.NQuadsWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NQuadsWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Web.DiskResourceHandler">
            <summary>
            A Disk Resource Handler translates a Uri it is invoked with into a filesystem path and attempts to return the file at that location
            </summary>
            <remarks>
            <para>
            This Handler supports only one handler of this type being registered (multiple Handlers can be registered but their configuration will be shared if they get it from the same Web.config file).  The Handler is designed to be configured with a wildcard path so any path using the Base Uri of the Handler will be translated into a filesystem path and the requested resource (if it exists) returned.
            </para>
            <para>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the type of the handler like so:
            <code>&lt;add key="VDS.RDF.Web.DiskResourceHandler" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </para>
            <para>
            This Handler supports the following Configuration Variables
            </para>
            <ul>
            <li><strong>BaseUri</strong> (<em>Required</em>) - Sets the Base Uri at which your Handler is installed, used to obtain the portion of the Uri that will be translated into a filesystem path for retrieving the resource</li>
            <li><strong>DataFolder</strong> (<em>Required</em>) - Sets the root Data Folder into which URIs will be mapped as filesystem paths</li>
            <li><strong>DataExtension</strong> (<em>Optional</em>) - Sets the extension of the data files contained in the data folder.  Defaults to <strong>.rdf</strong></li>
            <li><strong>DataMIMEType</strong> (<em>Optional</em>) - Sets the MIME Type of your data files, if you set a <strong>DataExtension</strong> the MIME Type will be determined from the extension unless you set it explicitly.  Defaults to <strong>application/rdf+xml</strong></li>
            <li><strong>DefaultFile</strong> (<em>Optional</em>) - Sets the Default File that will be retrieved if a client accesses the handler using the Base Uri.  Defaults to no default file.</li>
            <li><strong>AllowFormatTranslation</strong> (<em>Optional</em>) - Sets whether the Handler can automatically translate your data files into formats accepted by the Client if the client does not accept the MIME Type of your data.  Defaults to <strong>False</strong></li>
            </ul>
            <para>
            The following is an example of how this configuration can be used.  First we have the Web.config settings added to the &lt;appSettings&gt; section:
            </para>
            <code>
            &lt;appSettings&gt;
                &lt;add key="VDS.RDF.Web.DiskResourceHandler" value="Disk"/&gt;
                &lt;add key="DiskBaseURI" value="http://example.org/resource/"/&gt;
                &lt;add key="DiskDataFolder" value="~/App_Data"/&gt;
                &lt;add key="DiskDataExtension" value=".ttl"/&gt;
                &lt;add key="DiskDefaultFile" value="default"/&gt;
                &lt;add key="DiskAllowFormatTranslation" value="true"/&gt;
            &lt;/appSettings&gt;
            </code>
            <para>
            Then in the &lt;handlers&gt; section of &lt;system.webServer&gt; we have to register our handler (this assumes you're using IIS 7):
            </para>
            <code>
            &lt;handlers&gt;
                &lt;remove name="ResourceHandler" /&gt;
                &lt;add name="ResourceHandler" verb="*" path="resource/*" type="VDS.RDF.Web.DiskResourceHandler" /&gt;
            &lt;/handlers&gt;
            </code>
            <para>
            <strong>Note for IIS 6 Users:</strong> Simply add the &lt;add&gt; tag to your &lt;httpHandlers&gt; section of &lt;system.web&gt; - just remember to remove the <em>name</em> attribute
            </para>
            <para>
            Now you've done this you'll need to place some data files under the <strong>App_Data</strong> folder of your application with the Turtle extension <em>.ttl</em>
            <br />
            Once this is done you can start accessing resources at the Uri, the following table gives you an idea of the mapping from URIs to Files (the example assumes the application is installed in the filesystem at <strong>D:\example.org\www\</strong>
            </para>
            <table class="dtTable" cellspacing="0">
            <tr>
                <th>Uri</th>
                <th>File</th>
            </tr>
            <tr>
                <td>http://example.org/resource/</td>
                <td>D:\example.org\www\App_Data\default.ttl</td>
            </tr>
            <tr>
                <td>http://example.org/resource/something</td>
                <td>D:\example.org\www\App_Data\something.ttl</td>
            </tr>
            <tr>
                <td>http://example.org/resource/thing</td>
                <td>D:\example.org\www\App_Data\thing.ttl</td>
            </tr>
            <tr>
                <td>http://example.org/resource/subdirectory/thing</td>
                <td>D:\example.org\www\App_Data\subdirectory\thing.ttl</td>
            </tr>
            <tr>
                <td>http://example.org/resource/a/b/c/thing</td>
                <td>D:\example.org\www\App_Data\a\b\c\thing.ttl</td>
            </tr>
            </table>
            <para>
            If the Uri maps to a file that doesn't exist then the Handler will return a HTTP 404 error to the client.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.DiskResourceHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes a request for a resource by mapping the Uri to a filesystem path and returning the RDF document there
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="M:VDS.RDF.Web.DiskResourceHandler.LoadConfigInternal(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Loads the Configuration for the Handler
            </summary>
            <param name="context">Context of the HTTP Web Request</param>
            <param name="cacheKey">Cache Key</param>
            <param name="prefix">Config Variable Prefix</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlRemoteUpdateEndpoint">
            <summary>
            A Class for connecting to a remote SPARQL Update endpoint and executing Updates against it
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseEndpoint">
            <summary>
            Abstract Base class for HTTP endpoints
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.#ctor">
            <summary>
            Creates a new Base Endpoint
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new Base Endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetCredentials(System.String,System.String)">
            <summary>
            Sets the HTTP Digest authentication credentials to be used
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetCredentials(System.String,System.String,System.String)">
            <summary>
            Sets the HTTP Digest authentication credentials to be used
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="domain">Domain</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.ClearCredentials">
            <summary>
            Clears any in-use credentials so subsequent requests will not use HTTP authentication
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetProxy(System.String)">
            <summary>
            Sets a Proxy Server to be used
            </summary>
            <param name="address">Proxy Address</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetProxy(System.Uri)">
            <summary>
            Sets a Proxy Server to be used
            </summary>
            <param name="address">Proxy Address</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.ClearProxy">
            <summary>
            Clears any in-use credentials so subsequent requests will not use a proxy server
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetProxyCredentials(System.String,System.String)">
            <summary>
            Sets Credentials to be used for Proxy Server
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetProxyCredentials(System.String,System.String,System.String)">
            <summary>
            Sets Credentials to be used for Proxy Server
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="domain">Domain</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.ClearProxyCredentials">
            <summary>
            Clears the in-use proxy credentials so subsequent requests still use the proxy server but without credentials
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the endpoints Credential and Proxy information
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Uri">
            <summary>
            Gets the Endpoints URI
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.HttpMode">
            <summary>
            Gets/Sets the HTTP Mode used for requests
            </summary>
            <remarks>
            <para>
            Only GET and POST are permitted - implementations may override this property if they wish to support more methods
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Timeout">
            <summary>
            Gets/Sets the HTTP Timeouts used for Queries
            </summary>
            <remarks>
            Defaults to 30 Seconds
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.UseCredentialsForProxy">
            <summary>
            Controls whether the Credentials set with the <see cref="M:VDS.RDF.BaseEndpoint.SetCredentials(System.String,System.String)">SetCredentials()</see> method or the <see cref="P:VDS.RDF.BaseEndpoint.Credentials">Credentials</see>are also used for a Proxy (if used)
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Credentials">
            <summary>
            Gets/Sets the HTTP authentication credentials to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Proxy">
            <summary>
            Gets/Sets a Proxy Server to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.ProxyCredentials">
            <summary>
            Gets/Sets Credentials to be used for Proxy Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Update Endpoint for the given URI
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.Update(System.String)">
            <summary>
            Makes an update request to the remote endpoint
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DropCommand">
            <summary>
            Represents a SPARQL Update DROP command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(System.Uri,System.Boolean)">
            <summary>
            Creates a new DROP command
            </summary>
            <param name="graphUri">URI ofthe Graph to DROP</param>
            <param name="silent">Whether the DROP should be done silently</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(System.Uri)">
            <summary>
            Creates a new DROP command
            </summary>
            <param name="graphUri">URI of the Graph to DROP</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.ToString">
            <summary>
            Gets the String representation of the command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be dropped
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.Silent">
            <summary>
            Gets whether the Drop should be done silently
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SparqlConnectorLoadMethod">
            <summary>
            Controls how the <see cref="T:VDS.RDF.Storage.SparqlConnector">SparqlConnector</see> loads Graphs from the Endpoint
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SparqlConnectorLoadMethod.Describe">
            <summary>
            Graphs are loaded by issuing a DESCRIBE query using the Graph URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.SparqlConnectorLoadMethod.Construct">
            <summary>
            Graphs are loaded by issuing a CONSTRUCT FROM query using the Graph URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SparqlConnector">
            <summary>
            Class for connecting to any SPARQL Endpoint as a read-only Store
            </summary>
            <remarks>
            This class is effectively a read-only wrapper around a <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> using it with it's default settings, if you only need to query an endpoint and require more control over the settings used to access the endpoint you should use that class directly or use the constructors which allow you to provide your own pre-configure <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> instance
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.#ctor(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Creates a new SPARQL Connector which uses the given SPARQL Endpoint
            </summary>
            <param name="endpoint">Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.#ctor(VDS.RDF.Query.SparqlRemoteEndpoint,VDS.RDF.Storage.SparqlConnectorLoadMethod)">
            <summary>
            Creates a new SPARQL Connector which uses the given SPARQL Endpoint
            </summary>
            <param name="endpoint">Endpoint</param>
            <param name="mode">Load Method to use</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Connector which uses the given SPARQL Endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.#ctor(System.Uri,VDS.RDF.Storage.SparqlConnectorLoadMethod)">
            <summary>
            Creates a new SPARQL Connector which uses the given SPARQL Endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
            <param name="mode">Load Method to use</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.Query(System.String)">
            <summary>
            Makes a Query against the SPARQL Endpoint
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the SPARQL Endpoint
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the SPARQL Endpoint
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="g">Graph to save</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Always thrown since this Manager provides a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.Dispose">
            <summary>
            Disposes of the Connection
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.SkipLocalParsing">
            <summary>
            Controls whether the Query will be parsed locally to accurately determine its Query Type for processing the response
            </summary>
            <remarks>
            If the endpoint you are connecting to provides extensions to SPARQL syntax which are not permitted by the libraries parser then you may wish to enable this option as otherwise you will not be able to execute such queries
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.Timeout">
            <summary>
            Gets/Sets the HTTP Timeout used for communicating with the SPARQL Endpoint
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.Endpoint">
            <summary>
            Gets the underlying <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> which this class is a wrapper around
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.UpdateSupported">
            <summary>
            Returns that Updates are not supported since this connection is read-only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlConnector.IsReadOnly">
            <summary>
            Returns that the Connection is read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlParameterizedString">
            <summary>
            A SPARQL Parameterized String is a String that can contain parameters in the same fashion as a SQL command string
            </summary>
            <remarks>
            <para>
            This is intended for use in applications which may want to dynamically build SPARQL queries where user input may comprise individual values in the triples patterns and the applications want to avoid SPARQL/SPARUL injection attacks which change the meaning of the query (or in the case of SPARUL change the actual data)
            </para>
            <para>
            It works broadly in the same way as a SqlCommand would in that you specify a string with paramters specified in the form <strong>@name</strong> and then use various set methods to set the actual values that should be used.  The values are only substituted for parameters when you actually call the <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ToString">ToString()</see> method to get the final string representation of the command. E.g.
            </para>
            <code>
            SparqlParameterizedString queryString = @"SELECT * WHERE
            {
                ?s a @type .
            }";
            queryString.SetUri("type", new Uri("http://example.org/myType"));
            Console.WriteLine(queryString.ToString());
            </code>
            <para>
            Would result in the following being printed to the Console:
            </para>
            <code>
            SELECT * WHERE
            {
                ?s a &lt;http://example.org/myType&gt;
            }
            </code>
            <para>
            Calling a Set method to set a parameter that has already been set changes that value and the new value will be used next time you call <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ToString">ToString()</see> - this may be useful if you plan to execute a series of queries using a series of values since you need not instantiate a completely new parameterized string each time
            </para>
            <para>
            This class was added to a library based on a suggestion by Alexander Sidorov and ideas from slides from <a href="http://www.slideshare.net/Morelab/sparqlrdqlsparul-injection">Slideshare</a> by Almedia et al
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.#ctor">
            <summary>
            Creates a new empty parameterized String
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.#ctor(System.String)">
            <summary>
            Creates a new parameterized String
            </summary>
            <param name="query">Query Text</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetParameter(System.String,VDS.RDF.INode)">
            <summary>
            Sets the Value of a Parameter 
            </summary>
            <param name="name">Parameter Name</param>
            <param name="value">Value</param>
            <remarks>
            Can be used in derived classes to set the value of parameters if the derived class defines additional methods for adding values for parameters
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int32)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int64)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int16)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Decimal)">
            <summary>
            Sets the Parameter to a Decimal Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Single)">
            <summary>
            Sets the Parameter to a Float Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Double)">
            <summary>
            Sets the Parameter to a Double Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.DateTime)">
            <summary>
            Sets the Parameter to a Date Time Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.TimeSpan)">
            <summary>
            Sets the Parameter to a Duration Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Boolean)">
            <summary>
            Sets the Parameter to a Boolean Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String)">
            <summary>
            Sets the Parameter to an Untyped Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String,System.Uri)">
            <summary>
            Sets the Parameter to a Typed Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String,System.String)">
            <summary>
            Sets the Parameter to a Literal with a Language Specifier
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="lang">Language Specifier</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetUri(System.String,System.Uri)">
            <summary>
            Sets the Parameter to a URI
            </summary>
            <param name="name">Parameter</param>
            <param name="value">URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetBlankNode(System.String,System.String)">
            <summary>
            Sets the Parameter to be a Blank Node with the given ID
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Node ID</param>
            <remarks>
            Only guarantees that the Blank Node ID will not clash with any other Blank Nodes added by other calls to this method or it's overload which generates anonymous Blank Nodes.  If the base query text into which you are inserting parameters contains Blank Nodes then the IDs generated here may clash with those IDs.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetBlankNode(System.String)">
            <summary>
            Sets the Parameter to be a new anonymous Blank Node
            </summary>
            <param name="name">Parameter</param>
            <remarks>
            Only guarantees that the Blank Node ID will not clash with any other Blank Nodes added by other calls to this method or it's overload which takes an explicit Node ID.  If the base query text into which you are inserting parameters contains Blank Nodes then the IDs generated here may clash with those IDs.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ToString">
            <summary>
            Returns the actual Query String with parameter values inserted
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.QueryText">
            <summary>
            Gets/Sets the paramterized Query Text
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.PropertyPathPattern">
            <summary>
            Class for representing property patterns in SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem,System.String)">
            <summary>
            Creates a new Property Path Pattern
            </summary>
            <param name="subj">Subject</param>
            <param name="path">Property Path</param>
            <param name="obj">Object</param>
            <param name="lengthVar">Variable to bind the path length to</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Property Path Pattern
            </summary>
            <param name="subj">Subject</param>
            <param name="path">Property Path</param>
            <param name="obj">Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a property path pattern
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.IsAcceptAll">
            <summary>
            Gets whether the Pattern accepts all Triple Patterns
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.InversePath">
            <summary>
            Represents an Inverse Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Inverse Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Path transform to an Algebra expression
            </summary>
            <param name="context">Transform Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.InversePath.IsSimple">
            <summary>
            Gets whether the path is simple
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Service">
            <summary>
            Represents a Service Clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new Service clause with the given Endpoint Specifier and Graph Pattern
            </summary>
            <param name="endpointSpecifier">Endpoint Specifier</param>
            <param name="pattern">Graph Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Service Clause by generating instance(s) of <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> as required and issuing the query to the remote endpoint(s)
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.RdfXmlParserContext">
            <summary>
            Parser Context for RDF/XML Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IGraph,System.Xml.XmlDocument)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph</param>
            <param name="document">XML Document</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IGraph,System.Xml.XmlDocument,System.Boolean)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph</param>
            <param name="document">XML Document</param>
            <param name="traceParsing">Whether to Trace Parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IGraph,System.IO.Stream)">
            <summary>
            Creates a new Parser Context which uses Streaming parsing
            </summary>
            <param name="g">Graph</param>
            <param name="stream">Stream</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.Events">
            <summary>
            Gets the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.IDs">
            <summary>
            Gets the Mapping of in-use IDs
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ConfigurationSerializationContext">
            <summary>
            Context Class for writing serializing Configuration information
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationSerializationContext._g">
            <summary>
            Configuration Graph being written to
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor">
            <summary>
            Creates a new Serialization Context
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Serialization Context
            </summary>
            <param name="g">Base Configuration Graph</param>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.Graph">
            <summary>
            Gets the Graph to which Configuration information should be written
            </summary>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.NextSubject">
            <summary>
            Gets/Sets the next subject to be used
            </summary>
            <remarks>
            <para>
            Always returns a Blank Node if none is currently explicitly specified
            </para>
            <para>
            Used to link objects together when you want some subsidiary object to serialize it's configuration and link that to the configuration you are currently serializing
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Tools">
            <summary>
            Tools class which contains a number of utility methods which are declared as static methods
            </summary>
        </member>
        <member name="M:VDS.RDF.Tools.StreamCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies Byte by Byte from one Stream to another
            </summary>
            <param name="input">Input Stream</param>
            <param name="output">Output Stream</param>
        </member>
        <member name="M:VDS.RDF.Tools.StreamCopyLocal(System.IO.Stream)">
            <summary>
            Copies an Input Stream into a local Memory Stream and then seeks it to the start before returning it
            </summary>
            <param name="input">Input Stream</param>
            <returns>Memory Stream with a local copy of the Input Stream seeked to the origin and ready to read from</returns>
        </member>
        <member name="M:VDS.RDF.Tools.IsValidBaseUri(System.Uri)">
            <summary>
            Checks whether a Uri is valid as a Base Uri for resolving Relative URIs against
            </summary>
            <param name="baseUri">Base Uri to test</param>
            <returns>True if the Base Uri can be used to resolve Relative URIs against</returns>
            <remarks>A Base Uri is valid if it is an absolute Uri and not using the mailto: scheme</remarks>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.String,System.String)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">RDF Parse Exception if the Uri cannot be resolved for a know reason</exception>
            <exception cref="T:System.UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.Uri,System.Uri)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="T:System.UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
            <remarks>We recommend that you don't use this method directly but invoke it via the ResolveUri function, this ensures that certain classes of Uri resolve correctly</remarks>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveQName(System.String,VDS.RDF.NamespaceMapper,System.Uri)">
            <summary>
            Resolves a QName into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="qname">QName to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUriOrQName(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.NamespaceMapper,System.Uri)">
            <summary>
            Resolves a QName/Uri into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="t">QName/Uri to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Node being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Warning:</strong> Copying Blank Nodes may lead to unforseen circumstances since no remapping of IDs between Graphs is done
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Nodes being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CombineHashCodes(System.Object,System.Object)">
            <summary>
            Does a quick and simple combination of the Hash Codes of two Objects
            </summary>
            <param name="x">First Object</param>
            <param name="y">Second Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugRequest(System.Net.HttpWebRequest)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Request
            </summary>
            <param name="httpRequest">HTTP Web Request</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugResponse(System.Net.HttpWebResponse)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Response
            </summary>
            <param name="httpResponse">HTTP Web Response</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="T:VDS.RDF.Writing.TalisWriter">
            <summary>
            Class for writing RDF Graphs to a Talis Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TalisWriter.#ctor(VDS.RDF.Storage.TalisPlatformConnector)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Connector
            </summary>
            <param name="connector">Connector</param>
        </member>
        <member name="M:VDS.RDF.Writing.TalisWriter.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Store settings
            </summary>
            <param name="storeName">Store Name</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Writing.TalisWriter.#ctor(System.String)">
            <summary>
            Creates a new Talis Reader that connects to a Store using the given Store settings
            </summary>
            <param name="storeName">Store Name</param>
            <remarks>Generally authentication is required for adding data to a Talis store but some stores may be world writable so this constructor is still provided</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.TalisWriter.Save(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Metabox of the Talis Store
            </summary>
            <param name="g">Graph to save</param>
        </member>
        <member name="M:VDS.RDF.Writing.TalisWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to a Private Graph in the Talis Store
            </summary>
            <param name="g">Graph to save</param>
            <param name="privateGraphID">Private Graph ID</param>
        </member>
        <member name="T:VDS.RDF.Query.SparqlSpecsHelper">
            <summary>
            Class containing Helper information and methods pertaining to the Sparql Query Language for RDF
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlNamespace">
            <summary>
            Namespace Uri for SPARQL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlRdfResultsNamespace">
            <summary>
            Namespace Uri for the RDF serialization of a SPARQL Result Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordPrefix">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSelect">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordConstruct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDescribe">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAsk">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOrder">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOrderBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLimit">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOffset">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDistinct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordReduced">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFrom">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFromNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordWhere">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGraph">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOptional">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUnion">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFilter">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStr">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLangMatches">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDataType">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBound">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSameTerm">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsLiteral">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsBlank">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordRegex">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordTrue">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFalse">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAsc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDesc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCount">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSum">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAvg">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroupConcat">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSample">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMedian">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMode">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAs">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroupBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroup">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordHaving">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNot">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNotExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUnsaid">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLet">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSeparator">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLength">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrDt">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNotIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCoalesce">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIf">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordInsert">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDelete">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordClear">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLoad">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordData">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordInto">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSilent">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCreate">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDrop">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordWith">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUsing">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDefault">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMinus">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordService">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBindings">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUndef">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.NonQueryKeywords">
            <summary>
            Set of SPARQL Keywords that are Non-Query Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.FunctionKeywords">
            <summary>
            Set of SPARQL Keywords that are Function Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.AggregateKeywords">
            <summary>
            Set of SPARQL Keywords that are Aggregate Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.UpdateKeywords">
            <summary>
            Set of SPARQL Keywords that are Update Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.IntegerDataTypes">
            <summary>
            Set of XML Schema Data Types which are derived from Integer and can be treated as Integers by Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SupportedCastFunctions">
            <summary>
            Set of IRIs for supported Cast Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlInteger">
            <summary>
            Regular Expression Pattern for Valid Integers in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlDecimal">
            <summary>
            Regular Expression Pattern for Valid Decimals in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlDouble">
            <summary>
            Regular Expression Pattern for Valid Doubles in Sparql
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsNonQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Non-Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsFunctionKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Function Verb
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsAggregateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Aggregate Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsUpdateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Update Keyword
            </summary>
            <param name="keyword"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidQName(System.String)">
            <summary>
            Checks whether a given QName is valid in Sparql
            </summary>
            <param name="value">QName to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidVarName(System.String)">
            <summary>
            Checks whether a given Variable Name is valid in Sparql
            </summary>
            <param name="value">Variable Name to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNCharBase(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_BASE rule from the Sparql Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNCharU(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_U rule from the Sparql Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNChar(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS rule from the Sparql Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNLocal(System.Char[])">
            <summary>
            Checks whether a given String matches the PN_LOCAL rule from the Sparql Specification
            </summary>
            <param name="cs">String as character array</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNPrefix(System.Char[])">
            <summary>
            Checks whether a given String matches the PN_PREFIX rule from the Sparql Specification
            </summary>
            <param name="cs">String as character array</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidNumericLiteral(System.String)">
            <summary>
            Checks whether the given value is a valid Numeric Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsInteger(System.String)">
            <summary>
            Checks whether the given value is a valid Integer Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsDecimal(System.String)">
            <summary>
            Checks whether the given value is a valid Decimal Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsFloat(System.String)">
            <summary>
            Checks whether the given value is a valid Float Literal in Sparql
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsDouble(System.String)">
            <summary>
            Checks whether the given value is a valid Double Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.Uri)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.String)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri as a String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.EffectiveBooleanValue(VDS.RDF.INode)">
            <summary>
            Calculates the Effective Boolean Value of a given Node according to the Sparql specification
            </summary>
            <param name="n">Node to computer EBV for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsSelectQuery(VDS.RDF.Query.SparqlQueryType)">
            <summary>
            Checks whether the Query is a SELECT Query
            </summary>
            <param name="type">Query Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.Equality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Node Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.Inequality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Node Inequality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.NumericEquality(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Implements Numeric Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">SPARQL Numeric Tyoe</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.DateTimeEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Date Time Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.DateEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Date Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.TimeSpanEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Time Span Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDecimal(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Decimal
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDouble(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Double
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToFloat(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Float
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToInteger(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to an Integer
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDateTime(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Date Time
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDateTimeOffset(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Date Time Offset
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToTimeSpan(VDS.RDF.LiteralNode)">
            <summary>
            Converts a Literal Node to a Time Span
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.GraphVizWriter">
            <summary>
            A Writer which generates GraphViz DOT Format files from an RDF Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph into GraphViz DOT Format
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph into GraphViz DOT Format
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.TripleToDOT(VDS.RDF.Triple,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper Method for converting a Triple into DOT notation
            </summary>
            <param name="t">Triple to convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.NodeToDOT(VDS.RDF.INode,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper method for converting a Node into DOT notation
            </summary>
            <param name="n">Node to Convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
            <remarks>Currently Graphs containing Graph Literal Nodes cannot be converted</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.URINodeToDOT(VDS.RDF.UriNode,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper method for converting Uri Nodes to DOT Notation
            </summary>
            <param name="u">Uri Node to convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.BlankNodeToDOT(VDS.RDF.BlankNode)">
            <summary>
            Internal Helper Method for converting Blank Nodes to DOT notation
            </summary>
            <param name="b">Blank Node to Convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.LiteralNodeToDOT(VDS.RDF.LiteralNode)">
            <summary>
            Internal Helper Method for converting Literal Nodes to DOT notation
            </summary>
            <param name="l">Literal Node to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which handles raising the Warning event if an Event Handler is registered to it
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Writing.GraphVizWriter.Warning">
            <summary>
            Event that is raised if there is a potential problem with the RDF being output
            </summary>
            <remarks>Not used by this Writer</remarks>
        </member>
        <member name="T:VDS.RDF.Web.ResourceURIRewriteRule">
            <summary>
            Uri Rewriting Rule
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.ResourceURIRewriteRule.#ctor(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Creates a new Rewriting Rule
            </summary>
            <param name="find">Regular Expression to match</param>
            <param name="replace">Replace to make for matching URIs</param>
        </member>
        <member name="P:VDS.RDF.Web.ResourceURIRewriteRule.Find">
            <summary>
            Gets the Regular Expression to match
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.ResourceURIRewriteRule.Replace">
            <summary>
            Gets the Replace to make for matching URIs
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlQuerySyntax">
            <summary>
            Available Query Syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Sparql_1_0">
            <summary>
            Use SPARQL 1.0
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Sparql_1_1">
            <summary>
            Use SPARQL 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Extended">
            <summary>
            Use the latest SPARQL specification supported by the library (currently SPARQL 1.1) with some extensions
            </summary>
            <remarks>
            <para>
            Extensions include the following:
            </para>
            <ul>
            <li><strong>LET</strong> assignments</li>
            <li>Additional aggregates - <strong>NMAX</strong>, <strong>NMIN</strong>, <strong>MEDIAN</strong> and <strong>MODE</strong></li>
            <li><strong>UNSAID</strong> alias for <strong>NOT EXISTS</strong></li>
            <li>Most of the XPath Function Library for Strings and Numerics supported</li>
            <li>Most of the ARQ (Jena's SPARQL engine) Function Library supported</li>
            </ul>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlQueryParser">
            <summary>
            Class for parsing SPARQL Queries into <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> objects that can be used to query a Graph or Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor">
            <summary>
            Creates a new instance of the SPARQL Query Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new instance of the SPARQL Query Parser using the given Tokeniser Queue Mode
            </summary>
            <param name="queueMode">Token Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new instance of the SPARLQ Query Parser using the given Tokeniser which supports the given SPARQL Syntax
            </summary>
            <param name="queueMode"></param>
            <param name="syntax"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.ParseFromFile(System.String)">
            <summary>
            Parses a SPARQL Query from a File
            </summary>
            <param name="queryFile">File containing the Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.Parse(System.IO.StreamReader)">
            <summary>
            Parses a SPARQL Query from an arbitrary Input Stream
            </summary>
            <param name="input">Input Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.ParseFromString(System.String)">
            <summary>
            Parses a SPARQL Query from a String
            </summary>
            <param name="queryString">A SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.ParseFromString(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Parses a SPARQL Query from a SPARQL Parameterized String
            </summary>
            <param name="queryString">A SPARQL Parameterized String</param>
            <returns></returns>
            <remarks>
            The <see cref="T:VDS.RDF.Query.SparqlParameterizedString">SparqlParameterizedString</see> class allows you to use parameters in a String in a manner similar to SQL Commands in the ADO.Net model.  See the documentation for <see cref="T:VDS.RDF.Query.SparqlParameterizedString">SparqlParameterizedString</see> for details of this.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.TryParseGraphPattern(VDS.RDF.Parsing.Contexts.SparqlQueryParserContext,System.Boolean)">
            <summary>
            Tries to parse a Graph Pattern from the given Parser Context
            </summary>
            <param name="context">Parser Context</param>
            <param name="requireOpeningLeftBracket">Whether the opening Left Curly Bracket is required</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser progress is Traced to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.DefaultBaseURI">
            <summary>
            Gets/Sets the Default Base Uri for Queries parsed by this Parser instance
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertyLessThanSelector">
            <summary>
            A Selector which finds all Triples where the Predicate is a given Property and the Value is less than a given Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyLessThanSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasPropertyLessThanSelector for the given Property and Value
            </summary>
            <param name="property">Property</param>
            <param name="value">Value that the Property should be Less Than</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyLessThanSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the desired Property and the Object has a value Less Than the value specified when the Selector was instantiated with
            </summary>
            <param name="obj">Triple to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertyLessThanOrEqualToSelector">
            <summary>
            A Selector which finds all Triples where the Predicate is a given Property and the Value is less than or equal to a given Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyLessThanOrEqualToSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasPropertyLessThanOrEqualSelector for the given Property and Value
            </summary>
            <param name="property">Property</param>
            <param name="value">Value that the Property should be Less Than or Equal To</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyLessThanOrEqualToSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the desired Property and the Object has a value Less Than or Equal To the value specified when the Selector was instantiated with
            </summary>
            <param name="obj">Triple to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertyGreaterThanSelector">
            <summary>
            A Selector which finds all Triples where the Predicate is a given Property and the Value is greater than a given Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyGreaterThanSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasPropertyGreaterThanSelector for the given Property and Value
            </summary>
            <param name="property">Property</param>
            <param name="value">Value that the Property should be Greater Than</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyGreaterThanSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the desired Property and the Object has a value Greater Than the value specified when the Selector was instantiated with
            </summary>
            <param name="obj">Triple to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertyGreaterThanOrEqualToSelector">
            <summary>
            A Selector which finds all Triples where the Predicate is a given Property and the Value is greater than or equal to a given Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyGreaterThanOrEqualToSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasPropertyGreaterThanOrEqualToSelector for the given Property and Value
            </summary>
            <param name="property">Property</param>
            <param name="value">Value that the Property should be Greater Than or Equal To</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyGreaterThanOrEqualToSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples where the Predicate is the desired Property and the Object has a value Greater Than or Equal To the value specified when the Selector was instantiated with
            </summary>
            <param name="obj">Triple to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ThreadSafeSqlGraph">
            <summary>
            A Thread Safe version of <see cref="T:VDS.RDF.SqlGraph">SqlGraph</see> which represents a RDF Graph which is automatically persisted to a SQL based backing store as it is modified
            </summary>
            <threadsafety instance="true">Should be safe for almost any concurrent read and write access scenario, internally managed using a <see cref="T:System.Threading.ReaderWriterLockSlim">ReaderWriterLockSlim</see>.  If you encounter any sort of Threading/Concurrency issue please report to the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">dotNetRDF Bugs Mailing List</a></threadsafety>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.#ctor(System.Uri,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.#ctor(System.Uri,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded.  Assumes the Database is on the localhost
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.#ctor(System.Uri,VDS.RDF.Storage.IThreadedSqlIOManager)">
            <summary>
            Creates a new instance of a Graph which is automatically saved to the given SQL Store, if a Graph with the Uri exists in the store it will be automatically loaded
            </summary>
            <param name="graphUri">Uri of the Graph</param>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> for your chosen underlying store</param>
            <remarks>The Store may be any database for which a working <see cref="T:VDS.RDF.Storage.IThreadedSqlIOManager">IThreadedSqlIOManager</see> has been defined</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple into the Graph
            </summary>
            <param name="t">Triple to Assert</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts an Enumerable of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Assert(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Assert(VDS.RDF.Triple[])">
            <summary>
            Asserts an Array of Triples into the Graph
            </summary>
            <param name="ts">Triples to assert</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts an Enumerable of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Retract(System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Retracts a List of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Retract(VDS.RDF.Triple[])">
            <summary>
            Retracts an Array of Triples from the Graph
            </summary>
            <param name="ts">Triples to Retract</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Refresh">
            <summary>
            Causes the Graph to be refreshed from the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.HandleNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceAdded Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.HandleNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceModified Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.HandleNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Handler for the NamespaceRemoved Event of the Namespace map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeSqlGraph.Dispose">
            <summary>
            Disposes of a SQL Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeSqlGraph.Manager">
            <summary>
            Gets the <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> used to manage database IO for this Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseGraphCollection">
            <summary>
            Abstract Base Class for Graph Collections
            </summary>
            <remarks>Designed to allow the underlying storage of a Graph Collection to be changed at a later date without affecting classes that use it</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <see cref="!:IGraph.Dipose">Dispose()</see> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.FastRdfXmlWriter">
            <summary>
            Class for generating RDF/XML Concrete Syntax
            </summary>
            <remarks>
            <para>
            Use this if you require fast writing and are not so bothered about the readibility of syntax produced, if you prefer readable syntax and can live with the very slow speeds (around 300 Triple/second) use the <see cref="T:VDS.RDF.Writing.RdfXmlWriter">RdfXmlWriter</see> or the <see cref="T:VDS.RDF.Writing.RdfXmlTreeWriter">RdfXmlTreeWriter</see>.
            </para>
            <para>
            This is a fast writer based on the fast writing technique used in the other non-RDF/XML writers.  While it is significantly faster than the existing RDF/XML writers achieving a speed of around 25,000 Triples/second the syntax produced is not the 'prettiest'.  It uses various syntax compressions but since it doesn't generate output in an explicitly striped manner it cannot produce the nice striped syntax
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.FastRdfXmlWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph in RDF/XML syntax to the given File
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">Filename to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.FastRdfXmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to an arbitrary output stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.FastRdfXmlWriter.GenerateOutput(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Internal method which generates the RDF/Json Output for a Graph
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.FastRdfXmlWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method for raising the Warning event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.FastRdfXmlWriter.PrettyPrintMode">
            <summary>
            Gets/Sets Pretty Print Mode for the Writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.FastRdfXmlWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.HtmlWriterContext">
            <summary>
            Writer Context for XHTML+RDFa Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.HtmlWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new HTML Writer Context
            </summary>
            <param name="g">Graph</param>
            <param name="writer">Text Writer</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.HtmlWriterContext.HtmlWriter">
            <summary>
            HTML Writer to use
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.FileSparqlHandler">
            <summary>
            A HTTP Handler for Sparql Queries which use the libraries Sparql implementation over a Store which contains RDF data stored on disk in a single file/folder
            </summary>
            <remarks>
            <para>
            Effectively acts as a gateway to a Remote Endpoint, queries are executed against the endpoint and the raw Response Stream received is passed directly back to the Client.
            </para>
            <para>
            This Handler supports registering the Handler multiple times in one Web application with each able to use its own settings.
            </para>
            <para>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the virtual path of the handler like so:
            <code>&lt;add key="/virtualRoot/sparql/" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </para>
            <para>
            The following Configuration Variables are supported in addition to those supported by the <see cref="T:VDS.RDF.Web.BaseSparqlHandler">BaseSparqlHandler</see>:
            </para>
            <ul>
            <li>
                One of the following variables must be specified for the data source, <strong>DataFolder</strong> is checked before <strong>DataFile</strong>.  <strong>DataFile</strong> is ignored if <strong>DataFolder</strong> is specified:
                <ol>
                <li><strong>DataFolder</strong> - A relative path to a Folder containing RDF files that will be loaded into the Store and queried against by the Handler</li>
                <li><strong>DataFile</strong> - A relative path to a single RDF file that will be loaded into the Store and queried against by the Handler</li>
                </ol>
            </li>
            </ul>
            <para>
            If the Folder/File does not exist then the Handler will throw an Error when you first attempt to access it.
            </para>
            <para>
            In the event that there are no valid RDF files loaded the Handler will execute queries over an Empty Store
            </para>
            <para>
            As with the <see cref="T:VDS.RDF.Web.SparqlHandler">SparqlHandler</see> you can attach both Reasoners and Custom Expression Factories to this Handler, see the <see cref="T:VDS.RDF.Web.SparqlHandler">SparqlHandler</see> documentation for details of how to do this.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.FileSparqlHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Configuration for a File Sparql Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.FileSparqlHandler.RecacheConfig(System.Web.HttpContext)">
            <summary>
            Updates the Configuration in the Cache to reflect additional Graphs that have been added
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Web.FileSparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">
            <summary>
            Process a Sparql Query by executing against the Data from the File/Folder which has been loaded into an in-memory queryable Triple Store
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="query">Sparql Query</param>
            <param name="userDefaultGraphs">User specified default Graph(s)</param>
            <param name="userNamedGraphs">User specified named Graph(s)</param>
            <param name="timeout">User specified timeout</param>
            <param name="partialResults">Partial Results setting</param>
        </member>
        <member name="T:VDS.RDF.Web.HandlerHelper">
            <summary>
            Static Helper class for HTTP Handlers
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.IsAuthenticated(System.Web.HttpContext,System.Collections.Generic.IEnumerable{VDS.RDF.Configuration.Permissions.UserGroup})">
            <summary>
            Checks whether a User is authenticated (or guests are permitted)
            </summary>
            <param name="context">HTTP Context</param>
            <param name="groups">User Groups to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.IsAuthenticated(System.Web.HttpContext,System.Collections.Generic.IEnumerable{VDS.RDF.Configuration.Permissions.UserGroup},System.String)">
            <summary>
            Checks whether a User is authenticated (or guests are permitted) and the given action is allowed
            </summary>
            <param name="context">HTTP Context</param>
            <param name="groups">User Groups to test against</param>
            <param name="action">Action to check for permission for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.HandleQueryErrors(System.Web.HttpContext,VDS.RDF.Web.Configuration.BaseHandlerConfiguration,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="config">Handler Configuration</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.HandleQueryErrors(System.Web.HttpContext,VDS.RDF.Web.Configuration.BaseHandlerConfiguration,System.String,System.String,System.Exception,System.Int32)">
            <summary>
            Handles errors in processing SPARQL Query Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="config">Handler Configuration</param>
            <param name="title">Error title</param>
            <param name="query">Sparql Query</param>
            <param name="ex">Error</param>
            <param name="statusCode">HTTP Status Code to return</param>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.HandleUpdateErrors(System.Web.HttpContext,VDS.RDF.Web.Configuration.BaseHandlerConfiguration,System.String,System.String,System.Exception)">
            <summary>
            Handles errors in processing SPARQL Update Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="config">Handler Configuration</param>
            <param name="title">Error title</param>
            <param name="update">SPARQL Update</param>
            <param name="ex">Error</param>
        </member>
        <member name="M:VDS.RDF.Web.HandlerHelper.HandleUpdateErrors(System.Web.HttpContext,VDS.RDF.Web.Configuration.BaseHandlerConfiguration,System.String,System.String,System.Exception,System.Int32)">
            <summary>
            Handles errors in processing SPARQL Update Requests
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="config">Handler Configuration</param>
            <param name="title">Error title</param>
            <param name="update">SPARQL Update</param>
            <param name="ex">Error</param>
            <param name="statusCode">HTTP Status Code to return</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.WebConfigurationLoader">
            <summary>
            Static Helper class for Configuration loading for use in ASP.Net applicatons
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.WebConfigurationLoader.WebConfigGraphCacheKey">
            <summary>
            Base Cache Key for Configuration Graph caching
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.WebConfigurationLoader.WebConfigGraphCacheDuration">
            <summary>
            Cache Duration for Configuration Graph caching
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.WebConfigurationLoader.LoadConfigurationGraph(System.Web.HttpContext,System.String)">
            <summary>
            Gets the Configuration Graph with the given Filename returns it
            </summary>
            <param name="context">HTTP Context</param>
            <param name="configFile">Configuration File</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.WebConfigurationLoader.FindObject(VDS.RDF.IGraph,System.Uri,System.String@)">
            <summary>
            Finds whether there is any Handler Configuration for a wildcard path that the current request path matches
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="requestUri">Request URI</param>
            <param name="matchedPath">The resulting matched path</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.WebConfigurationPathResolver">
            <summary>
            Path Resolver for Web Configuration loading
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.WebConfigurationPathResolver.#ctor(System.Web.HttpServerUtility)">
            <summary>
            Creates a new Web Configuration Path Resolver
            </summary>
            <param name="server">HTTP Server Utility</param>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.WebConfigurationPathResolver.ResolvePath(System.String)">
            <summary>
            Resolves a Path by calling MapPath() where appropriate
            </summary>
            <param name="path">Path</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.FilterPattern">
            <summary>
            Class for representing Filter Patterns in SPARQL Queries
            </summary>
            <remarks>
            A Filter Pattern is any FILTER clause that can be executed during the process of executing Triple Patterns rather than after all the Triple Patterns and Child Graph Patterns have been executed
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.#ctor(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Filter Pattern with the given Filter
            </summary>
            <param name="filter">Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.ToString">
            <summary>
            Returns the string representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.IsAcceptAll">
            <summary>
            Returns that the Pattern is not an accept all (since it's a Filter)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainService">
            <summary>
            Represents the Explain Service provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.Services.ExplainService._baseQuery">
            <summary>
            Base Query for use with the Explain Service
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainService.Explain(System.String)">
            <summary>
            Gets a Graph explaining the result of the SPARQL Query
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService">
            <summary>
            Represents the Explan Unsatisfiable Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Unsatisfiable Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService.ExplainUnsatisfiable(VDS.RDF.INode)">
            <summary>
            Gets a Graph explaining why a Class is unsatisfiable
            </summary>
            <param name="cls">Class</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService">
            <summary>
            Represents the Explain Instance Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Instance Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService.ExplainInstance(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets a Graph explaining why an Instance is of the given Class
            </summary>
            <param name="instance">Instance</param>
            <param name="cls">Class</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService">
            <summary>
            Represents the Explain Subclass Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Subclass Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService.ExplainSubclass(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets a Graph explaining why the given Class is a subclass of the given Super Class
            </summary>
            <param name="subclass">Class</param>
            <param name="superclass">Super Class</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService">
            <summary>
            Represents the Explain Inconsistent Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Inconsistent Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService.ExplainInconsistent">
            <summary>
            Gets a Graph explaining why the Knowledge Base is inconsistent
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService">
            <summary>
            Represents the Explain Property Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Property Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.ExplainProperty(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets a Graph explaining why the given Triple was derived
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.ExplainProperty(VDS.RDF.Triple)">
            <summary>
            Gets a Graph explaining why the given Triple was derived
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlHelper">
            <summary>
            Helper class containing constants and methods for use in implementing OWL support
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlNothing">
            <summary>
            OWL Class and Property Constants
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode">
            <summary>
            Class containing Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DefaultStatements">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllClass">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllIndividual">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllProperty">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllStatements">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllStatementsIncludingJena">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ClassAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ComplementOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DataPropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DifferentIndividuals">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectClassAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectSubClassOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectSubPropertyOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DisjointClasses">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DisjointProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.EquivalentClasses">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.EquivalentProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.InverseProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ObjectPropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.PropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SameIndividual">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SubClassOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SubPropertyOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.DistinctModifierExpression">
            <summary>
            Class for representing the Distinct Modifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.DistinctModifierExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Throws a <see cref="T:System.NotImplementedException">NotImplementedException</see> since this class is a placeholder and only used in parsing
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.DistinctModifierExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Throws a <see cref="T:System.NotImplementedException">NotImplementedException</see> since this class is a placeholder and only used in parsing
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.DistinctModifierExpression.Variables">
            <summary>
            Returns an empty enumerable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.AggregateExpressionTerm">
            <summary>
            Class for representing Aggregate Expressions which have Numeric Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AggregateExpressionTerm.#ctor(VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Creates a new Aggregate Expression Term that uses the given Aggregate
            </summary>
            <param name="aggregate">Aggregate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AggregateExpressionTerm.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of the Aggregate as evaluated for the given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AggregateExpressionTerm.ToString">
            <summary>
            Gets the String representation of the Aggregate Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.AggregateExpressionTerm.Aggregate">
            <summary>
            Gets the Aggregate this Expression represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.AggregateExpressionTerm.Variables">
            <summary>
            Gets the enumeration of variables that are used in the the aggregate expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm">
            <summary>
            Class for representing Aggregate Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.#ctor(VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Creates a new non-numeric Aggregate Expression Term
            </summary>
            <param name="agg"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the Aggregate
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean Value of the Aggregate
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.Aggregate">
            <summary>
            Gets the Aggregate this Expression represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.NonNumericAggregateExpressionTerm.Variables">
            <summary>
            Gets the Variables used in the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext">
            <summary>
            Parser Context for SPARQL Query parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new SPARQL Query Parser Context with default settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Contexts.SparqlQueryParserContext,VDS.RDF.Parsing.Tokens.ITokenQueue)">
            <summary>
            Creates a new SPARQL Query Parser Context for parsing sub-queries
            </summary>
            <param name="parent">Parent Query Parser Context</param>
            <param name="tokens">Tokens that need parsing to form a subquery</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokenQueue)">
            <summary>
            Creates a new Query Parser Context from the given Token Queue
            </summary>
            <param name="tokens">Token Queue</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.GetNewBlankNodeID">
            <summary>
            Gets a new Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.Query">
            <summary>
            Gets the Query that this Parser Context is populating
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.VerbSeen">
            <summary>
            Gets/Sets whether the Query Verb has been seen
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.SubQueryMode">
            <summary>
            Returns whether this Parser Context is for a sub-query
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.DefaultBaseUri">
            <summary>
            Gets/Sets the default Base Uri to resolve relative URIs against
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.ExpressionParser">
            <summary>
            Gets the Expression Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.PathParser">
            <summary>
            Gets the Property Path Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.GraphPatternID">
            <summary>
            Gets/Sets the current Graph Pattern ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.BlankNodeIDUsages">
            <summary>
            Gets the mapping of in use Blank Nodes IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.BlankNodeID">
            <summary>
            Gets the last Blank Node ID that was issued
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.NextAliasID">
            <summary>
            Gets the Next Available Alias ID for aliasing Project Expressions and Aggregates which don't have an Aggregate Specified
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.ExpressionFactories">
            <summary>
            Gets the Custom Expression Factories valid for this Parser
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.StringWriter">
            <summary>
            Static Helper class for the writing of RDF Graphs and SPARQL Result Sets to Strings rather than Streams/Files
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.StringWriter.Write(VDS.RDF.IGraph,VDS.RDF.IRdfWriter)">
            <summary>
            Writes the Graph to a String and returns the Output in your chosen concrete RDF Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="writer">Writer to use to generate the concrete RDF Syntax</param>
            <returns></returns>
            <remarks>
            Since the API allows for any <see cref="T:System.IO.TextWriter">TextWriter</see> to be passed to the <see cref="M:VDS.RDF.IRdfWriter.Save(VDS.RDF.IGraph,System.String)">Save()</see> method of a <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> you can just pass in a <see cref="T:VDS.RDF.Writing.StringWriter">StringWriter</see> to the Save() method to get the output as a String.  This method simply provides a wrapper to doing just that.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.StringWriter.Write(VDS.RDF.Query.SparqlResultSet,VDS.RDF.ISparqlResultsWriter)">
            <summary>
            Writes the SPARQL Result Set to a String and returns the Output in your chosen format
            </summary>
            <param name="results">SPARQL Result Set</param>
            <param name="writer">Writer to use to generate the SPARQL Results output</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlHtmlWriter">
            <summary>
            Class for saving SPARQL Result Sets to a HTML Table format (this is not a standardised format)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves the Result Set to the given File as a HTML Table
            </summary>
            <param name="results">Result Set to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream as a HTML Table
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Internal method which generates the HTML Output for the Sparql Results
            </summary>
            <param name="results"></param>
            <param name="output"></param>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.Stylesheet">
            <summary>
            Gets/Sets a path to a Stylesheet which is used to format the Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.CssClassUri">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display the URIs of URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.CssClassBlankNode">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Blank Node IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.CssClassLiteral">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.CssClassDatatype">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display Literal datatypes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.CssClassLangSpec">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literal language specifiers
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.UriPrefix">
            <summary>
            Gets/Sets the Prefix applied to href attributes
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.AllSelector`1">
            <summary>
            Selector which Selects All Objects
            </summary>
            <typeparam name="T">Type you are performing Selection upon</typeparam>
        </member>
        <member name="M:VDS.RDF.Query.AllSelector`1.Accepts(`0)">
            <summary>
            Accepts All Objects
            </summary>
            <param name="obj">Object to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.NoneSelector`1">
            <summary>
            Selector which Selects No Objects
            </summary>
            <typeparam name="T">Type you are performing Selection upon</typeparam>
        </member>
        <member name="M:VDS.RDF.Query.NoneSelector`1.Accepts(`0)">
            <summary>
            Accepts No Objects
            </summary>
            <param name="obj">Object to Test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.NotSelector`1">
            <summary>
            Selector which performs Not on the underlying Selectors results
            </summary>
            <typeparam name="T">Type you are performing selection upon</typeparam>
        </member>
        <member name="M:VDS.RDF.Query.NotSelector`1.#ctor(VDS.RDF.ISelector{`0})">
            <summary>
            Creates a new Not Selector using the given Selector
            </summary>
            <param name="selector">The Selector whose results you wish to Not</param>
        </member>
        <member name="M:VDS.RDF.Query.NotSelector`1.Accepts(`0)">
            <summary>
            Accepts any Object which are rejected by the Underlying Selector
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasPropertyValueSelector">
            <summary>
            A Selector which finds Triples which have a given value for a given Property
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyValueSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasPropertyValueSelector for the given Property and Value
            </summary>
            <param name="property">Property that Triples must have as their Predicates</param>
            <param name="value">Value that Triples must have as their Objects</param>
        </member>
        <member name="M:VDS.RDF.Query.HasPropertyValueSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples which have the given Property as their Predicate and the given Value as their Object
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.HasNonMatchingPropertyValueSelector">
            <summary>
            A Selector which finds Triples which have a given Property which does not match the given Value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.HasNonMatchingPropertyValueSelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new HasNonMatchingPropertyValueSelector for the given Property and Value
            </summary>
            <param name="property">Property that Triples must have as their Predicate</param>
            <param name="value">Value that Triples must not have as their Object</param>
        </member>
        <member name="M:VDS.RDF.Query.HasNonMatchingPropertyValueSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples which have the given Property as their Predicate and not the given Value as their Object
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SubjectHasPropertySelector">
            <summary>
            A Selector which finds Triples where a given Subject has a given Property
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SubjectHasPropertySelector.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new SubjectHasPropertySelector which selects Triples which have a given Subject and Predicate
            </summary>
            <param name="subject">Subject that Triples must have</param>
            <param name="property">Property that Triples must have as their Predicate</param>
        </member>
        <member name="M:VDS.RDF.Query.SubjectHasPropertySelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples which have the Subject and Predicate specified when the Selector was instantiated
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SubjectIsSelector">
            <summary>
            A Selector which finds Triples which have a given Subject
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SubjectIsSelector.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new SubjectIsSelector using the given Subject
            </summary>
            <param name="subject">Subject to Select</param>
        </member>
        <member name="M:VDS.RDF.Query.SubjectIsSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples whose Subject matches the given Subject this Selector was initialised with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.PredicateIsSelector">
            <summary>
            A Selector which finds Triples which have a given Predicate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PredicateIsSelector.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new PredicateIsSelector using the given Predicate
            </summary>
            <param name="predicate">Predicate to Select</param>
        </member>
        <member name="M:VDS.RDF.Query.PredicateIsSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples whose Predicate matches the given Predicate this Selector was initialised with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.ObjectIsSelector">
            <summary>
            A Selector which finds Triples which have a given Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.ObjectIsSelector.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new ObjectIsSelector using the given Object
            </summary>
            <param name="obj">Object to Select</param>
        </member>
        <member name="M:VDS.RDF.Query.ObjectIsSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples whose Object matches the given Object this Selector was initialised with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SubjectDependentWrapperSelector">
            <summary>
            A Dependent Selector Wrapper which accepts Triples accepted by the underlying Selector if their Subject is the Subject of one of the Triples the Dependent Wrapper was initialised with
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SubjectDependentWrapperSelector.#ctor(VDS.RDF.ISelector{VDS.RDF.Triple})">
            <summary>
            Creates a new SubjectDependentWrapperSelector using the given Selector
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:VDS.RDF.Query.SubjectDependentWrapperSelector.Initialise(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Intialises this Selector
            </summary>
            <param name="input">List of Triples to initialise this Selector</param>
        </member>
        <member name="M:VDS.RDF.Query.SubjectDependentWrapperSelector.Accepts(VDS.RDF.Triple)">
            <summary>
            Accepts Triples whose Subjects were the Subject of any of the Triples this Selector was initialised with and which are accepted by the underlying selector that this Selector was instantiated with
            </summary>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlTsvWriter">
            <summary>
            Class for saving SPARQL Result Sets to TSV format (not a standardised format)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlTsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves a SPARQL Result Set to TSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlTsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves a SPARQL Result Set to TSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.FolderStoreWriterContext">
            <summary>
            Writer Context for Store Writers which write to multiple files in a folder
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.FolderStoreParams)">
            <summary>
            Creates a new Writer Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="params">Folder Store Parameters</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.String,VDS.RDF.Storage.FolderStoreFormat,System.Int32)">
            <summary>
            Creates a new Writer Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="folder">Folder to write to</param>
            <param name="format">Folder Store Format</param>
            <param name="threads">Threads to use</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.String,VDS.RDF.Storage.FolderStoreFormat)">
            <summary>
            Creates a new Writer Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="folder">Folder to write to</param>
            <param name="format">Folder Store Format</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Creates a new Writer Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="folder">Folder to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.Add(System.Uri)">
            <summary>
            Adds a Uri to the list of URIs for Graphs that are waiting to be written
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.GetNextURI">
            <summary>
            Gets the next Uri for a Graph that is waiting to be written
            </summary>
            <returns>Uri of next Graph to be written</returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.Store">
            <summary>
            Gets the Triple Store that is being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.Folder">
            <summary>
            Gets the Folder to which the Store should be written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.Threads">
            <summary>
            Gets the number of threads to use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.FolderStoreWriterContext.Format">
            <summary>
            Gets the Format to use for files in the Folder
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlNumericType">
            <summary>
            Numeric Types for Sparql Numeric Expressions
            </summary>
            <remarks>All Numeric expressions in Sparql are typed as Integer/Decimal/Double</remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.NaN">
            <summary>
            Not a Number
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Integer">
            <summary>
            An Integer
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Decimal">
            <summary>
            A Decimal
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Float">
            <summary>
            A Single precision Floating Point
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Double">
            <summary>
            A Double precision Floating Point
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticSkosReasoner">
            <summary>
            An Inference Engine that uses SKOS Concept Hierarchies
            </summary>
            <remarks>
            <para>
            Infers additional values for properties based on SKOS Concept Hierarcies.  If there is a Triple whose value is a Concept from the hierarchy then new versions of that Triple will be inferred where the object becomes each concept higher in the hierarchy.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Inference.StaticSkosReasoner.SKOSNamespace">
            <summary>
            Namespace for SKOS
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.#ctor">
            <summary>
            Creates a new instance of the SKOS Reasoner
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Initialise(VDS.RDF.IGraph)">
            <summary>
            Imports any Concept heirarchy information from the given Graph into the Reasoners Knowledge Base in order to initialise the Reasoner
            </summary>
            <param name="g">Graph to import from</param>
            <remarks>
            Looks for Triples defining SKOS concepts and relating them to narrower and broader concepts
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.SkosReasoner">
            <summary>
            An Inference Engine that uses SKOS Concept Hierarchies
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SkosReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="T:VDS.RDF.Update.SimpleUpdateProcessor">
            <summary>
            SPARQL Update Processor which processes updates by handing them off to the <see cref="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(System.String)">ExecuteUpdate()</see> method of an <see cref="T:VDS.RDF.IUpdateableTripleStore">IUpdateableTripleStore</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.#ctor(VDS.RDF.IUpdateableTripleStore)">
            <summary>
            Creates a new Simple Update Processor
            </summary>
            <param name="store">Updateable Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="T:VDS.RDF.Update.LeviathanUpdateProcessor">
            <summary>
            Default SPARQL Update Processor provided by the library's Leviathan SPARQL Engine
            </summary>
            <remarks>
            <para>
            The Leviathan Update Processor simply invokes the <see cref="!:SparqlUpdateCommand.Update">Update</see> method of the SPARQL Commands it is asked to process
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Update Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
            <remarks>
            Invokes the type specific method for the command type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
            <remarks>
            Invokes <see cref="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">ProcessCommand()</see> on each command in turn
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DeleteCommand">
            <summary>
            Represents the SPARQL Update DELETE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new DELETE command
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="where">Pattern to select data which is then used in evaluating the deletions pattern</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new DELETE command which operates on the Default Graph
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="where">Pattern to select data which is then used in evaluating the deletions pattern</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new DELETE command 
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Createa a new DELETE command which operates on the Default Graph
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the deletions are made from
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.DeletePattern">
            <summary>
            Gets the pattern used for Deletions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.GenericIOParams">
            <summary>
            Store Parameters for Readers &amp; Writers which communicate with arbitrary stores which are connected to using an <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Params.GenericIOParams._manager">
            <summary>
            Input/Output Manager for the target underlying store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.GenericIOParams.#ctor(VDS.RDF.Storage.IGenericIOManager)">
            <summary>
            Creates a new set of Generic IO Parameters using the given <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>
            </summary>
            <param name="manager">IO Manager for the underlying Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Params.GenericIOParams.#ctor(VDS.RDF.Storage.IGenericIOManager,System.Int32)">
            <summary>
            Creates a new set of Generic IO Parameters using the given <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see>
            </summary>
            <param name="manager">IO Manager for the underlying Store</param>
            <param name="threads">Number of Threads to use for operations which can be multi-threaded</param>
        </member>
        <member name="P:VDS.RDF.Storage.Params.GenericIOParams.Manager">
            <summary>
            Input/Output Manager for communicating with the underlying store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.GenericIOParams.Threads">
            <summary>
            Threads to use for multi-threadable operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.QueryableGenericIOParams">
            <summary>
            Store Parameters for Readers &amp; Writers which communicate with arbitrary stores which are connected to using an <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.QueryableGenericIOParams.#ctor(VDS.RDF.Storage.IQueryableGenericIOManager)">
            <summary>
            Creates a new set of Generic IO Parameters using the given <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see>
            </summary>
            <param name="manager">Queryable IO Manager for the underlying Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Params.QueryableGenericIOParams.#ctor(VDS.RDF.Storage.IQueryableGenericIOManager,System.Int32)">
            <summary>
            Creates a new set of Generic IO Parameters using the given <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see>
            </summary>
            <param name="manager">Queryable IO Manager for the underlying Store</param>
            <param name="threads">Number of Threads to use for operations which can be multi-threaded</param>
        </member>
        <member name="P:VDS.RDF.Storage.Params.QueryableGenericIOParams.QueryableManager">
            <summary>
            Gets the Queryable Input/Output Manager for communicating with the underlying store
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlNodeComparer">
            <summary>
            Comparer class for implementing the SPARQL semantics for the relational operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.Compare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.NumericCompare(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Compares two Nodes for Numeric Ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">Numeric Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateTimeCompare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateCompare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Dates for Date ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.NonAlgebraQueryProcessor">
            <summary>
            Abstract Base Class for SPARQL Query processors which are not based on the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Processes SPARQL Algebra
            </summary>
            <param name="algebra">Algebra</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessAsk(VDS.RDF.Query.Algebra.Ask)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessBGP(VDS.RDF.Query.Algebra.BGP)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessBindings(VDS.RDF.Query.Algebra.Bindings)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessExistsJoin(VDS.RDF.Query.Algebra.ExistsJoin)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessFilter(VDS.RDF.Query.Algebra.Filter)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessGraph(VDS.RDF.Query.Algebra.Graph)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessHaving(VDS.RDF.Query.Algebra.Having)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessJoin(VDS.RDF.Query.Algebra.Join)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessLeftJoin(VDS.RDF.Query.Algebra.LeftJoin)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessMinus(VDS.RDF.Query.Algebra.Minus)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessProject(VDS.RDF.Query.Algebra.Project)">
            <summary>
            Processes a Projection
            </summary>
            <param name="project">Projection</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessReduced(VDS.RDF.Query.Algebra.Reduced)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessSelect(VDS.RDF.Query.Algebra.Select)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessService(VDS.RDF.Query.Algebra.Service)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessSlice(VDS.RDF.Query.Algebra.Slice)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="M:VDS.RDF.Query.NonAlgebraQueryProcessor.ProcessUnion(VDS.RDF.Query.Algebra.Union)">
            <summary>
            Processes a Union
            </summary>
            <param name="union"></param>
            <exception cref="T:System.NotSupportedException">Thrown since this Query Processor is not an algebra supporting processor</exception>
        </member>
        <member name="T:VDS.RDF.Query.SimpleQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to the <see cref="M:VDS.RDF.INativelyQueryableStore.ExecuteQuery(System.String)">ExecuteQuery()</see> method of an <see cref="T:VDS.RDF.INativelyQueryableStore">INativelyQueryableStore</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.#ctor(VDS.RDF.INativelyQueryableStore)">
            <summary>
            Creates a new Simple Query Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.GenericQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to the <see cref="!:IGenericIOManager.Query">Query()</see> method of an <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.#ctor(VDS.RDF.Storage.IQueryableGenericIOManager)">
            <summary>
            Creates a new Generic Query Processor
            </summary>
            <param name="manager">Generic IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.RemoteQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to a remote SPARQL endpoint
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.#ctor(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Creates a new Remote Query Processor
            </summary>
            <param name="endpoint">SPARQL Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqBNodeFunction">
            <summary>
            Represents the ARQ afn:bnode() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqBNodeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ BNode function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqBNodeFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqBNodeFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqBNodeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqLocalNameFunction">
            <summary>
            Represents the ARQ afn:localname() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqLocalNameFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ Local Name function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqLocalNameFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqLocalNameFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqLocalNameFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqNamespaceFunction">
            <summary>
            Represents the ARQ namespace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNamespaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ Namespace function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNamespaceFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNamespaceFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqNamespaceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.CoalesceFunction">
            <summary>
            Class representing the SPARQL COALESCE() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.CoalesceFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new COALESCE function with the given expressions as its arguments
            </summary>
            <param name="expressions">Argument expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.CoalesceFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.CoalesceFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Effective Boolean value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.CoalesceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.CoalesceFunction.Variables">
            <summary>
            Gets the Variables used in all the argument expressions of this function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.GroupBy">
            <summary>
            Represents a Grouping
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Group By
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Group By by generating a <see cref="T:VDS.RDF.Query.Algebra.GroupMultiset">GroupMultiset</see> from the Input Multiset
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.ToString">
            <summary>
            Gets the String representation of the 
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfASyntax">
            <summary>
            Possible RDFa Syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfASyntax.RDFa_1_0">
            <summary>
            RDFa 1.0
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfASyntax.RDFa_1_1">
            <summary>
            RDFa 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfASyntax.AutoDetect">
            <summary>
            Auto-detect - assumes RDFa 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfASyntax.AutoDetectLegacy">
            <summary>
            Auto-detect - assumes RDFa 1.0
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfAParser">
            <summary>
            Class for reading RDF embedded as RDFa from within HTML web pages
            </summary>
            <remarks>
            <para>
            The RDFa parser uses a HTML parser (<a href="http://www.codeplex.com/htmlagilitypack">Html Agility Pack</a>) that is highly tolerant of real-world HTML and so is able to extract RDFa from pages that are not strictly valid HTML/XHTML
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfAParser.XHtmlVocabNamespace">
            <summary>
            XHTML Vocab Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfAParser.XHtmlPlusRdfADoctype">
            <summary>
            URI for the XHTML+RDFa DTD
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfAParser.XHtmlNamespace">
            <summary>
            Namespace URI for XHTML
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfAParser.RdfANamespace">
            <summary>
            Namespace URI for RDFa
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.#ctor">
            <summary>
            Creates a new RDFa Parser which will auto-detect which RDFa version to use (assumes 1.1 if none explicitly specified)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.#ctor(VDS.RDF.Parsing.RdfASyntax)">
            <summary>
            Creates a new RDFa Parser which will use the specified RDFa syntax
            </summary>
            <param name="syntax">RDFa Syntax Version</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Parses RDFa by extracting it from the HTML from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Parses RDFa by extracting it from the HTML from the given file
            </summary>
            <param name="g">Graph to load into</param>
            <param name="filename">File to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.ResolveCurie(VDS.RDF.Parsing.Contexts.RdfAParserContext,VDS.RDF.Parsing.Contexts.RdfAEvaluationContext,System.String)">
            <summary>
            Resolves a CURIE to a Node
            </summary>
            <param name="context">Parser Context</param>
            <param name="evalContext">Evaluation Context</param>
            <param name="curie">CURIE</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.ResolveUriOrCurie(VDS.RDF.Parsing.Contexts.RdfAParserContext,VDS.RDF.Parsing.Contexts.RdfAEvaluationContext,System.String)">
            <summary>
            Resolves an Attribute which may be a CURIE/URI to a Node
            </summary>
            <param name="context">Parser Context</param>
            <param name="evalContext">Evaluation Context</param>
            <param name="uriref">URI/CURIE</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.ResolveTermOrCurie(VDS.RDF.Parsing.Contexts.RdfAParserContext,VDS.RDF.Parsing.Contexts.RdfAEvaluationContext,System.String)">
            <summary>
            Resolves an Attribute which may be a Term/CURIE/URI to a Node where one/more of the values may be special values permissible in a complex attribute
            </summary>
            <param name="context">Parser Context</param>
            <param name="evalContext">Evaluation Context</param>
            <param name="curie">URI/CURIE/Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.ParseComplexAttribute(VDS.RDF.Parsing.Contexts.RdfAParserContext,VDS.RDF.Parsing.Contexts.RdfAEvaluationContext,System.String)">
            <summary>
            Parses an complex attribute into a number of Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="evalContext">Evaluation Context</param>
            <param name="value">Attribute Value</param>
            <returns></returns>
            <remarks>
            A complex attribute is any attribute which accepts multiple URIs, CURIEs or Terms
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.ParseAttribute(VDS.RDF.Parsing.Contexts.RdfAParserContext,VDS.RDF.Parsing.Contexts.RdfAEvaluationContext,System.String)">
            <summary>
            Parses an attribute into a number of Nodes from the CURIEs contained in the Attribute
            </summary>
            <param name="context">Parser Context</param>
            <param name="evalContext">Evaluation Context</param>
            <param name="value">Attribute Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfAParser.OnWarning(System.String)">
            <summary>
            Internal Helper for raising the Warning Event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Parsing.RdfAParser.Warning">
            <summary>
            Event which is raised when there is a non-fatal error with the input being read
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.JsonParserContext">
            <summary>
            Parser Context for RDF/JSON Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.JsonParserContext.#ctor(VDS.RDF.IGraph,Newtonsoft.Json.JsonTextReader)">
            <summary>
            Creates a new Json Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="input">Json Text Reader to read from</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.JsonParserContext.Input">
            <summary>
            Gets the Json Text Reader which input is read from
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.CachedObjectKey">
            <summary>
            Key for Objects that are cached by the Configuration Loader
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Cached Object Key
            </summary>
            <param name="objNode">Object Node</param>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.GetHashCode">
            <summary>
            Gets the Hash Code for the Key
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.Equals(System.Object)">
            <summary>
            Gets whether this Key is equal to the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.Equals(VDS.RDF.Configuration.CachedObjectKey)">
            <summary>
            Gets whether this Key is equal to the given Key
            </summary>
            <param name="other">Key</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.SqlWriter">
            <summary>
            Class for storing RDF Graphs into SQL backed Storage
            </summary>
            <remarks>The Default Database format is that of the dotNetRDF Store which can be found at <see>http://www.dotnetrdf.org/content.asp?pageID=dotNetRDF%20Store</see>, arbitrary database formats can be used by implementing the <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> interface for your chosen database.</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.SqlWriter.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the SqlWriter which will use the SQL Store accessed with the given Database Information
            </summary>
            <param name="dbserver">Hostname of the Database Server</param>
            <param name="dbname">Name of the Database</param>
            <param name="dbuser">Username for the Database</param>
            <param name="dbpassword">Password for the Database</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.SqlWriter.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the SqlWriter which will use the SQL Store accessed with the given Database Information and assuming the Database is on the localhost
            </summary>
            <param name="dbname">Name of the Database</param>
            <param name="dbuser">Username for the Database</param>
            <param name="dbpassword">Password for the Database</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.SqlWriter.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new instance of the SqlWriter which will use the SQL Store accessed using the given <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> which allows writing to arbitrary SQL Stores
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen underlying store</param>
        </member>
        <member name="M:VDS.RDF.Writing.SqlWriter.Save(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Saves a Graph into a SQL Store
            </summary>
            <param name="g">Graph to Save</param>
            <param name="clearIfExists">Boolean indicating whether this Graph should completely replace an existing Graph with the same Base Uri</param>
        </member>
        <member name="T:VDS.RDF.RdfWriterWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Writers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.RdfReaderWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Readers
            </summary>
            <param name="warning">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TriGTokeniser">
            <summary>
            Tokeniser for TriG (Turtle with Named Graphs) RDF Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(VDS.RDF.Parsing.BlockingStreamReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.GetNextToken">
            <summary>
            Gets the next available Token from the Input Stream
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.SqlReader">
            <summary>
            Class for reading RDF Graphs from a SQL Server Database
            </summary>
            <remarks>The Database format is that of the dotNetRDF Store which can be found at <see>http://www.dotnetrdf.org/content.asp?pageID=dotNetRDF%20Store</see>, arbitrary database formats can be used by implementing the <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> interface for your chosen database.</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SqlReader.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the SqlReader which will use the SQL Store accessed with the given Database Information
            </summary>
            <param name="dbserver">Hostname of the Database Server</param>
            <param name="dbname">Name of the Database</param>
            <param name="dbuser">Username for the Database</param>
            <param name="dbpassword">Password for the Database</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SqlReader.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the SqlReader which will use the SQL Store accessed with the given Database Information and assuming the Database is located on the localhost
            </summary>
            <param name="dbname">Name of the Database</param>
            <param name="dbuser">Username for the Database</param>
            <param name="dbpassword">Password for the Database</param>
            <remarks>Assumes that the SQL Store is a dotNetRDF MS SQL Store</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SqlReader.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new instance of the SqlReader which will use the SQL Store accessed using the given <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> which allows writing to arbitrary SQL Stores
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen underlying store</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SqlReader.Load(System.String)">
            <summary>
            Loads a Graph from a SQL Store
            </summary>
            <param name="graphURI">Uri of the Graph to Load</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SqlReader.Load(System.Uri)">
            <summary>
            Loads a Graph from the SQL Store into a Graph object
            </summary>
            <param name="graphUri">Uri of the Graph to load</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.FolderStoreReader">
            <summary>
            Class for reading Triple Stores that are saved on disk as a set of files in a Folder
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.FolderStoreReader.Load(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Loads Graphs into the store using the settings the Reader was instantiated with
            </summary>
            <param name="store">Store to load into</param>
            <param name="parameters">Parameters indicating where to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.FolderStoreReader.LoadGraphs(VDS.RDF.Parsing.Contexts.FolderStoreParserContext)">
            <summary>
            Internal Method which performs multi-threaded reading of data
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.FolderStoreReader.OnWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="E:VDS.RDF.Parsing.FolderStoreReader.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.FolderStoreReader.LoadGraphsDelegate">
            <summary>
            Delegate for LoadGraphs method
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.BaseGroupBy">
            <summary>
            Abstract Base Class for classes representing Sparql GROUP BY clauses
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Grouping.BaseGroupBy._child">
            <summary>
            Child Grouping
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.BaseGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Grouping to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.BaseGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies the Grouping to the Binder subdividing Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Groups to subdivide</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.Child">
            <summary>
            Gets/Sets the Child GROUP BY Clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.Variables">
            <summary>
            Gets the Fixed Variables involved in this Group By
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.GroupByVariable">
            <summary>
            Represents a Grouping on a given Variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.#ctor(System.String)">
            <summary>
            Creates a new Group By which groups by a given Variable
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies a Grouping on a given Variable to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies a Grouping on a given Variable to the Binder Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Binder Group to subgroup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.ToString">
            <summary>
            Gets the String representation of the GROUP BY
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByVariable.Variables">
            <summary>
            Gets the Variables used in the GROUP BY
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.GroupByExpression">
            <summary>
            Represents a Grouping on a given Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Group By which groups by a given Expression
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies a Grouping on a given Expression to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies a Grouping on a given Variable to the Binder Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Binder Group to subgroup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.ToString">
            <summary>
            Gets the String representation of the GROUP BY
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByExpression.Variables">
            <summary>
            Gets the Fixed Variables used in the Grouping
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint">
            <summary>
            Represents the Service Endpoint for a Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.#ctor(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Service Endpoint instance
            </summary>
            <param name="obj">JSON Object representing the Endpoint</param>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.Uri">
            <summary>
            Gets the URI of the Endpoint
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.HttpMethods">
            <summary>
            Gets the HTTP Methods supported by the Endpoint
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqMaxFunction">
            <summary>
            Represents the ARQ max() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMaxFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ max() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMaxFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMaxFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqMinFunction">
            <summary>
            Represents the ARQ min() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ min() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMinFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqMinFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqPiFunction">
            <summary>
            Represents the ARQ pi() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NumericExpressionTerm">
            <summary>
            Class for representing Fixed Numeric Terms
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.#ctor(System.Int64)">
            <summary>
            Creates a new Numeric Expression
            </summary>
            <param name="value">Integer Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.#ctor(System.Decimal)">
            <summary>
            Creates a new Numeric Expression
            </summary>
            <param name="value">Decimal Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.#ctor(System.Single)">
            <summary>
            Creates a new Numeric Expression
            </summary>
            <param name="value">Float Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.#ctor(System.Double)">
            <summary>
            Creates a new Numeric Expression
            </summary>
            <param name="value">Double Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value this Expression represents as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.NumericType(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Type of the Numeric Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.IntegerValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Integer Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.DecimalValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Decimal Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.FloatValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Float Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.DoubleValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Double Value this Expression represents
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NumericExpressionTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.NumericExpressionTerm.Variables">
            <summary>
            Gets an Empty enumerable since a Numeric expression term doesn't use variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqPiFunction.#ctor">
            <summary>
            Creates a new ARQ Pi function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqPiFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.ArqEFunction">
            <summary>
            Represents the ARQ e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqEFunction.#ctor">
            <summary>
            Creates a new ARQ e function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.ArqEFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.GroupMultiset">
            <summary>
            Multiset which represents a Grouping of Sets from another Multiset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Multiset">
            <summary>
            Represents a Multiset of possible solutions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._variables">
            <summary>
            Variables contained in the Multiset
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._sets">
            <summary>
            Dictionary of Sets in the Multiset
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._counter">
            <summary>
            Counter used to assign Set IDs
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._orderedIDs">
            <summary>
            List of IDs that is used to return the Sets in order if the Multiset has been sorted
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor">
            <summary>
            Creates a new Empty Multiset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Empty Mutliset that has the list of given Variables
            </summary>
            <param name="variables"></param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Multiset from a SPARQL Result Set
            </summary>
            <param name="results">Result Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(VDS.RDF.Query.Patterns.BindingsPattern)">
            <summary>
            Creates a new Multiset from a Bindings Pattern
            </summary>
            <param name="bindings">Bindings Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Does a Left Join of this Multiset to another Multiset where the Join is predicated on the given Expression
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Does an Exists Join of this Multiset to another Multiset where the Join is predicated on the existence/non-existence of a joinable solution on the RHS
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether a solution must exist in the Other Multiset for the join to be made</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Minus Join of this Multiset to another Multiset where any joinable results are subtracted from this Multiset to give the resulting Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Product of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Union of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Determines whether a given Value is present for a given Variable in any Set in this Multiset
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.ContainsVariable(System.String)">
            <summary>
            Returns whether a given Variable is present in any Set in this Multiset
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Determines whether this Multiset is disjoint with another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Add(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Adds a Set to the Multiset
            </summary>
            <param name="s">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the list of Variables present in this Multiset
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Remove(System.Int32)">
            <summary>
            Removes a Set from the Multiset
            </summary>
            <param name="id">Set ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Sort(System.Collections.Generic.IComparer{VDS.RDF.Query.Algebra.Set})">
            <summary>
            Sorts a Set based on the given Comparer
            </summary>
            <param name="comparer">Comparer on Sets</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Trim">
            <summary>
            Trims the Multiset to remove Temporary Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Trim(System.String)">
            <summary>
            Trims the Multiset to remove the given Variable
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.IsEmpty">
            <summary>
            Gets whether the Multiset is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Count">
            <summary>
            Gets the number of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Variables">
            <summary>
            Gets the Variables in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Sets">
            <summary>
            Gets the Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.SetIDs">
            <summary>
            Gets the IDs of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Item(System.Int32)">
            <summary>
            Gets a Set from the Multiset
            </summary>
            <param name="id">Set ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.#ctor(VDS.RDF.Query.Algebra.BaseMultiset,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Creates a new Group Multiset
            </summary>
            <param name="contents">Multiset which contains the Member Sets of the Groups</param>
            <param name="groups">Groups</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.GroupSetIDs(System.Int32)">
            <summary>
            Gets the enumeration of the IDs of Sets in the group with the given ID
            </summary>
            <param name="id">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.Group(System.Int32)">
            <summary>
            Gets the Group with the given ID
            </summary>
            <param name="id">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.Add(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Adds a Set to the Group Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this action is invalid on a Group Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupMultiset.Groups">
            <summary>
            Gets the enumeration of the Groups in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupMultiset.Contents">
            <summary>
            Gets the Multiset which contains the Sets who are the members of the Groups this Multiset represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BGP">
            <summary>
            Represents a BGP which is a set of Triple Patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor">
            <summary>
            Creates a new empty BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Creates a BGP containing a single Triple Pattern
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern})">
            <summary>
            Creates a BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.TriplePattern})">
            <summary>
            Creates a BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.LetPattern})">
            <summary>
            Creates a BGP containing a set of Let Patterns
            </summary>
            <param name="ps">Let Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.FilterPattern})">
            <summary>
            Creates a BGP containing a set of Filter Patterns
            </summary>
            <param name="ps">Filter Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.SubQueryPattern})">
            <summary>
            Creates a BGP containing a set of Sub-query Patterns
            </summary>
            <param name="ps">Sub-query Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BGP against the Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BGP.ToString">
            <summary>
            Returns the String representation of the BGP
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BGP.PatternCount">
            <summary>
            Gets the number of Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BGP.IsEmpty">
            <summary>
            Gets whether the BGP is the emtpy BGP
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.PermissionFactory">
            <summary>
            Factory class for producing Permissions from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.PermissionFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Permission based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.PermissionFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.UserGroupFactory">
            <summary>
            Factory class for producing User Groups from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.UserGroupFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a User Group based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.UserGroupFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ExpressionFactoryFactory">
            <summary>
            Factory class for producing Custom SPARQL Expression Factories from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ExpressionFactoryFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Custom Expression Factory based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ExpressionFactoryFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.LiteralNode">
            <summary>
            Class for representing Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.LangSpecLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.DataTypedLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.PlainLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralNode.CompareTo(VDS.RDF.LiteralNode)">
            <summary>
            Implementation of Compare To for Literal Nodes
            </summary>
            <param name="other">Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralNode.ToString">
            <summary>
            Gets a String representation of a Literal Node
            </summary>
            <returns></returns>
            <remarks>Gives a value without quotes (as some syntaxes use) with the Data Type/Language Specifier appended using Notation 3 syntax</remarks>
        </member>
        <member name="M:VDS.RDF.LiteralNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of CompareTo for Literal Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Literal Nodes are greater than Blank Nodes, Uri Nodes and Nulls, they are less than Graph Literal Nodes.
            <br /><br />
            Two Literal Nodes are initially compared based upon Data Type, untyped literals are less than typed literals.  Two untyped literals are compared purely on lexical value, Language Specifier has no effect on the ordering.  This means Literal Nodes are only partially ordered, for example "hello"@en and "hello"@en-us are considered to be the same for ordering purposes though they are different for equality purposes.  Datatyped Literals can only be properly ordered if they are one of a small subset of types (Integers, Booleans, Date Times, Strings and URIs).  If the datatypes for two Literals are non-matching they are ordered on Datatype Uri, this ensures that each range of Literal Nodes is sorted to some degree.  Again this also means that Literals are partially ordered since unknown datatypes will only be sorted based on lexical value and not on actual value.
            </remarks>
        </member>
        <member name="P:VDS.RDF.LiteralNode.Value">
            <summary>
            Gives the String Value of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.LiteralNode.Language">
            <summary>
            Gives the Language Specifier for the Literal (if it exists) or the Empty String
            </summary>
        </member>
        <member name="P:VDS.RDF.LiteralNode.DataType">
            <summary>
            Gives the Data Type Uri for the Literal (if it exists) or a null
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokenQueueMode">
            <summary>
            Token Queue Mode Constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.QueueAllBeforeParsing">
            <summary>
            No Buffering used
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.SynchronousBufferDuringParsing">
            <summary>
            Synchronous Buffering used
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.AsynchronousBufferDuringParsing">
            <summary>
            Asynchronous Buffering used
            </summary>
        </member>
        <member name="T:VDS.RDF.StoreWriterWarning">
            <summary>
            Delegate Type for Warning Events raised by Triple Store Writers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.StoreReaderWarning">
            <summary>
            Delegate Type for Warning Events raised by Triple Store Readers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.IRdfTranslator">
            <summary>
            Interface to be implemented by RDF Translators which convert from one concrete syntax into another
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfTranslator.Translate(System.String,System.String)">
            <summary>
            Method for Translating RDF in one file into RDF in another file
            </summary>
            <param name="fileIn">File to Read RDF from</param>
            <param name="fileOut">File to Writer RDF to</param>
        </member>
        <member name="M:VDS.RDF.IRdfTranslator.Translate(System.String,System.IO.StreamWriter)">
            <summary>
            Method for Translating RDF in a file into RDF in a Stream
            </summary>
            <param name="fileIn">File to Read RDF from</param>
            <param name="output">Stream to output RDF to</param>
        </member>
        <member name="M:VDS.RDF.IRdfTranslator.Translate(System.IO.StreamReader,System.String)">
            <summary>
            Method for Translating RDF from a Stream into RDF in a File
            </summary>
            <param name="input">Stream to read RDF from</param>
            <param name="fileOut">File to Writer RDF to</param>
        </member>
        <member name="M:VDS.RDF.IRdfTranslator.Translate(System.IO.StreamReader,System.IO.StreamWriter)">
            <summary>
            Method for Translating RDF from a Stream into RDF in another Stream
            </summary>
            <param name="input">Stream to read RDF from</param>
            <param name="output">Stream to output RDF to</param>
        </member>
        <member name="T:VDS.RDF.Storage.VirtuosoManager">
            <summary>
            A Manager for accessing the Native Virtuoso Quad Store
            </summary>
            <remarks>
            <para>
            This class implements <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> allowing it to be used with any of the general classes that support this interface as well as the Virtuoso specific classes.
            </para>
            <para>
            Although this class takes a Database Name to ensure compatability with any Virtuoso installation (i.e. this allows for the Native Quad Store to be in a non-standard database) generally you should always specify <strong>DB</strong> as the Database Name parameter
            </para>
            <para>
            Virtuoso automatically assigns IDs to Blank Nodes input into it, these IDs are <strong>not</strong> based on the actual Blank Node ID so inputting a Blank Node with the same ID multiple times will result in multiple Nodes being created in Virtuoso.  This means that data containing Blank Nodes which is stored to Virtuoso and then retrieved will have different Blank Node IDs to those input.  In addition there is no guarentee that when you save a Graph containing Blank Nodes into Virtuoso that retrieving it will give the same Blank Node IDs even if the Graph being saved was originally retrieved from Virtuoso.
            </para>
            <para>
            You can use a null Uri or an empty String as a Uri to indicate that operations should affect the Default Graph.  Where the argument is only a Graph a null <see cref="P:VDS.RDF.IGraph.BaseUri">BaseUri</see> property indicates that the Graph affects the Default Graph
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager.DefaultPort">
            <summary>
            Default Port for Virtuoso Servers
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager.DefaultDB">
            <summary>
            Default Database for Virtuoso Server Quad Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._dbserver">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._dbname">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._dbuser">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._dbpwd">
            <summary>
            Variables for Database Connection Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._dbport">
            <summary>
            Database Port
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.VirtuosoManager._keepOpen">
            <summary>
            Indicates whether the Database Connection is currently being kept open
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            Creates a Manager for a Virtuoso Native Quad Store
            </summary>
            <param name="server">Server</param>
            <param name="port">Port</param>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a Manager for a Virtuoso Native Quad Store
            </summary>
            <param name="db">Database Name</param>
            <param name="user">Username</param>
            <param name="password">Password</param>
            <remarks>
            Assumes the Server is on the localhost and the port is the default installation port of 1111
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.#ctor(System.String)">
            <summary>
            Creates a Manager for a Virtuoso Native Quad Store
            </summary>
            <param name="connectionString">Connection String</param>
            <remarks>
            Allows the end user to specify a customised connection string
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Quad Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to Load</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Quad Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to Load</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.LoadTriples(System.Uri)">
            <summary>
            Gets a Table of Triples that are in the given Graph
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
            <remarks>
            Assumes that the caller has opened the Database connection
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.LoadNode(VDS.RDF.IGraph,System.Object)">
            <summary>
            Decodes an Object into an appropriate Node
            </summary>
            <param name="g">Graph to create the Node in</param>
            <param name="n">Object to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph into the Quad Store (Warning: Completely replaces any existing Graph with the same URI)
            </summary>
            <param name="g">Graph to save</param>
            <remarks>
            Completely replaces any previously saved Graph with the same Graph URI
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Quad Store
            </summary>
            <param name="graphUri">Graph Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Quad Store
            </summary>
            <param name="graphUri">Graph Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Query(System.String)">
            <summary>
            Executes a SPARQL Query on the native Quad Store
            </summary>
            <param name="sparqlQuery">SPARQL Query to execute</param>
            <returns></returns>
            <remarks>
            <para>
            This method will first attempt to parse the query into a <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> object.  If this succeeds then the Query Type can be used to determine how to handle the response.
            </para>
            <para>
            If the parsing fails then the query will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support.  These include things like aggregate functions but also SPARQL Update statements.
            </para>
            <para>
            If you use an aggregate query which has an Integer, Decimal or Double type result then you will receive a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> containing a single <see cref="T:VDS.RDF.Query.SparqlResult">SparqlResult</see> which has contains a binding for a variable named <strong>Result</strong> which contains a <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see> typed to the appropriate datatype.
            </para>
            </remarks>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs in making the query</exception>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Update(System.String)">
            <summary>
            Executes a SPARQL Update on the native Quad Store
            </summary>
            <param name="sparqlUpdate">SPARQL Update to execute</param>
            <remarks>
            <para>
            This method will first attempt to parse the updat einto a <see cref="T:VDS.RDF.Update.SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> object.  If this succeeds then each command in the command set will be issued to Virtuoso.
            </para>
            <para>
            If the parsing fails then the update will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support.
            </para>
            </remarks>
            <exception cref="T:VDS.RDF.Update.SparqlUpdateException">Thrown if an error occurs in making the update</exception>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Open(System.Boolean)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Open(System.Boolean,System.Data.IsolationLevel)">
            <summary>
            Opens a Connection to the Database
            </summary>
            <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started</param>
            <param name="level">Isolation Level to use</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Close(System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the Connection to the Database
            </summary>
            <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened</param>
            <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.ExecuteNonQuery(System.String)">
            <summary>
            Executes a Non-Query SQL Command against the database
            </summary>
            <param name="sqlCmd">SQL Command</param>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.ExecuteQuery(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns a DataTable
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>DataTable of results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.ExecuteScalar(System.String)">
            <summary>
            Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result)
            </summary>
            <param name="sqlCmd">SQL Command</param>
            <returns>First Column of First Row of the Results</returns>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.Dispose">
            <summary>
            Disposes of the Manager
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.VirtuosoManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.VirtuosoManager.UpdateSupported">
            <summary>
            Indicates that Updates are supported by the Virtuoso Native Quad Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.VirtuosoManager.IsReady">
            <summary>
            Returns that the Manager is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.VirtuosoManager.IsReadOnly">
            <summary>
            Returns that the Manager is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.TalisUpdateResult">
            <summary>
            Possible results of a Talis Update Operation
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisUpdateResult.NotRequired">
            <summary>
            No Update was Required
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisUpdateResult.Done">
            <summary>
            Unversioned Update was Done
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisUpdateResult.Synchronous">
            <summary>
            Versioned Update was Done Synchronously
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisUpdateResult.Asynchronous">
            <summary>
            Unversioned Update was Done Asychronously
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisUpdateResult.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.TalisPlatformConnector">
            <summary>
            Class for connecting to the Talis Platform
            </summary>
            <remarks>
            The Talis platform automatically converts all Blank Nodes input into it into Uri nodes.  This means that data saved to Talis and then retrieved may lose it's Blank Nodes or have them assigned different IDs (different IDs is perfectly acceptable behaviour for any RDF based application since Blank Node IDs are only ever scoped to a given serialization).
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.TalisPlatformConnector.TalisChangeSetNamespace">
            <summary>
            Namespace for the Talis Changeset Ontology
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisPlatformConnector.TalisChangeSetIDFormat">
            <summary>
            Formatting String used to turn Date Times into ChangeSet IDs on URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisPlatformConnector.TalisChangeSetMIMEType">
            <summary>
            MIME Type for Talis ChangeSets
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.TalisPlatformConnector.TalisAPIBaseURI">
            <summary>
            Base Uri for the Talis Platform API
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Talis Platform Connector which manages access to the services provided by the Talis platform
            </summary>
            <param name="storeName">Name of the Store</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <remarks>This Constructor creates a Connector which provides authentication details when making requests to the Talis Platform.  Note that this does not guarentee that operations suceed since the account you apply requires certain capabilities in order for operations to be permitted.</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.#ctor(System.String)">
            <summary>
            Creates a new Talis Platform Connector which manages access to the services provided by the Talis platform
            </summary>
            <param name="storeName">Name of the Store</param>
            <remarks>This Constructor creates a Connector which does not provide authentication details when making requests to the Talis Platform.  This means that any operations that require capabilities not available to unauthenticated users will fail.</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.String)">
            <summary>
            Gets the Graph describing the given resource from the Store
            </summary>
            <param name="resourceUri">Uri of Resource to Describe</param>
            <param name="g">Graph to load the description into</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Gets the Graph describing the given resource from the Store
            </summary>
            <param name="resourceUri">Uri of Resource to Describe</param>
            <param name="g">Graph to load the description into</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Gets the Graph describing the given resource from a particular Private Graph in the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="privateGraphID">ID of the Private Graph</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Gets the Graph describing the given resource from a particular Private Graph in the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="privateGraphID">ID of the Private Graph</param>
            <param name="resourceUri">Uri of the Resource to Describe</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.DescribeInternal(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Internal implementation of the Describe function which can describe a resource at various service paths
            </summary>
            <param name="g">Graph to load description into</param>
            <param name="resourceUri">Uri of resource to describe</param>
            <param name="servicePath">Service to get the resource from</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Add(VDS.RDF.IGraph,System.String)">
            <summary>
            Adds a Graph to a Private Graph in the Store
            </summary>
            <param name="g">Graph to add</param>
            <param name="privateGraphID">Private Graph ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.AddInternal(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal implementation of adding a Graphs content to the Store
            </summary>
            <param name="g">Graph to add to the Store</param>
            <param name="servicePath">Service at the Store to add to</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Update(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates the Store
            </summary>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Update(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Private Graph in the Store
            </summary>
            <param name="privateGraphID">Private Graph ID</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.UpdateVersioned(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates the Store using a Versioned Update
            </summary>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.UpdateVersioned(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Private Graph in the Store using a Versioned Update
            </summary>
            <param name="privateGraphID">Private Graph ID</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.UpdateInternal(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.String)">
            <summary>
            Internal implementation of Updating a Store by POSTing a ChangeSet to it
            </summary>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="servicePath">Service to post ChangeSet to</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.GenerateChangeSet(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Takes lists of Triples added and removed and generates a ChangeSet Batch Graph for these
            </summary>
            <param name="additions">Triple added</param>
            <param name="removals">Triples removed</param>
            <returns>Null if there are no Changes to be persisted</returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Query(System.String)">
            <summary>
            Makes a Sparql query against the Talis Store Metabox using the Store Sparql Service
            </summary>
            <param name="query">Sparql Query</param>
            <returns>Either a Result Set or a Graph depending on the type of Sparql Query</returns>
            <remarks>The Sparql Query will be parsed locally by the internal Sparql Parser to ensure that it is a valid Query, this adds some extra overhead but potentially saves the overhead of submitting a malformed Sparql query via a <see cref="T:System.Net.HttpWebRequest">HttpWebRequest</see> to the Talis Platform</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.QueryAll(System.String)">
            <summary>
            Makes a Sparql query against the Talis Store Metabox and Private Graphs using the Store Multi-Sparql Service
            </summary>
            <param name="query">Sparql Query</param>
            <returns>Either a Result Set or a Graph depending on the type of Sparql Query</returns>
            <remarks>The Sparql Query will be parsed locally by the internal Sparql Parser to ensure that it is a valid Query, this adds some extra overhead but potentially saves the overhead of submitting a malformed Sparql query via a <see cref="T:System.Net.HttpWebRequest">HttpWebRequest</see> to the Talis Platform</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.QueryInternal(System.String,System.String)">
            <summary>
            Internal implementation of querying the Store 
            </summary>
            <param name="query">Sparql Query</param>
            <param name="servicePath">Service to Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.CreateRequest(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method which sets up the basic Request to the Talis Platform
            </summary>
            <param name="servicePath">Path to the service relative to the Base Uri for the Store</param>
            <param name="serviceParams">Querystring parameters to be added to the Request</param>
            <returns>A HTTP Request to the appropriate Talis service with authentication credentials added, no Method or other Headers are set so the calling function needs to configure the Request to perform the correct type of HTTP operation</returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Error(System.Int32,System.Net.WebException)">
            <summary>
            Helper method for determining the reason for an error received from the Talis platform based on the HTTP Response Code
            </summary>
            <param name="code">HTTP Response Code</param>
            <param name="ex">Exception to be handled</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph which is the Description of the given Uri from the Metabox of the Talis Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            If there are no Triples with the given Uri as the Subject then no Triples will be loaded into the given Graph
            <br/><br/>
            Equivalent to calling the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.String)">Describe()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph which is the Description of the given Uri from the Metabox of the Talis Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            If there are no Triples with the given Uri as the Subject then no Triples will be loaded into the given Graph
            <br/><br/>
            Equivalent to calling the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Describe(VDS.RDF.IGraph,System.String)">Describe()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph into the Metabox of the Talis Store
            </summary>
            <param name="g">Graph to save</param>
            <remarks>
            The Metabox of a Talis Store is a single Graph so the contents of the given Graph will be added to the existing content of the Metabox
            <br/><br/>
            Equivalent to calling the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Add(VDS.RDF.IGraph)">Add()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates the Metabox of the Talis Store using unversioned update
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            The Metabox of a Talis Store is a single Graph so the updates apply to the Metabox and not to a specific Graph i.e. the <paramref name="graphUri"/> parameter is ignored
            <br/><br/>
            Equivalent to calling the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Update(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">Update()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates the Metabox of the Talis Store using unversioned update
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            The Metabox of a Talis Store is a single Graph so the updates apply to the Metabox and not to a specific Graph i.e. the <paramref name="graphUri"/> parameter is ignored
            <br/><br/>
            Equivalent to calling the <see cref="M:VDS.RDF.Storage.TalisPlatformConnector.Update(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">Update()</see> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.Dispose">
            <summary>
            Disposes of the Talis Platform Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.TalisPlatformConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.TalisPlatformConnector.UpdateSupported">
            <summary>
            Indicates that Updates are supported by the Talis Platform
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.TalisPlatformConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.TalisPlatformConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.FolderStoreParams">
            <summary>
            Parameters for Folder Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Params.FolderStoreParams.#ctor(System.String,VDS.RDF.Storage.FolderStoreFormat,System.Int32)">
            <summary>
            Creates a new set of Folder Store Parameters
            </summary>
            <param name="folder">Folder</param>
            <param name="format">Format of the Folder Store</param>
            <param name="threads">Threads to use</param>
        </member>
        <member name="M:VDS.RDF.Storage.Params.FolderStoreParams.#ctor(System.String,VDS.RDF.Storage.FolderStoreFormat)">
            <summary>
            Creates a new set of Folder Store Parameters
            </summary>
            <param name="folder">Folder</param>
            <param name="format">Format of the Folder Store</param>
            <remarks>Defaults to 8 Threads</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Params.FolderStoreParams.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new set of Folder Store Parameters
            </summary>
            <param name="folder">Folder</param>
            <param name="threads">Threads to use</param>
            <remarks>Defaults to <see cref="F:VDS.RDF.Storage.FolderStoreFormat.AutoDetect">AutoDetect</see> format</remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Params.FolderStoreParams.#ctor(System.String)">
            <summary>
            Creates a new set of Folder Store Parameters
            </summary>
            <param name="folder">Folder</param>
            <remarks>Defaults to <see cref="F:VDS.RDF.Storage.FolderStoreFormat.AutoDetect">AutoDetect</see> format and 8 Threads</remarks>
        </member>
        <member name="P:VDS.RDF.Storage.Params.FolderStoreParams.Folder">
            <summary>
            Gets the Folder
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.FolderStoreParams.Format">
            <summary>
            Gets the Format
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Params.FolderStoreParams.Threads">
            <summary>
            Gets the number of Threads to use
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.FolderStoreFormat">
            <summary>
            Folder Store Formats
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.FolderStoreFormat.AutoDetect">
            <summary>
            Auto-Detect, determines format for Reading from Graph List file and defaults to Turtle for Writing
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.FolderStoreFormat.Turtle">
            <summary>
            Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.FolderStoreFormat.Notation3">
            <summary>
            Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.FolderStoreFormat.RdfXml">
            <summary>
            RDF/XML
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphCollection">
            <summary>
            Wrapper class for Graph Collections
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphCollection.DefaultGraphUri">
            <summary>
            Constant used as the URI for Default Graphs (which is the Graph with the Null Base URI) for the purposes of getting a Hash Code for the Graph URI
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphCollection._graphs">
            <summary>
            Dictionary of Graph Uri Enhanced Hash Codes to Graphs
            </summary>
            <remarks>See <see cref="M:VDS.RDF.Extensions.GetEnhancedHashCode(System.Uri)">GetEnhancedHashCode()</see></remarks>
        </member>
        <member name="F:VDS.RDF.GraphCollection._collisionGraphs">
            <summary>
            List of Graphs which handles Graphs which have Hash Code collisions
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
            <exception cref="T:VDS.RDF.RdfException">Throws an RDF Exception if the Graph has no Base Uri or if the Graph already exists in the Collection and the <paramref name="mergeIfExists"/> parameter was not set to true</exception>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.GraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <see cref="!:IGraph.Dipose">Dispose()</see> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="P:VDS.RDF.GraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ThreadSafeGraphCollection">
            <summary>
            Thread Safe Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
            <exception cref="T:VDS.RDF.RdfException">Throws an RDF Exception if the Graph has no Base Uri or if the Graph already exists in the Collection and the <paramref name="mergeIfExists"/> parameter was not set to true</exception>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <see cref="!:IGraph.Dipose">Dispose()</see> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Storage.JosekiConnector">
            <summary>
            Class for connecting to any dataset that can be exposed by Joseki (i.e. any existing Jena model)
            </summary>
            <remarks>
            <para>
            <strong>Experimental and partially untested</strong>
            </para>
            <para>
            Since Joseki can be used to expose practically any type of Jena based model via Sparql and SPARUL endpoints some/all operations may fail depending on the underlying storage model of the Joseki instance.  For example not all models support named graphs and not all Joseki instances provide full read/write capabilities.
            </para>
            <para>
            The Joseki connector permits use in a read-only mode in the event when you only specify a Query Service path to the constructor (or enter null for the Update Service path).  When instantiated in read-only mode any attempt to use the <see cref="M:VDS.RDF.Storage.JosekiConnector.SaveGraph(VDS.RDF.IGraph)">SaveGraph</see> or <see cref="M:VDS.RDF.Storage.JosekiConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph</see> methods will result in errors and the <see cref="P:VDS.RDF.Storage.JosekiConnector.UpdateSupported">UpdateSupported</see> property will return false.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Joseki server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="queryServicePath">Path to the Query Service</param>
            <param name="updateServicePath">Path to the Update Service</param>
            <remarks>
            For example the Base Uri might be <strong>http://example.org:8080/</strong> with a Query Service path of <strong>sparql</strong> and an Update Service path of <strong>update</strong>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new read only connection to a Joseki server
            </summary>
            <param name="baseUri">Base Uri of the server</param>
            <param name="queryServicePath">Path to the Query Service</param>
            <remarks>
            For example the Base Uri might be <strong>http://example.org:8080/</strong> with a Query Service path of <strong>sparql</strong>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Joseki store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Joseki store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Joseki store (appends to any existing Graph with the same URI)
            </summary>
            <param name="g">Graph to save</param>
            <remarks>
            <para>
            Contents of this Graph will be appended to any existing Graph with the same URI
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Joseki store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Joseki store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the Joseki store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.Update(System.String)">
            <summary>
            Makes a SPARQL Update against the Joseki Store
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if the connector was created in read-only mode</exception>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.Dispose">
            <summary>
            Disposes of a connection to the Joseki store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.JosekiConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.JosekiConnector.UpdateSupported">
            <summary>
            Returns whether Updates are supported by this Joseki connector
            </summary>
            <remarks>
            If the connector was instantiated in read-only mode this returns false
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.JosekiConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.JosekiConnector.IsReadOnly">
            <summary>
            Returns whether the Connection was created in read-only mode
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.FourStoreConnector">
            <summary>
            Class for connecting to 4store
            </summary>
            <remarks>
            <para>
            Depending on the version of <a href="http://librdf.org/rasqal/">RASQAL</a> used for your 4store instance and the options it was built with some kinds of queries may not suceed or return unexpected results.
            </para>
            <para>
            The default build of 4store does not permit the saving of unamed Graphs to the Store or Triple level updates.  There is a branch of 4store that supports Triple level updates and you can tell the connector if your 4store instance supports this when you instantiate it.
            </para>
            <para>
            <strong>Warning</strong> - The Triple level update support added to this connector is entirely experimental and has not been tested since I don't have time to experiment with the non-standard builds of 4store that support this feature.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.#ctor(System.String)">
            <summary>
            Creates a new 4store connector which manages access to the services provided by a 4store server
            </summary>
            <param name="baseUri">Base Uri of the 4store</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new 4store connector which manages access to the services provided by a 4store server
            </summary>
            <param name="baseUri">Base Uri of the 4store</param>
            <param name="enableUpdateSupport">Indicates to the connector that you are using a 4store instance that supports Triple level updates</param>
            <remarks>
            If you enable Update support but are using a 4store instance that does not support Triple level updates then you will almost certainly experience errors while using the connector.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the 4store instance
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the 4store instance
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <exception cref="!:RDFStorageExeception"></exception>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to a 4store instance (Warning: Completely replaces any existing Graph with the same URI)
            </summary>
            <param name="g">Graph to save</param>
            <remarks>
            <para>
            Completely replaces any existing Graph with the same Uri in the store
            </para>
            <para>
            Attempting to save a Graph which doesn't have a Base Uri will result in an error
            </para>
            </remarks>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if you try and save a Graph without a Base Uri or if there is an error communicating with the 4store instance</exception>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the store
            </summary>
            <param name="graphUri">Uri of the Graph to Update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            May throw an error since the default builds of 4store don't support Triple level updates.  There are builds that do support this and the user can instantiate the connector with support for this enabled if they wish, if they do so and the underlying 4store doesn't support updates errors will occur when updates are attempted.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the store
            </summary>
            <param name="graphUri">Uri of the Graph to Update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <remarks>
            May throw an error since the default builds of 4store don't support Triple level updates.  There are builds that do support this and the user can instantiate the connector with support for this enabled if they wish, if they do so and the underlying 4store doesn't support updates errors will occur when updates are attempted.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Query(System.String)">
            <summary>
            Makes a Sparql Query against the underlying 4store Instance
            </summary>
            <param name="sparqlQuery">Sparql Query</param>
            <returns>A <see cref="T:VDS.RDF.Graph">Graph</see> or a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see></returns>
            <remarks>
            Depending on the version of <a href="http://librdf.org/rasqal/">RASQAL</a> used and the options it was built with some kinds of queries may not suceed or return unexpected results.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.DeleteGraph(System.Uri)">
            <summary>
            Deletes a Graph from the 4store server
            </summary>
            <param name="graphUri">Uri of Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.DeleteGraph(System.String)">
            <summary>
            Deletes a Graph from the 4store server
            </summary>
            <param name="graphUri">Uri of Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Dispose">
            <summary>
            Disposes of a 4store connection
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.UpdateSupported">
            <summary>
            Returns whether this connector has been instantiated with update support or not
            </summary>
            <remarks>
            If this property returns true it does not guarantee that the 4store instance actually supports updates it simply indicates that the user has enabled updates on the connector.  If Updates are enabled and the 4store server being connected to does not support updates then errors will occur.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.SparqlServer">
            <summary>
            HTTP Handler for adding SPARQL Servers to ASP.Net applications - SPARQL Servers provide combined Query, Update and Uniform HTTP Protocol for RDF Graph Management endpoints
            </summary>
            <remarks>
            <para>
            Used to create a SPARQL Server with a base URI where any URI under this URI is handled by this Server
            </para>
            <para>
            For example given a Base URI of <strong>http://example.org/server/</strong> then the Handler would treat requests to <strong>http://example.org/server/query</strong> as SPARQL Query requests, requests to <strong>http://example.org/server/update</strong> as SPARQL Update requests and requests to any other URL covered by this base URL as SPARQL Uniform HTTP Protocol requests
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Update Endpoint:
            <code>
            &lt;dotnetrdf:/folder/server/*&gt; a dnr:HttpHandler ;
                                               dnr:type "VDS.RDF.Web.SparqlServer" ;
                                               dnr:queryProcessor _:qProc ;
                                               dnr:updateProcessor _:uProc ;
                                               dnr:protocolProcessor _:pProc .
                       
            _:qProc a dnr:SparqlQueryProcessor ;
                    dnr:type "VDS.RDF.Query.LeviathanQueryProcessor" ;
                    dnr:usingStore _:store .
            
            _:uProc a dnr:SparqlUpdateProcessor ;
                    dnr:type "VDS.RDF.Update.LeviathanUpdateProcessor" ;
                    dnr:usingStore _:store .
                   
            _:pProc a dnr:SparqlHttpProtocolProcessor ;
                    dnr:type "VDS.RDF.Update.Protocol.LeviathanProtocolProcessor" ;
                    dnr:usingStore _:store .
                   
            _:store a dnr:TripleStore ;
                    dnr:type "VDS.RDF.TripleStore" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.SparqlServer.LoadConfig(System.Web.HttpContext,System.String@)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="basePath">Base Path for the Server</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.SparqlServer.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Web.FileHandler">
            <summary>
            Handler for serving individual RDF files at a fixed path e.g. a FOAF file
            </summary>
            <remarks>
            <para>
            The configuration for this Handler is very simple, simply create an entry in the  &lt;appSettings&gt; section of your Web.config file with the path you map the Handler to as the key and the path to the file as the value e.g.
            </para>
            <pre>
            &lt;add key="/directory/name" value="~/App_Data/data.rdf" /&gt;
            </pre>
            <para>
            <strong>Note:</strong> If the file you are serving is a Schema then we strongly recommend you use the <see cref="T:VDS.RDF.Web.SchemaHandler">SchemaHandler</see> instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.FileHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            Processes the request for the File and returns a Graph
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="P:VDS.RDF.Web.FileHandler.IsReusable">
            <summary>
            Gets that the Handler is reusable
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ConfigurationLoader">
            <summary>
            The Configuration Loader is responsible for the loading of Configuration information and objects based upon information encoded in a Graph but more generally may be used for the loading of any type of object whose configuration has been loaded in a Graph and for which a relevant <see cref="!:IObjectLoader">IObjectLoader</see> is available.
            </summary>
            <remarks>
            <para></para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ConfigurationNamespace">
            <summary>
            Configuration Namespace URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyType">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUser">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPassword">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCredentials">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUseCredentialsForProxy">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyServer">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPort">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDatabase">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCatalog">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyStore">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryPath">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdatePath">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyReadOnly">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEnableUpdates">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAsync">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyLoadMode">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertySqlManager">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyGenericManager">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryProcessor">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdateProcessor">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyProtocolProcessor">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingStore">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingGraph">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromFile">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromString">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromDatabase">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromStore">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromGraph">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyWithUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAssignUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEndpoint">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEndpointUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultGraphUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyNamedGraphUri">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyProxy">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyReasoner">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyOwlReasoner">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUserGroup">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyMember">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyRequiresAuthentication">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPermissionModel">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAllow">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDeny">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAction">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyTimeout">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPartialResults">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowErrors">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyHaltOnError">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowQueryForm">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowUpdateForm">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultQueryFile">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultUpdateFile">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyIntroFile">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyStylesheet">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCacheDuration">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCacheSliding">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyExpressionFactory">
            <summary>
            QName Constants for configuration properties for use with the CreateConfigurationNode function
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassObjectFactory">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassTripleStore">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassGraph">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSqlManager">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassGenericManager">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassHttpHandler">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlEndpoint">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlQueryProcessor">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlUpdateProcessor">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlHttpProtocolProcessor">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlExpressionFactory">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassReasoner">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassOwlReasoner">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassProxy">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassUserGroup">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassUser">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassPermission">
            <summary>
            QName Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeTripleStore">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeGraph">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSqlManager">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlQueryProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlUpdateProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlHttpProtocolProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeUserGroup">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AddObjectFactory(VDS.RDF.Configuration.IObjectFactory)">
            <summary>
            Registers an Object Factory with the Configuration Loader
            </summary>
            <param name="factory">Object Factory</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoDetectObjectFactories(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph will detect Object Factories defined in the Graph and add them to the list of available factories
            </summary>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.CheckCircularReference(VDS.RDF.INode,VDS.RDF.INode,System.String)">
            <summary>
            Checks for circular references and throws an error if there is one
            </summary>
            <param name="a">Object you are attempting to load</param>
            <param name="b">Object being referenced</param>
            <param name="property">QName for the property that makes the reference</param>
            <remarks>
            <para>
            If the Object you are trying to load and the Object you need to load are equal then this is a circular reference and an error is thrown
            </para>
            <para>
            The <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> is not currently capable of detecting more subtle circular references
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.CreateConfigurationNode(VDS.RDF.IGraph,System.String)">
            <summary>
            Creates a URI Node that refers to some Configuration property/type
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="qname">QName of the property/type</param>
            <returns></returns>
            <remarks>
            <para>
            The QName provides should be of the form <strong>dnr:qname</strong> - the <strong>dnr</strong> prefix will be automatically be considered to be to the Configuration Namespace which is defined by the <see cref="F:VDS.RDF.Configuration.ConfigurationLoader.ConfigurationNamespace">ConfigurationNamespace</see> constant.
            </para>
            <para>
            This function uses caching to ensure that URI Nodes aren't needlessly recreated in order to save memory.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.ClearCache">
            <summary>
            Clears the Object Loader cache (this is not recommended)
            </summary>
            <remarks>
            <para>
            This method should only be invoked in cases where you have attempted to load an object and some error occurred which was external to dotNetRDF e.g. network connectivity problem and 
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationData(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the values given for a property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            Enumeration of values given for the property for the Object
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationNode(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the first value given for a property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            First value given for the property of the Object
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationString(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the String value or null of the first instance of a property for a given Object in the Configuration Graph where the value for the property is a Literal Node
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            <para>
            String value of the first instance of the property or a null if no values or not a literal value
            </para>
            <para>
            If you want the String value regardless of Node type then use the <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">GetConfigurationValue</see> function instead
            </para>
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the String value or null of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationBoolean(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Gets the Boolean value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid boolean value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt64(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Int64)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt32(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Int32)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetUsernameAndPassword(VDS.RDF.IGraph,VDS.RDF.INode,System.Boolean,System.String@,System.String@)">
            <summary>
            Gets the Username and Password specified for a given Object
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="allowCredentials">Whether settings may be specified using the dnr:credentials property</param>
            <param name="user">Username</param>
            <param name="pwd">Password</param>
            <remarks>
            Username and/or Password will be null if there is no value specified for the relevant properties
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.IsCached(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets whether the given Object has already been loaded and cached
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            If this returns true then loading that object again should be essentially instantaneous as it will come from the cache
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type)">
            <summary>
            Loads the Object identified by the given Node as an object of the given type based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <returns></returns>
            <remarks>
            <para>
            Callers of this method should be careful to check that the Object returned is of a usable type to them.  The Target Type parameter does not guarantee that the return value is of that type it is only used to determine which registered instances of <see cref="!:IObjectLoader">IObjectLoader</see> are potentially capable of creating the desired Object
            </para>
            <para>
            Callers should also take care that any Objects returned from this method are disposed of when the caller no longer has a use for them as otherwise the reference kept in the cache here will cause the Object to remain in-memory consuming resources
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Loads the Object identified by the given Node based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            <para>
            Use this overload when you have a Node which identifies an Object and you don't know what the type of that Object is.  This function looks up the <strong>dnr:type</strong> property for the given Object and then calls the other version of this function providing it with the relevant type information.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetDefaultType(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Attempts to find the Default Type to load an Object as when no explicit dnr:type property has been declared but an rdf:type property has been declared giving a valid Configuration Class
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> Only some configuration classes have corresponding default types, in general it is recommended that Configuration Graphs should always use the dnr:type property to explicitly state the intended type of an Object
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.ResolvePath(System.String)">
            <summary>
            Resolves a Path using the in-use path-resolver
            </summary>
            <param name="path">Path to resolve</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationLoader.PathResolver">
            <summary>
            Gets/Sets the in-use Path Resolver
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.UnloadableObject">
            <summary>
            Marker class used in the <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> Object cache to mark objects which are unloadable due to some errors to stop the loader repeatedly trying to load an Object whose configuration is invalid, incomplete or otherwise erroneous.
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.SequencePath">
            <summary>
            Represents a standard forwards path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseBinaryPath">
            <summary>
            Abstract Base Class for Binary Path operators
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._lhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._rhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Binary Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path using the given Path Evaluation Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Algebra Transform of the Path
            </summary>
            <param name="context">Transform Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.IsSimple">
            <summary>
            Gets whether the Path is simple
            </summary>
            <remarks>
            Some derived classes will need to override this appropriately since their operator will automatically imply non-simple
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.AllowsZeroLength">
            <summary>
            Gets whether the Path permits zero-length paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Sequence Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Generates the Path transform to an Algebra expression
            </summary>
            <param name="context">Transform Context</param>
        </member>
        <member name="T:VDS.RDF.Query.Paths.AlternativePath">
            <summary>
            Represents Alternative Paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Alternative Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path in the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Throws an error since a Path with alternatives is not transformable to an Algebra expression
            </summary>
            <param name="context">Transform Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.AlternativePath.IsSimple">
            <summary>
            Alternative paths are complex
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.QueryService">
            <summary>
            Represents the SPARQL Query Service provided by a Pellet Server knowledge base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.QueryService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new SPARQL Query Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.QueryService.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the Knowledge Base
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.VariableExpressionTerm">
            <summary>
            Class representing Variable value expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.#ctor(System.String)">
            <summary>
            Creates a new Variable Expression
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the Variable for the given Binding (if any)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Numeric Value of this Expression as evaluated for a given Binding (if it has a numeric value)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.NumericType(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Numeric Type of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.IntegerValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Integer Value of this Expression as evaluated for a given Binding (if it has a numeric value)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.DecimalValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Decimal Value of this Expression as evaluated for a given Binding (if it has a numeric value)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.FloatValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Float Value of this Expression as evaluated for a given Binding (if it has a numeric value)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.DoubleValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Double Value of this Expression as evaluated for a given Binding (if it has a numeric value)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.VariableExpressionTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.VariableExpressionTerm.Variables">
            <summary>
            Gets the enumeration containing the single variable that this expression term represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BooleanExpressionTerm">
            <summary>
            Class for representing Boolean Terms
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BooleanExpressionTerm.#ctor(System.Boolean)">
            <summary>
            Creates a new Boolean Expression
            </summary>
            <param name="value">Boolean value</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BooleanExpressionTerm.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Boolean Value this Expression represents as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BooleanExpressionTerm.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BooleanExpressionTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BooleanExpressionTerm.Variables">
            <summary>
            Gets an Empty enumerable since a Boolean expression term doesn't use variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Slice">
            <summary>
            Represents the Slice Operation in the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Slice
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Slice by applying the appropriate LIMIT and OFFSET to the Results
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NullMultiset">
            <summary>
            Represents a Multiset when there are no possible Solutions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Left Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression the join is predicate upon</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Exists Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether joinable solutions must exist in the other Multiset for joins to be made</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Minus Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Computes the Product of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in the Other Multiset since for Product we consider this Multiset to contain a single empty Set
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Unions this Multiset with another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in the Other Multiset as this is an empty Multiset
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Returns false since the Null Multiset contains no values
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ContainsVariable(System.String)">
            <summary>
            Returns false since the Null Multiset contains no variables
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Returns true since the Null Multiset is disjoint with all Multisets
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Add(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Adds a Set to this Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to this Multiset
            </summary>
            <param name="variable">Variable</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set from a Multiset
            </summary>
            <param name="id">Set ID</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.IsEmpty">
            <summary>
            Returns true since the Null Multiset is always empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Variables">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Sets">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.SetIDs">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Item(System.Int32)">
            <summary>
            Gets the Set with the given ID
            </summary>
            <param name="index">Set ID</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the Null Multiset contains no Sets</exception>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Graph">
            <summary>
            Represents a GRAPH clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Creates a new Graph clause
            </summary>
            <param name="pattern">Pattern</param>
            <param name="graphSpecifier">Graph Specifier</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Graph Clause by setting up the dataset, applying the pattern and then generating additional bindings if necessary
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.SubGraphMatcher">
            <summary>
            Implements a Sub-Graph Isomorphism Algorithm
            </summary>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.IsSubGraph(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Checks to see whether a given Graph is a sub-graph of the other Graph
            </summary>
            <param name="subgraph">Sub-Graph</param>
            <param name="parent">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.TryRulesBasedMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDegrees">1st Graph Degree classification</param>
            <param name="parentDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.TryBruteForceMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.INode}},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair},VDS.RDF.IGraph)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <param name="target">Target Graph (2nd Graph)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.SubGraphMatcher.Mapping">
            <summary>
            Gets the Blank Node mapping if one could be found
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleCollection">
            <summary>
            Basic Triple Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleCollection._triples">
            <summary>
            Underlying Storage of the Triple Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleCollection._collisionTriples">
            <summary>
            Underlying Storage of the Triple Collection which handles the extra Triples that result from Hash Code collisions
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleCollection.#ctor">
            <summary>
            Creates a new Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Colleciton
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.TripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given Triple does not exist in the Triple Collection</exception>
        </member>
        <member name="P:VDS.RDF.TripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="T:VDS.RDF.ThreadSafeTripleCollection">
            <summary>
            Thread Safe Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the original instance of a specific Triple from the Triple Collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.IndexedTripleCollection">
            <summary>
            A Triple Collection which trades a little load performance for improved lookup performance
            </summary>
            <remarks>
            <para>
            Uses the libaries <see cref="T:VDS.RDF.HashTable`2">HashTable</see> class for storage
            </para>
            <para>
            Indexes on Subjects, Predicates and Objects and on Subject-Predicate, Subject-Object and Predicate-Object pairs.
            </para>
            <para>
            In cases where you require minimal indexing and want to reduce memory usage you can set the <see cref="P:VDS.RDF.Options.FullTripleIndexing">Options.FullTripleIndexing</see> property to be false which disables the paired indices.  Once this is disabled any instance of this class instantiated when the option is disabled will only create basic indexes.
            </para>
            <para>
            Note: This is a change from the 0.1.x API behaviour where the <see cref="P:VDS.RDF.Options.FullTripleIndexing">FullTripleIndexing</see> option was disabled by default, from the 0.2.0 release onwards this is enabled by default.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.IndexedTripleCollection._triples">
            <summary>
            Hash Table storage of Triples
            </summary>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.#ctor">
            <summary>
            Creates a new Indexed Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection if it doesn't already exist
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.Index(VDS.RDF.Triple)">
            <summary>
            Internal method for indexing Triples as they are asserted
            </summary>
            <param name="t">Triple to index</param>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.UnIndex(VDS.RDF.Triple)">
            <summary>
            Internal method for unindexing Triples as they are retracted
            </summary>
            <param name="t">Triple to unindex</param>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple is contained in the collection
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the collection
            </summary>
            <param name="t">Triple to remove</param>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject and Object
            </summary>
            <param name="subj"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.Dispose">
            <summary>
            Disposes of a Triple collection
            </summary>
        </member>
        <member name="M:VDS.RDF.IndexedTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator of the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.IndexedTripleCollection.Count">
            <summary>
            Gets the number of Triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple from the Collection
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="!:KeyNoutFoundException">Thrown if the given Triple does not exist in the Triple Collection</exception>
        </member>
        <member name="P:VDS.RDF.IndexedTripleCollection.ObjectNodes">
            <summary>
            Gets the Object Nodes from the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedTripleCollection.PredicateNodes">
            <summary>
            Gets the Predicate Nodes from the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedTripleCollection.SubjectNodes">
            <summary>
            Gets the Subject Nodes from the collection
            </summary>
        </member>
        <member name="T:VDS.RDF.IndexedThreadSafeTripleCollection">
            <summary>
            Thread Safe Triple Collection which is also Indexed
            </summary>
            <remarks>
            Using the indexed Triple Collection requires more memory but is considerably faster for a lot of the lookup operations you would typically want to do - in essence we trade some memory consumption for performance.
            </remarks>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given Subject and Object
            </summary>
            <param name="subj"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IndexedThreadSafeTripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedThreadSafeTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedThreadSafeTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple from the Triple Collection
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given Triple does not exist in the Collection</exception>
        </member>
        <member name="P:VDS.RDF.IndexedThreadSafeTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedThreadSafeTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.IndexedThreadSafeTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BOFToken">
            <summary>
            Token which represents the Start of the Input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BOFToken.#ctor">
            <summary>
            Creates a new Beginning of File Token
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EOFToken">
            <summary>
            Token which represents the End of the Input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EOFToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new End of File Token
            </summary>
            <param name="line">Line at which the File Ends</param>
            <param name="pos">Column as which the File Ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ATToken">
            <summary>
            Token which represents the @ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ATToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new @ Token
            </summary>
            <param name="line">Line at which the @ occurs</param>
            <param name="pos">Column at which the @ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DotToken">
            <summary>
            Token which represents the . Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DotToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new . Token
            </summary>
            <param name="line">Line at which the . occurs</param>
            <param name="pos">Column at which the . occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SemicolonToken">
            <summary>
            Token which represents the ; Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SemicolonToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ; Token
            </summary>
            <param name="line">Line at which the ; occurs</param>
            <param name="pos">Column at which the ; occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CommaToken">
            <summary>
            Token which represents the , Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CommaToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new , Token
            </summary>
            <param name="line">Line at which the , occurs</param>
            <param name="pos">Column at which the , occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HashToken">
            <summary>
            Token which represents the # Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HashToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new # Token
            </summary>
            <param name="line">Line at which the # occurs</param>
            <param name="pos">Column at which the # occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnderscoreToken">
            <summary>
            Token which repreents the _ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnderscoreToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new _ Token
            </summary>
            <param name="line">Line at which the _ occurs</param>
            <param name="pos">Column at which the _ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HatHatToken">
            <summary>
            Token which represents the ^^ sequence used for Data Type specification in some RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HatHatToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ^^Token
            </summary>
            <param name="line">Line at which the ^^ occurs</param>
            <param name="pos">Column at which the ^^ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HatToken">
            <summary>
            Token which represents the ^ Character used for Reverse Path Traversal in somme RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HatToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ^ Token
            </summary>
            <param name="line">Line at which the ^ occurs</param>
            <param name="pos">Column at which the ^ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ExclamationToken">
            <summary>
            Token which represents the ! Character used for Forward Path Traversal in some RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ExclamationToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ! Token
            </summary>
            <param name="line">Line at which the ! occurs</param>
            <param name="pos">Column at which the ! occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CommentToken">
            <summary>
            Token which represents Comments
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CommentToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Comment Token
            </summary>
            <param name="value">The Comment</param>
            <param name="line">Line on which the Comment occurs</param>
            <param name="start">Column at which the Comment starts</param>
            <param name="end">Column at which the Comment ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftSquareBracketToken">
            <summary>
            Token which represents the [ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftSquareBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new [ Token
            </summary>
            <param name="line">Line at which the [ occurs</param>
            <param name="pos">Column at which the [ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightSquareBracketToken">
            <summary>
            Token which represents the ] Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightSquareBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ] Token
            </summary>
            <param name="line">Line at which the ] occurs</param>
            <param name="pos">Column at which the ] occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftBracketToken">
            <summary>
            Token which represents the ( Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ( Token
            </summary>
            <param name="line">Line at which the ( occurs</param>
            <param name="pos">Column at which the ( occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightBracketToken">
            <summary>
            Token which represents the ) Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ) Token
            </summary>
            <param name="line">Line at which the ) occurs</param>
            <param name="pos">Column at which the ) occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftCurlyBracketToken">
            <summary>
            Token which represents the { Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftCurlyBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new { Token
            </summary>
            <param name="line">Line at which the { occurs</param>
            <param name="pos">Column at which the { occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightCurlyBracketToken">
            <summary>
            Token which represents the } Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightCurlyBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new } Token
            </summary>
            <param name="line">Line at which the } occurs</param>
            <param name="pos">Column at which the } occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AssignmentToken">
            <summary>
            Token which reprsents the := Assignment Operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AssignmentToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new := Token
            </summary>
            <param name="line">Line on which the := occurs</param>
            <param name="post">Position at which the := occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.QuestionToken">
            <summary>
            Token which represents the ? Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.QuestionToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ? Token
            </summary>
            <param name="line">Line at which the ? occurs</param>
            <param name="pos">Column at which the ? occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BitwiseOrToken">
            <summary>
            Token which represents the | Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BitwiseOrToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new | Token
            </summary>
            <param name="line">Line at which the | occurs</param>
            <param name="pos">Column at which the | occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PrefixDirectiveToken">
            <summary>
            Token which represents a Prefix Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PrefixDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Prefix Direction Token
            </summary>
            <param name="line">Line at which the Prefix Directive occurs</param>
            <param name="pos">Column at which the Prefix Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PrefixToken">
            <summary>
            Token which represents the Prefix specified after a Prefix Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PrefixToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Prefix Token
            </summary>
            <param name="value">Prefix</param>
            <param name="line">Line at which the Prefix occurs</param>
            <param name="start">Column at which the Prefix starts</param>
            <param name="end">Column at which the Prefix ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseDirectiveToken">
            <summary>
            Token which represents a Base Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Base Directive Token
            </summary>
            <param name="line">Line at which the Base Directive occurs</param>
            <param name="pos">Column at which the Base Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordDirectiveToken">
            <summary>
            Token which represents a Keyword Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Keyword Directive Token
            </summary>
            <param name="line">Line at which the Keyword Directive occurs</param>
            <param name="pos">Column at which the Keyword Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ForAllQuantifierToken">
            <summary>
            Token which represents a For All Quantifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ForAllQuantifierToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new For All Quantifier Token
            </summary>
            <param name="line">Line at which the For All Quantifier occurs</param>
            <param name="pos">Column at which the For All Quantifier occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ForSomeQuantifierToken">
            <summary>
            Token which represents a For Some Quantifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ForSomeQuantifierToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new For Some Quantifier Token
            </summary>
            <param name="line">Line at which the For Some Quantifier occurs</param>
            <param name="pos">Column at which the For Some Quantifier occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UriToken">
            <summary>
            Token which represents URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UriToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Uri Token
            </summary>
            <param name="value">Value of the Uri including the &lt; &gt; deliminators</param>
            <param name="line">Line the Uri occurs on</param>
            <param name="start">Column the Uri starts at</param>
            <param name="end">Column the Uri ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.QNameToken">
            <summary>
            Token which represents QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.QNameToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new QName Token
            </summary>
            <param name="value">QName</param>
            <param name="line">Line the QName occurs on</param>
            <param name="start">Column the QName starts at</param>
            <param name="end">Column the QName ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PlainLiteralToken">
            <summary>
            Token which represents Plain (Unquoted) Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PlainLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Plain Literal Token
            </summary>
            <param name="value">Literal Value</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralToken">
            <summary>
            Token which represents Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Literal Token
            </summary>
            <param name="value">Literal Value including the Quote deliminators</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LongLiteralToken">
            <summary>
            Token which represents Long Literals (allows multi-line values)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LongLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Long Literal Token
            </summary>
            <param name="value">Literal Value including the Triple Quote deliminators</param>
            <param name="startLine">Line the Long Literal starts on</param>
            <param name="endLine">Line the Long Literal ends on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LanguageSpecifierToken">
            <summary>
            Token which represents the Language Specifier for a Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LanguageSpecifierToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Language Specifier Token
            </summary>
            <param name="value">Language Specifier</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataTypeToken">
            <summary>
            Token which represents the Data Type for a Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataTypeToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new DataType Token
            </summary>
            <param name="value">DataType Uri including the &lt; &gt; deliminators or a QName</param>
            <param name="line">Line the DataType occurs on</param>
            <param name="start">Column the DataType starts at</param>
            <param name="end">Column the DataType ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken">
            <summary>
            Token which represents Literals with Language Specifiers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Parsing.Tokens.LanguageSpecifierToken)">
            <summary>
            Creates a new Literal with Language Specifier Token
            </summary>
            <param name="lit">Literal Token</param>
            <param name="lang">Language Specifier Token</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken.Language">
            <summary>
            The Language Specifier for this Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken">
            <summary>
            Token which represents Literals with Data Types
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Parsing.Tokens.DataTypeToken)">
            <summary>
            Creates a new Literal with DataType Token
            </summary>
            <param name="lit">Literal Token</param>
            <param name="dt">DataType Token</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken.DataType">
            <summary>
            The Data Type Uri/QName for this Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GraphLiteralToken">
            <summary>
            Token which represents Graph Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GraphLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Graph Literal Token
            </summary>
            <param name="value">Value of the Graph Literal</param>
            <param name="startLine">Line the Graph Literal starts on</param>
            <param name="endLine">Line the Graph Literal ends on</param>
            <param name="startPos">Column the Graph Literal starts at</param>
            <param name="endPos">Column the Graph Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeToken">
            <summary>
            Token which represents anonymous Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Anonymous Blank Node Token
            </summary>
            <param name="line">Line the Blank Node occurs on</param>
            <param name="pos">Column the Blank Node occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeWithIDToken">
            <summary>
            Token which represents named Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeWithIDToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Blank Node Token
            </summary>
            <param name="value">ID of the Blank Node</param>
            <param name="line">Line the Blank Node occurs on</param>
            <param name="start">Column the Blank Node starts at</param>
            <param name="end">Column the Blank Node ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken">
            <summary>
            Token which represents Blank Node Collections
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken.#ctor(System.Collections.Generic.Stack{VDS.RDF.Parsing.Tokens.IToken},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Blank Node Collection Token
            </summary>
            <param name="contents">Contents of the Blank Node Collection</param>
            <param name="startline">Line the Collection starts on</param>
            <param name="endline">Line the Collection ends on</param>
            <param name="start">Column the Collection starts at</param>
            <param name="end">Column the Collection ends at</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken.Collection">
            <summary>
            The Tokens contained in the Blank Node Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordAToken">
            <summary>
            Token representing the 'a' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordAToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'a' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordIsToken">
            <summary>
            Token representing the 'is' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordIsToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'is' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordOfToken">
            <summary>
            Token representing the 'of' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordOfToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'of' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ImpliesToken">
            <summary>
            Token representing the '=>' implies Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ImpliesToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '=>' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ImpliedByToken">
            <summary>
            Token representing the '>=' implied by Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ImpliedByToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '&lt;=' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EqualityToken">
            <summary>
            Token representing the '=' equality Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EqualityToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '=' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CustomKeywordToken">
            <summary>
            Token representing the use of a Custom Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CustomKeywordToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Custom Keyword Token
            </summary>
            <param name="value">Custom Keyword</param>
            <param name="line">Line the Keyword occurs on</param>
            <param name="start">Column the Keyword starts at</param>
            <param name="end">Column the Keyword ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CustomKeywordDefinitionToken">
            <summary>
            Token representing the definition of a Custom Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CustomKeywordDefinitionToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Custom Keyword Definition Token
            </summary>
            <param name="value">Custom Keyword Definition</param>
            <param name="line">Line the Keyword occurs on</param>
            <param name="start">Column the Keyword starts at</param>
            <param name="end">Column the Keyword ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.VariableToken">
            <summary>
            Token representing Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.VariableToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Variable Token
            </summary>
            <param name="value">Variable</param>
            <param name="line">Line the Variable occurs on</param>
            <param name="start">Column the Variable starts at</param>
            <param name="end">Column the Variable ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Notation3Tokeniser">
            <summary>
            A Class for Reading an Input Stream and generating Notation 3 Tokens from it
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.ValidPlainLiteralsPattern">
            <summary>
            Pattern for Valid Plain (Unquoted) Literal Formats
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.ValidQNamesPattern">
            <summary>
            Pattern for Valid QNames that use only the Latin Alphabet
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.ValidVarNamesPattern">
            <summary>
            Patter for Valid Variable Names
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.#ctor(VDS.RDF.Parsing.BlockingStreamReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.TryGetCommentToken">
            <summary>
            Internal Helper method which attempts to get a Comment Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.IsRDFTermToken(System.Int32)">
            <summary>
            Determines whether a given Token represents an RDF Term or part thereof
            </summary>
            <param name="tokentype">Token Type to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.RemoteSparqlHandlerConfiguration">
            <summary>
            Class for storing Remote Sparql Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.RemoteSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new Remote Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.RemoteSparqlHandlerConfiguration.EndpointURI">
            <summary>
            Uri of the Remote Endpoint
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.RemoteSparqlHandler">
            <summary>
            A HTTP Handler for Sparql Queries where the Sparql Endpoint is provided by some remote Endpoint
            </summary>
            <remarks>
            <para>
            Effectively acts as a gateway to a Remote Endpoint, queries are executed against the endpoint and the raw Response Stream received is passed directly back to the Client.
            </para>
            <para>
            This Handler supports registering the Handler multiple times in one Web application with each able to use its own settings.
            </para>
            <para>
            Each Handler registered in Web.config may have a prefix for their Configuration variables set by adding a AppSetting key using the virtual path of the handler like so:
            <code>&lt;add key="/virtualRoot/sparql/" value="ABC" /&gt;</code>
            Then when the Handler at that path is invoked it will look for Configuration variables prefixed with that name.
            </para>
            <para>
            The following Configuration Variables are supported in addition to those supported by the <see cref="T:VDS.RDF.Web.BaseSparqlHandler">BaseSparqlHandler</see>:
            </para>
            <ul>
            <li><strong>EndpointURI</strong> (<em>Required</em>) - Sets the Remote Sparql Endpoint Uri to which queries will be sent for processing.</li>
            <li><strong>SupportsTimeout</strong> (<em>Optional</em>) - Sets whether the Remote Endpoint supports specifying a query timeout.  Defaults to false (Disabled).  If Timeout is not supported then the Handler will simulate the ability to set a Timeout by setting a HTTP Timeout on the HTTP request to the remote endpoint, in this mode partial results behaviour is not supported.</li>
            <li><strong>TimeoutField</strong> (<em>Optional</em>) - Sets the querystring field name used to specify the timeout when supported, defaults to <em>timeout</em></li>
            <li><strong>SupportsPartialResults</strong> (<em>Optional</em>) - Sets whether the Remote Endpoint supports specifying the partial results behaviour in the event of a query timeout.  Defaults to false (disabled)</li>
            <li><strong>PartialResultsField</strong> (<em>Optional</em>) - Sets the querystring field name used to specify the partial results behaviour when supported, defaults to <em>partialResults</em></li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.RemoteSparqlHandler.ProcessQuery(System.Web.HttpContext,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int64,System.Boolean)">
            <summary>
            Processes a Query by sending a HTTP Request to a Remote Sparql Endpoint and passing the raw response stream back to the Client
            </summary>
            <param name="context">Context of the HTTP Request</param>
            <param name="query">Sparql Query</param>
            <param name="userDefaultGraphs">User specified default Graph(s)</param>
            <param name="userNamedGraphs">User specified names Graph(s)</param>
            <param name="timeout">User specified timeout</param>
            <param name="partialResults">Partial Results setting</param>
            <remarks>
            The HTTP Accept header passed to the remote endpoint will be the same Accept header which this Handler receives.  If the remote endpoint does content negotiation correctly the Client should get the results in a format they can understand
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.RemoteSparqlHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Configuration for the Handler
            </summary>
            <param name="context">Context of the HTTP Request</param>
        </member>
        <member name="T:VDS.RDF.NonIndexedGraph">
            <summary>
            Class for representing RDF Graphs when you don't want Indexing
            </summary>
            <remarks>
            Gives better load performance but poorer lookup performance
            </remarks>
        </member>
        <member name="M:VDS.RDF.NonIndexedGraph.#ctor">
            <summary>
            Creates a new Graph which is not indexed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlXmlParser">
            <summary>
            Parser for SPARQL Results XML Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.#ctor">
            <summary>
            Creates a new SPARQL Results XML Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Loads a Result Set from a File
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="filename">File to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.Query.SparqlResultSet,System.Xml.XmlDocument)">
            <summary>
            Loads a Result Set from an XML Document
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="doc">XML Document</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Parse(System.Xml.XmlDocument,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Parses the XML Result Set format into a set of SPARQLResult objects
            </summary>
            <param name="xmlDoc">XML Document to parse from</param>
            <param name="results">Result Set to parse into</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.ParseValue(System.Xml.XmlNode)">
            <summary>
            Internal Helper method which parses the child element of a &lt;binding&gt; element into an <see cref="T:VDS.RDF.INode">INode</see>
            </summary>
            <param name="valueNode">An XML Node representing the value bound to a Variable for a given Binding</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Notation3Writer">
            <summary>
            Class for generating Notation 3 Concrete RDF Syntax which provides varying levels of Syntax Compression
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.#ctor">
            <summary>
            Creates a new Notation 3 Writer which uses the Default Compression Level
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.#ctor(System.Int32)">
            <summary>
            Creates a new Notation 3 Writer which uses the given Compression Level
            </summary>
            <param name="compressionLevel">Desired Compression Level</param>
            <remarks>See Remarks for this classes <see cref="P:VDS.RDF.Writing.Notation3Writer.CompressionLevel">CompressionLevel</see> property to see what effect different compression levels have</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves a Graph to a file using Notation 3 Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to the given Stream using Notation 3 Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext)">
            <summary>
            Generates the Notation 3 Syntax for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateTripleOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Generates Output for Triples as a single "s p o." Triple
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to output</param>
            <returns></returns>
            <remarks>Used only in High Speed Write Mode</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateNodeOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for Nodes in Notation 3 syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being output</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateCollectionOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Writing.OutputRDFCollection)">
            <summary>
            Internal Helper method which converts a Collection into Notation 3 Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="c">Collection to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.OnWarning(System.String)">
            <summary>
            Helper method for generating Parser Warning Events
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode should be allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level to be used
            </summary>
            <remarks>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.None">None</see> then High Speed mode will always be used regardless of the input Graph and the <see cref="P:VDS.RDF.Writing.Notation3Writer.HighSpeedModePermitted">HighSpeedMorePermitted</see> property.
            </para>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.Minimal">Minimal</see> or above then full Predicate Object lists will be used for Triples.
            </para>
            <para>
            If the Compression Level is set to <see cref="!:WriterCompressionLevels.More">More</see> or above then Blank Node Collections and Collection syntax will be used if the Graph contains Triples that can be compressed in that way.</para>
            </remarks>
        </member>
        <member name="E:VDS.RDF.Writing.Notation3Writer.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the Graph being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.TurtleWriterContext">
            <summary>
            Writer Context for Turtle Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.GetBlankNodeOutputID(System.String)">
            <summary>
            Gets the ID that should be used to output a Blank Node as Turtle
            </summary>
            <param name="id">Blank Node ID</param>
            <returns></returns>
            <remarks>
            If the Blank Node ID would not be valid in Turtle syntax it gets remapped appropriately
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.FormatBlankNode(VDS.RDF.BlankNode,VDS.RDF.Writing.NodeFormat)">
            <summary>
            Formats a Blank Node as a String for Turtle
            </summary>
            <param name="b">Blank Node to format</param>
            <param name="format">Format to output in</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext">
            <summary>
            Writer Context for Compressing Turtle Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.Collections">
            <summary>
            Represents the mapping from Blank Nodes to Collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.TriplesDone">
            <summary>
            Stores the Triples that should be excluded from standard output as they are part of collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticRdfsReasoner">
            <summary>
            An Inference Engine which uses RDFS reasoning
            </summary>
            <remarks>
            <para>
            Does basic RDFS inferencing using the schema taken from the Graph(s) which are provided in calls to the reasoners <see cref="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Initialise(VDS.RDF.IGraph)">Initialise()</see> method.
            </para>
            <para>
            Types of inference performed are as follows:
            </para>
            <ul>
                <li>Class hierarchy reasoning - asserts additional types triples for anything that is typed as the subclass of a class.</li>
                <li>Property hierarchy reasoning - asserts additional property triples for anything where the predicate is a subproperty of a defined property</li>
                <li>Domain &amp; Range reasoning - asserts additional type triples based on the domains and ranges of properties</li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.#ctor">
            <summary>
            Creates a new instance of the Static RdfsReasoner
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Initialise(VDS.RDF.IGraph)">
            <summary>
            Imports any Class heirarchy information from the given Graph into the Reasoners Knowledge Base in order to initialise the Reasoner
            </summary>
            <param name="g">Graph to import from</param>
            <remarks>
            Looks for Triples defining things to be classes and those defining that something is a subClass of something
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.InferClasses(VDS.RDF.Triple,VDS.RDF.IGraph,System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Helper method which applies Class hierarchy inferencing
            </summary>
            <param name="t">Triple defining the type for something</param>
            <param name="input">Input Graph</param>
            <param name="inferences">List of Inferences</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.RdfsReasoner">
            <summary>
            An Inference Engine which uses RDFS reasoning
            </summary>
            <remarks>
            Does basic RDFS inferencing as detailed in the remarks for the <see cref="T:VDS.RDF.Query.Inference.StaticRdfsReasoner">StaticRdfsReasoner</see> except every Graph that inference is applied to has the potential to alter the schema which is in use.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.RdfsReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Protocol.BaseProtocolHandlerConfiguration">
            <summary>
            Abstract Base Class for representing SPARQL Uniform HTTP Protocol for Graph Management Handler configurations
            </summary>
        </member>
        <member name="F:VDS.RDF.Web.Configuration.Protocol.BaseProtocolHandlerConfiguration._processor">
            <summary>
            Protocol processor
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Protocol.BaseProtocolHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Protocol Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Protocol.BaseProtocolHandlerConfiguration.Processor">
            <summary>
            Gets the SPARQL Uniform HTTP Protocol for Graph Management processor which is to be used
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Protocol.ProtocolHandlerConfiguration">
            <summary>
            A basic Protocol Handler Configuration implentation
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Protocol.ProtocolHandlerConfiguration.#ctor(System.Web.HttpContext,VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Creates a new Protocol Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.LoadCommand">
            <summary>
            Represents the SPARQL Update LOAD command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a new LOAD command
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
            <param name="graphUri">Target URI for the Graph to store data in</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri)">
            <summary>
            Creates a new LOAD command which operates on the Default Graph
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.SourceUri">
            <summary>
            Gets the URI that data is loaded from
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to load data into
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BindingsPattern">
            <summary>
            Represents a set of Bindings for a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Bindings Pattern
            </summary>
            <param name="vars">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.AddTuple(VDS.RDF.Query.Patterns.BindingTuple)">
            <summary>
            Adds a Tuple to the Bindings pattern
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.Accepts(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Gets whether the given Set can be matched with a Tuple
            </summary>
            <param name="s">Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.ToAlgebra">
            <summary>
            Gets the Algebra representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.Variables">
            <summary>
            Gets the enumeration of Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.Tuples">
            <summary>
            Gets the enumeration of Tuples
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BindingTuple">
            <summary>
            Represents a Tuple in a BINDINGS clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingTuple.#ctor(System.Collections.Generic.List{System.String},System.Collections.Generic.List{VDS.RDF.Query.Patterns.PatternItem})">
            <summary>
            Creates a new Binding Tuple
            </summary>
            <param name="variables">Variables</param>
            <param name="values">Values</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingTuple.ToString">
            <summary>
            Gets the String representation of the Tuple
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.Values">
            <summary>
            Gets the enumeration of Variable-Value pairs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.Item(System.String)">
            <summary>
            Gets the Value for a Variable
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.RealizeService">
            <summary>
            Represents the Realize Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.RealizeService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Realize Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.RealizeService.Realize">
            <summary>
            Gets the Graph which comprises the class hierarchy and individuals of those classes
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService">
            <summary>
            Represents the Consistency Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Consistency Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService.IsConsistent">
            <summary>
            Returns whether the Knowledge Base is consistent
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Project">
            <summary>
            Represents the Projection step of Query Evaluation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Project.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Projection
            </summary>
            <param name="pattern">Inner pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Project.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Projection to the results of Evaluating the Inner Pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Project.ToString">
            <summary>
            Gets the String representation of the Projection
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Select">
            <summary>
            Represents the Selection step of Query Evaluation
            </summary>
            <remarks>
            Selection trims variables from the Multiset that are not needed in the final output.  This is separate from <see cref="T:VDS.RDF.Query.Algebra.Project">Project</see> so that all Variables are available for Ordering and Having clauses
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Select
            </summary>
            <param name="pattern">Inner Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Trims the Results of evaluating the inner pattern to remove Variables which are not Result Variables
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Ask">
            <summary>
            Represents the Ask step of Query Evaluation
            </summary>
            <remarks>
            Used only for ASK queries.  Turns the final Multiset into either an <see cref="T:VDS.RDF.Query.Algebra.IdentityMultiset">IdentityMultiset</see> if the ASK succeeds or a <see cref="T:VDS.RDF.Query.Algebra.NullMultiset">NullMultiset</see> if the ASK fails
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new ASK
            </summary>
            <param name="pattern">Inner Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the ASK by turning the Results of evaluating the Inner Pattern to either an Identity/Null Multiset depending on whether there were any Results
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.ToString">
            <summary>
            Gets the String representation of the Ask
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ExistsJoin">
            <summary>
            Represents a LeftJoin predicated on the existence/non-existence of joinable sets on the RHS for each item on the LHS
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Boolean)">
            <summary>
            Creates a new Exists Join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
            <param name="mustExist">Whether a joinable set must exist on the RHS for the LHS set to be preserved</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates an ExistsJoin
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.LeftJoin">
            <summary>
            Represents a LeftJoin predicated on an arbitrary filter expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new LeftJoin where there is no Filter over the join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new LeftJoin where there is a Filter over the join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
            <param name="filter">Filter to decide which RHS solutions are valid</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the LeftJoin
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Join">
            <summary>
            Represents a Join
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Join
            </summary>
            <param name="lhs">Left Hand Side</param>
            <param name="rhs">Right Hand Side</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.CreateJoin(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates either a Join or returns just one of the sides of the Join if one side is the empty BGP
            </summary>
            <param name="lhs">Left Hand Side</param>
            <param name="rhs">Right Hand Side</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evalutes a Join
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.ToString">
            <summary>
            Gets the String representation of the Join
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Union">
            <summary>
            Represents a Union
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Union
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Notation3Parser">
            <summary>
            Parser for Notation 3 syntax
            </summary>
            <remarks>
            <para>
            This is a newly implemented parser as of 11/12/2009 - it was rewritten from scratch in order to remove an issue with Blank Node Handling which could not be solved with the old parser.  The code is now around a third the size, parses faster and appears to be bug free so far!
            </para>
            <para>
            As with the previous Parser @forSome and @forAll directives are in effect ignored and variables are treated simply as QNames in the default namespace.
            </para>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="F:VDS.RDF.Parsing.Notation3Parser.ImpliesUri">
            <summary>
            The Uri for log:implies
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Notation3Parser.SameAsUri">
            <summary>
            The Uri for owl:sameAs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.#ctor">
            <summary>
            Creates a new Notation 3 Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Notation 3 Parser which uses the given Token Queue Mode
            </summary>
            <param name="queueMode">Queue Mode for Tokenising</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Loads a Graph by reading Notation 3 syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph by reading Notation 3 syntax from the given file
            </summary>
            <param name="g">Graph to load into</param>
            <param name="filename">File to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Parse(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Internal method which does the parsing of the input
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseDirective(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse declarations
            </summary>
            <param name="context">Parse Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseForAll(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse forAll quantifiers
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseForSome(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse forSome quantifiers
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseTriples(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParsePredicateObjectList(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Predicate Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Predicate Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseObjectList(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode,VDS.RDF.INode,System.Boolean,System.Boolean)">
            <summary>
            Tries to parse Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="pred">Predicate of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Object list</param>
            <param name="reverse">Indicates whether the asserted triples should have it's subject and object swapped</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseCollection(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode)">
            <summary>
            Tries to parse Collections
            </summary>
            <param name="context">Parser Context</param>
            <param name="firstSubj">Blank Node which is the head of the collection</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseGraphLiteral(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse a Graph Literal
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseLiteral(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Tries to parse Literal Tokens into Literal Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="lit">Literal Token</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.OnWarning(System.String)">
            <summary>
            Helper method which raises the Warning event if there is an event handler registered
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:VDS.RDF.Parsing.Notation3Parser.TraceParsing">
            <summary>
            Gets/Sets whether Parsing Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Notation3Parser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Trace is written to the Console
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.Notation3Parser.Warning">
            <summary>
            Event which is raised when the parser detects issues with the input which are non-fatal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.Notation3ParserContext">
            <summary>
            Parser Context for Notation 3 Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Notation 3 Parser Context with default settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.PushGraph">
            <summary>
            Pushes the current in-scope Graph onto the Graph stack and creates a new empty Graph to be the in-scope Graph
            </summary>
            <remarks>
            Used for Graph Literal parsing - Base Uri and Namespace Maps of the outermost Graph is propogated to the innermost Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.PopGraph">
            <summary>
            Pops a Graph from the Graph stack to become the in-scope Graph
            </summary>
            <remarks>
            Used for Graph Literal parsing
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.KeywordsMode">
            <summary>
            Gets/Sets whether Keywords Mode is in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.Keywords">
            <summary>
            Gets the list of in-use Keywords
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.GraphLiteralMode">
            <summary>
            Gets whether the Context is currently for a Graph Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyHelper">
            <summary>
            Static Helper class for the Ontology API
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyVersionInfo">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySameAs">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDifferentFrom">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyEquivalentClass">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDisjointWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyEquivalentProperty">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyInverseOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyBackwardCompatibleWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyIncompatibleWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyPriorVersion">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyImports">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyComment">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyLabel">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySeeAlso">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyIsDefinedBy">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySubClassOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySubPropertyOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyRange">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDomain">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyType">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.RdfsClass">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlClass">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.RdfsProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlObjectProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlDataProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlAnnotationProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlOntology">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphMatcher">
            <summary>
            Implements a Graph Isomorphism Algorithm
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.Equals(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Compares two Graphs for equality
            </summary>
            <param name="g">Graph</param>
            <param name="h">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.TryRulesBasedMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="gDegrees">1st Graph Degree classification</param>
            <param name="hDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.TryBruteForceMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.INode}},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair},VDS.RDF.IGraph)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <param name="target">Target Graph (2nd Graph)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.GraphMatcher.Mapping">
            <summary>
            Gets the Blank Node Mapping found between the Graphs
            </summary>
        </member>
        <member name="T:VDS.RDF.MappingPair">
            <summary>
            Represents a Pair of Nodes that occur in the same Triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.UriLoader">
            <summary>
            A Class for dereferencing URIs and attempting to parse the results of a HTTP GET request to the Uri into RDF
            </summary>
            <remarks>
            <para>
            As of the 0.2.2 release the loader has support for caching retrieved data locally built into it (for Graphs only), caching is done using ETags where the remote server provides them or just by a user-defineable 'freshness' criteria (i.e. number of hours retrieved resources should be cached for).  By default this caching happens in the system temporary directory which means it is non-persistent i.e. if you run your application using dotNetRDF it may cache stuff during the session but once the application is closed the operating system may freely delete the cached data.  If you wish to have a persistent cache then you can use the <see cref="P:VDS.RDF.Parsing.UriLoader.CacheDirectory">CacheDirectory</see> property to set your own cache directory.  Even when you set your own cache directory dotNetRDF will delete obsolete data from it over time though this will only happen when a new request invalidates previously cached data.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Attempts to load a RDF Graph from the given URI into the given Graph
            </summary>
            <param name="g">Graph to assert Triples in</param>
            <param name="u">Uri to attempt to get RDF from</param>
            <remarks>
            <para>
            Attempts to select the relevant Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If you know ahead of time the Content Type you can just open a HTTP Stream yourself and pass it to an instance of the correct Parser.
            </para>
            <para>
            In the event that the URI is a File URI the <see cref="T:VDS.RDF.Parsing.FileLoader">FileLoader</see> will be used instead.  If the URI is a Data URI then the <see cref="T:VDS.RDF.Parsing.DataUriLoader">DataUriLoader</see> will be used instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IGraph,System.Uri,VDS.RDF.IRdfReader)">
            <summary>
            Attempts to load a RDF Graph from the given Uri into the given Graph
            </summary>
            <param name="g">Graph to assert Triples in</param>
            <param name="u">Uri to attempt to get RDF from</param>
            <param name="parser">Parser to use</param>
            <remarks>
            <para>
            Uses the supplied parser to attempt parsing regardless of the actual Content Type returned
            </para>
            <para>
            In the event that the Uri is a File Uri the <see cref="T:VDS.RDF.Parsing.FileLoader">FileLoader</see> will be used instead
            </para>
            <para>
            If the URI is a Data URI then the <see cref="T:VDS.RDF.Parsing.DataUriLoader">DataUriLoader</see> will be used instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.ITripleStore,System.Uri)">
            <summary>
            Attempts to load a RDF dataset from the given Uri into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="u">Uri to attempt to get a RDF dataset from</param>
            <remarks>
            <para>
            Attempts to select the relevant Store Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If you know ahead of time the Content Type you can just open a HTTP Stream yourself and pass it to an instance of the correct Store Parser.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.OnWarning(System.String)">
            <summary>
            Raises warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.OnStoreWarning(System.String)">
            <summary>
            Raises store warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Parsing.UriLoader.CacheDirectory">
            <summary>
            Gets/Sets the Directory used for caching Graphs loaded from URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.UriLoader.CacheDuration">
            <summary>
            Gets/Sets the amount of time Graphs are cached for
            </summary>
            <remarks>
            This duration only applies to URIs which don't return an ETag as part of the HTTP response when they are deferenced
            </remarks>
        </member>
        <member name="E:VDS.RDF.Parsing.UriLoader.Warning">
            <summary>
            Event which is raised when a parser that is invoked by the UriLoader notices a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.UriLoader.StoreWarning">
            <summary>
            Event which is raised when a store parser that is invoked by the UriLoader notices a non-fatal issue with the RDF dataset syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.DataUriLoader">
            <summary>
            A Class for parsing RDF data from Data URIs
            </summary>
            <remarks>
            <para>
            Data URIs use the data: scheme and are defined by the IETF in <a href="http://tools.ietf.org/html/rfc2397">RFC 2397</a> and provide a means to embed data directly in a URI either in Base64 or ASCII encoded format.  This class can extract the data from such URIs and attempt to parse it as RDF using the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see>
            </para>
            <para>
            The parsing process for data: URIs involves first extracting and decoding the data embedded in the URI - this may either be in Base64 or ASCII encoding - and then using the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> to actually parse the data string.  If the data: URI defines a MIME type then a parser is selected (if one exists for the given MIME type) and that is used to parse the data, in the event that no MIME type is given or the one given does not have a corresponding parser then the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> will use its basic heuristics to attempt to auto-detect the format and select an appropriate parser.
            </para>
            <para>
            If you attempt to use this loader for non data: URIs then the standard <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> is used instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.DataUriLoader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads RDF data into a Graph from a data: URI
            </summary>
            <param name="g">Graph to load into</param>
            <param name="u">URI to load from</param>
            <remarks>
            Invokes the normal <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> instead if a the URI provided is not a data: URI
            </remarks>
            <exception cref="T:System.UriFormatException">Thrown if the metadata portion of the URI which indicates the MIME Type, Character Set and whether Base64 encoding is used is malformed</exception>
        </member>
        <member name="T:VDS.RDF.Writing.NTriplesWriter">
            <summary>
            Class for generating RDF in NTriples Concrete Syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.Save(VDS.RDF.IGraph,System.String)">
            <summary>
            Saves the Graph in NTriples Syntax to the given stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves the Graph in NTriples Syntax to the given stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.TripleToNTriples(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Converts a Triple into relevant NTriples Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.NodeToNTriples(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Converts a Node into relevant NTriples Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to convert</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="P:VDS.RDF.Writing.NTriplesWriter.SortTriples">
            <summary>
            Gets/Sets whether Triples are sorted before being Output
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.NTriplesWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graph being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SqlStoreWriter">
            <summary>
            Class for storing entire Triple Stores into SQL backed Storage
            </summary>
            <remarks>Uses single threaded writing which will be very slow for large Triple Stores, use a <see cref="T:VDS.RDF.Writing.ThreadedSqlStoreWriter">ThreadedSqlStoreWriter</see> for large Stores</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.SqlStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves the given Triple Store to the SQL Store that this class was instantiated with
            </summary>
            <param name="store">Store you wish to Save</param>
            <param name="parameters">Parameters for the Store</param>
        </member>
        <member name="E:VDS.RDF.Writing.SqlStoreWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.ThreadedSqlStoreWriter">
            <summary>
            Class for storing entire Triple Stores into SQL backed Storage which uses multi-threaded writing for improved write speeds
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.ThreadedSqlStoreWriter.Save(VDS.RDF.ITripleStore,VDS.RDF.Storage.Params.IStoreParams)">
            <summary>
            Saves the given Triple Store to the Target Store that this class was instantiated with
            </summary>
            <param name="store">Store to Save</param>
            <param name="parameters">Parameters for the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.ThreadedSqlStoreWriter.WriteGraphs(VDS.RDF.Writing.Contexts.ThreadedSqlStoreWriterContext)">
            <summary>
            Internal Worker method for Writer Threads
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.ThreadedSqlStoreWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Writing.ThreadedSqlStoreWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Translation.SimpleTranslator">
            <summary>
            Class which provides a Naive implementation of a Translator as a wrapper to a supplied Reader and Writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Translation.SimpleTranslator.#ctor(VDS.RDF.IRdfReader,VDS.RDF.IRdfWriter)">
            <summary>
            Creates a new Translator using the supplied Reader and Writer
            </summary>
            <param name="reader">The Reader to use for Parsing the Input</param>
            <param name="writer">The Writer to use for Writing the Output</param>
        </member>
        <member name="M:VDS.RDF.Translation.SimpleTranslator.Translate(System.String,System.String)">
            <summary>
            Translates the RDF in one file into RDF in the other file using the Reader and Writer this class was instantiated with
            </summary>
            <param name="fileIn">Filename of the Input File</param>
            <param name="fileOut">Filename of the Output File</param>
            <remarks>Open streams for both files then uses the overloaded version which takes two streams to do the actual translation</remarks>
        </member>
        <member name="M:VDS.RDF.Translation.SimpleTranslator.Translate(System.String,System.IO.StreamWriter)">
            <summary>
            Translates the RDF in one file into RDF to the Stream using the Reader and Writer this class was instantiated with
            </summary>
            <param name="fileIn">Filename of the Input File</param>
            <param name="output">Stream to write the Output RDF to</param>
            <remarks>Open streams for the input file then uses the overloaded version which takes two streams to do the actual translation</remarks>
        </member>
        <member name="M:VDS.RDF.Translation.SimpleTranslator.Translate(System.IO.StreamReader,System.String)">
            <summary>
            Translates the RDF in the Stream into RDF in the file using the Reader and Writer this class was instantiated with
            </summary>
            <param name="input">Stream to read the Input RDF from</param>
            <param name="fileOut">Filename of the Output File</param>
            <remarks>Open streams for the input file then uses the overloaded version which takes two streams to do the actual translation</remarks>
        </member>
        <member name="M:VDS.RDF.Translation.SimpleTranslator.Translate(System.IO.StreamReader,System.IO.StreamWriter)">
            <summary>
            Translates the RDF from one Stream into RDF in the other Stream using the Reader and Writer this class was instantiated with
            </summary>
            <param name="input">Stream to read the Input RDF from</param>
            <param name="output">Stream to write the Output RDF to</param>
        </member>
        <member name="T:VDS.RDF.Web.SqlSparqlHandlerConfiguration">
            <summary>
            Class for Storing Sparql Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.SqlSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.SqlSparqlHandlerConfiguration.LoadMode">
            <summary>
            Gets the Load Mode that controls how the Handler loads the Store into memory
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.SqlSparqlHandlerConfiguration.Manager">
            <summary>
            Gets the Manager used for the Database
            </summary>
        </member>
        <member name="T:VDS.RDF.OnDemandTripleStore">
            <summary>
            Class for representing Triple Stores which are collections of RDF Graphs
            </summary>
            <remarks>
            The 'On Demand' Triple Store is a <strong>read-only</strong> view of a SQL Based Store which loads Graphs as required rather than loading everything ahead of time.  This makes for a much more responsive Triple Store class though it does mean that SPARQL queries will generally only operate over a subset of the Store.
            <br /><br />
            Users of this class should be aware of the implications of the <strong>read-only</strong> nature of this Store.  Although it represents a view of a SQL Based Store changes made to either the Store (adding/removing Graphs) or to individual Graphs are <strong>never</strong> persisted to the backing Store.
            </remarks>
        </member>
        <member name="M:VDS.RDF.OnDemandTripleStore.#ctor(VDS.RDF.Storage.ISqlIOManager,System.Uri)">
            <summary>
            Opens an On Demand SQL Triple Store using the provided Store Manager
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen backing SQL Store</param>
            <param name="defaultGraphUri">A Uri for the Default Graph which should be loaded from the backing Store</param>
        </member>
        <member name="M:VDS.RDF.OnDemandTripleStore.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Opens an On Demand SQL Triple Store using the provided Store Manager
            </summary>
            <param name="manager">An <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> for your chosen backing SQL Store</param>
        </member>
        <member name="M:VDS.RDF.OnDemandTripleStore.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Opens an On Demand SQL Triple Store using the default Manager for a dotNetRDF Store accessible at the given database settings
            </summary>
            <param name="dbserver">Database Server</param>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
        </member>
        <member name="M:VDS.RDF.OnDemandTripleStore.#ctor(System.String,System.String,System.String)">
            <summary>
            Opens an On Demand SQL Triple Store using the default Manager for a dotNetRDF Store accessible at the given database settings
            </summary>
            <param name="dbname">Database Name</param>
            <param name="dbuser">Database User</param>
            <param name="dbpassword">Database Password</param>
            <remarks>Assumes that the Store is located on the localhost</remarks>
        </member>
        <member name="T:VDS.RDF.OnDemandGraphCollection">
            <summary>
            A Graph Collection connected to a backing SQL Store where Graphs can be loaded on-demand from the Store as needed
            </summary>
        </member>
        <member name="F:VDS.RDF.OnDemandGraphCollection._store">
            <summary>
            Reference back to the Store that this is a GraphCollection for
            </summary>
        </member>
        <member name="F:VDS.RDF.OnDemandGraphCollection._manager">
            <summary>
            The Manager for the underlying SQL Store
            </summary>
        </member>
        <member name="F:VDS.RDF.OnDemandGraphCollection._sqlreader">
            <summary>
            A Reader which reads Graphs from the underlying SQL Store
            </summary>
        </member>
        <member name="M:VDS.RDF.OnDemandGraphCollection.#ctor(VDS.RDF.Storage.ISqlIOManager,VDS.RDF.ITripleStore)">
            <summary>
            Creates a new On Demand Graph Collection which loads Graphs from a backing SQL Store on demand
            </summary>
            <param name="manager">Manager for the SQL Store</param>
            <param name="store">Store this is a Graph Collection for (may be null if not associated with a Store)</param>
        </member>
        <member name="M:VDS.RDF.OnDemandGraphCollection.#ctor(VDS.RDF.Storage.ISqlIOManager)">
            <summary>
            Creates a new On Demand Graph Collection which loads Graphs from a backing SQL Store on demand
            </summary>
            <param name="manager">Manager for the SQL Store</param>
        </member>
        <member name="M:VDS.RDF.OnDemandGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection.  If it doesn't but is in the backing Store it will be loaded into the Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.OnDemandGraphCollection.Load(System.Uri)">
            <summary>
            Loads the specified Graph into the Graph Collection
            </summary>
            <param name="graphUri"></param>
        </member>
        <member name="M:VDS.RDF.OnDemandGraphCollection.Dispose">
            <summary>
            Disposes of a On Demand Graph Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlCsvWriter">
            <summary>
            Class for saving SPARQL Result Sets to CSV format (not a standardised format)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlCsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves a SPARQL Result Set to CSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlCsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves a SPARQL Result Set to CSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="T:VDS.RDF.Query.BindingGroup">
            <summary>
            Represents an Group of Bindings which is used when executing Queries with GROUP BY clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.Add(System.Int32)">
            <summary>
            Adds a Binding ID to the Group
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.GetEnumerator">
            <summary>
            Gets the Enumerator for the Binding IDs in the Group
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Binding IDs in the Group
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.BindingGroup.BindingIDs">
            <summary>
            Gets the Binding IDs in the Group
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.SqlManagerFactory">
            <summary>
            Factory class for producing <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> instances from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.SqlManagerFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SQL IO Manager based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.SqlManagerFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.GenericManagerFactory">
            <summary>
            Factory class for producing <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> instances from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.GenericManagerFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Generic IO Manager based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.GenericManagerFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DeleteDataCommand">
            <summary>
            Represents a SPARQL Update DELETE DATA command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new DELETE DATA command
            </summary>
            <param name="pattern">Pattern composed of concrete Triples to delete</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteDataCommand.DataPattern">
            <summary>
            Gets the Data Pattern containing Triples to delete
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathAbsoluteFunction">
            <summary>
            Represents the XPath fn:abs() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathAbsoluteFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Absolute function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathAbsoluteFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathAbsoluteFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathCeilingFunction">
            <summary>
            Represents the XPath fn:ceiling() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCeilingFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Ceiling function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCeilingFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathCeilingFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathFloorFunction">
            <summary>
            Represents the XPath fn:floor() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloorFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Floor function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloorFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathFloorFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathRoundFunction">
            <summary>
            Represents the XPath fn:round() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Round function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPathRoundHalfToEvenFunction">
            <summary>
            Represents the XPath fn:round-half-to-even() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundHalfToEvenFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Round Half to Even function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundHalfToEvenFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Round Half to Even function
            </summary>
            <param name="expr">Expression</param>
            <param name="precision">Precision for the Rouding</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundHalfToEvenFunction.NumericValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPathRoundHalfToEvenFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.SearchService">
            <summary>
            Represents the Search Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Search Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchService.Search(System.String)">
            <summary>
            Gets the list of Search Results which match the given search term
            </summary>
            <param name="text">Search Term</param>
            <returns>A list of Search Results representing Nodes in the Knowledge Base that match the search term</returns>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult">
            <summary>
            Represents a Search Result returned from the
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.#ctor(VDS.RDF.INode,System.Double)">
            <summary>
            Creates a new Search Service Result
            </summary>
            <param name="node">Result Node</param>
            <param name="score">Result Score</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.ToString">
            <summary>
            Gets the String representation of the Result
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.Node">
            <summary>
            Gets the Node for this Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.Score">
            <summary>
            Gets the Score for this Result
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletServer">
            <summary>
            Represents a Connection to a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletServer.ServerDescriptionFormat">
            <summary>
            Preferred MIME Type for the format to retrieve the Server Description in
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.#ctor(System.Uri)">
            <summary>
            Creates a new connection to a Pellet Server
            </summary>
            <param name="serverUri">Server URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.#ctor(System.String)">
            <summary>
            Creates a new connection to a Pellet Server
            </summary>
            <param name="serverUri">Server URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.Discover">
            <summary>
            Discovers the Knowledge Bases on a Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.HasKnowledgeBase(System.String)">
            <summary>
            Gets whether the Server has a Knowledge Base with the given Name
            </summary>
            <param name="name">Knowledge Base Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.HasKnowledgeBase(System.Type)">
            <summary>
            Gets whether the Server has a Knowledge Base which supports the given Service Type
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.GetKnowledgeBase(System.String)">
            <summary>
            Gets the Knowledge Base with the given Name
            </summary>
            <param name="name">Knowledge Base Name</param>
            <returns>
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.GetKnowledgeBases(System.Type)">
            <summary>
            Gets all the Knowledge Bases which support a given Server
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletServer.KnowledgeBases">
            <summary>
            Gets the Knowledge Bases available from this Pellet Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper">
            <summary>
            Wrapper around an <see cref="T:VDS.RDF.Query.Inference.IOwlReasoner">IOwlReasoner</see> to make it appear like a forward-chaining reasoner
            </summary>
            <remarks>
            Essentially all this class does is extract all triples which the underlying reasoner can infer.  Currently the input graph and any graph passed to the <see cref="M:VDS.RDF.Query.Inference.IInferenceEngine.Initialise(VDS.RDF.IGraph)">Initialise()</see> method have no effect on the output of the reasoner
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.#ctor(VDS.RDF.Query.Inference.IOwlReasoner)">
            <summary>
            Creates a new OWL Reasoner Wrapper around the given OWL Reasoner
            </summary>
            <param name="reasoner">OWL Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given Graph outputting inferences into the same Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given input Graph outputting inferences into the output Graph
            </summary>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Initialise(VDS.RDF.IGraph)">
            <summary>
            Initialises the reasoner
            </summary>
            <param name="g">Graph to initialise with</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlReasonerWrapper">
            <summary>
            Wrapper around an <see cref="T:VDS.RDF.Query.Inference.IOwlReasoner">IOwlReasoner</see> to make it appear like a forward-chaining reasoner
            </summary>
            <remarks>
            Effectively equivalent to <see cref="T:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper">StaticOwlReasonerWrapper</see> except that every Graph reasoning is applied to is added to the reasoners knowledge base (unless the reasoner uses a fixed knowledge base)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.#ctor(VDS.RDF.Query.Inference.IOwlReasoner)">
            <summary>
            Creates a new OWL Reasoner Wrapper around the given OWL Reasoner
            </summary>
            <param name="reasoner">OWL Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given Graph outputting inferences into the same Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given input Graph outputting inferences into the output Graph
            </summary>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IdentityMultiset">
            <summary>
            Represents the Identity Multiset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            The other Multiset
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Left Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression which the Join is predicated on</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Exists Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether solutions must exist in the Other Multiset for the Join to suceed</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Minus Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Generates the Product of this Set and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Generates the Union of this Set and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Returns True since the Identity Multiset is considered to contain all values
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ContainsVariable(System.String)">
            <summary>
            Returns False since the Identity Multiset contains no Variables
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Returns False since the Identity Multiset is not disjoint with anything
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Add(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Adds a Set to the Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Multiset
            </summary>
            <param name="variable">Variable</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set to the Multiset
            </summary>
            <param name="id">Set ID</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.IsEmpty">
            <summary>
            Returns false as the Identity Multiset is not considered empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Variables">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Sets">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.SetIDs">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Item(System.Int32)">
            <summary>
            Gets the Set with the given ID
            </summary>
            <param name="index">Set ID</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the Identity Multiset contains no Sets</exception>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlSpecsHelper">
            <summary>
            Static Helper class for providing Constants and Helper functions for use by RDF/XML parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAbsoluteURI(System.String)">
            <summary>
            Checks whether a Uri Reference is an absolute Uri
            </summary>
            <param name="uriref">Uri Reference to Test</param>
            <returns></returns>
            <remarks>Implemented by seeing if the Uri Reference starts with a Uri scheme specifier</remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.coreSyntaxTerms">
            <summary>
            Array containing the Core Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.syntaxTerms">
            <summary>
            Array containing the other Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.oldTerms">
            <summary>
            Array containing the Old Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.requiresRdfPrefix">
            <summary>
            Array containing Syntax Terms where the rdf: Prefix is mandated
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsCoreSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Core Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Core Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsOldTerm(System.String)">
            <summary>
            Checks whether a given QName is a Old Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Old Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsNodeElementUri(System.String)">
            <summary>
            Checks whether a given QName is valid as a Node Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyElementURI(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyAttributeURI(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Attribute Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAmbigiousAttributeName(System.String)">
            <summary>
            Checks whether a given Local Name is potentially ambigious
            </summary>
            <param name="name">Local Name to Test</param>
            <returns>True if the Local Name is ambigious</returns>
            <remarks>This embodies Local Names which must have an rdf prefix</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsValidUriRefEncoding(System.String)">
            <summary>
            Checks whether a given URIRef is encoded in Unicode Normal Form C
            </summary>
            <param name="uriref">URIRef to Test</param>
            <returns>True if the URIRef is encoded correctly</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsValidBaseUri(System.String)">
            <summary>
            Checks whether a given Base Uri can be used for relative Uri resolution
            </summary>
            <param name="baseUri">Base Uri to Test</param>
            <returns>True if the Base Uri can be used for relative Uri resolution</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsIDAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:ID attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:ID attribute</returns>
            <remarks>Does some validation on ID value but other validation occurs in the <see cref="!:ValidateID()">ValidateID</see> method which is called at other points in the Parsing</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsNodeIDAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:nodeID attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:nodeID attribute</returns>
            <remarks>Does some validation on ID value but other validation occurs in the <see cref="!:ValidateID()">ValidateID</see> method which is called at other points in the Parsing</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAboutAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:about attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:about attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an property attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an property attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsResourceAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:resource attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:resource attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsDataTypeAttribute(VDS.RDF.Parsing.Events.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:datatype attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:datatype attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsRdfID(System.String)">
            <summary>
            Validates that an ID is a valid NCName
            </summary>
            <param name="value">ID Value to Test</param>
            <returns>True if the ID is valid</returns>
            <remarks>Actual Validation conditions on IDs are stricter than this and this is handled separately by the <see cref="!:ValidateID()">ValidateID</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsRdfUriReference(System.String)">
            <summary>
            Validates that a URIReference is valid
            </summary>
            <param name="value">URIReference to Test</param>
            <returns>True</returns>
            <remarks>
            Currently partially implemented, some invalid Uri References may be considered valid
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.Error(System.String,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which generates standardised Error Messages
            </summary>
            <param name="message">Error Message</param>
            <param name="evt">Event causing the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.Error(System.String,System.String,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which generates standardised Error Messages
            </summary>
            <param name="message">Error Message</param>
            <param name="production">The Production where the Error occurred</param>
            <param name="evt">Event causing the Error</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Triple">
            <summary>
            Class for representing RDF Triples in memory
            </summary>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph</remarks>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.ITripleContext)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph with some Context
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <param name="con">Context Information for the Triple</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph</remarks>
        </member>
        <member name="M:VDS.RDF.Triple.Involves(VDS.RDF.INode)">
            <summary>
            Checks whether the Triple involves a given Node
            </summary>
            <param name="n">The Node to test upon</param>
            <returns>True if the Triple contains the given Node</returns>
        </member>
        <member name="M:VDS.RDF.Triple.Involves(System.Uri)">
            <summary>
            Checks whether the Triple involves a given Uri
            </summary>
            <param name="uri">The Uri to test upon</param>
            <returns>True if the Triple has a UriNode with the given Uri</returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasSubject(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Subject
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasPredicate(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Predicate
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasObject(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Object
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.Equals(System.Object)">
            <summary>
            Implementation of Equality for Triples
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
            <remarks>
            Triples are considered equal on the basis of two things:
            <ol>
            <li>The Hash Codes of the Triples are identical</li>
            <li>The logical conjunction (AND) of the equality of the Subject, Predicate and Object is true.  Each pair of Nodes must either be Equal using Node Equality or are both Blank Nodes and have identical Node IDs (i.e. are indistinguishable for equality purposes on a single Triple level)</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Triple.GetHashCode">
            <summary>
            Implementation of Hash Codes for Triples
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Returns the Hash Code of the Triple which is calculated as the Hash Code of the String formed by concatenating the Hash Codes of its constituent Nodes.  This Hash Code is precomputed in the Constructor of a Triple since it will be used a lot (in Triple Equality calculation, Triple Collections etc)
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Triple will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">System.String.GetHashCode()</see> for further details)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Triple.ToString">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object'
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.ToString(System.Boolean)">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object' with optional compression of URIs to QNames
            </summary>
            <param name="compress">Controls whether URIs will be compressed to QNames in the String representation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.CompareTo(VDS.RDF.Triple)">
            <summary>
            Implementation of CompareTo for Triples which allows Triples to be sorted
            </summary>
            <param name="other">Triple to compare to</param>
            <returns></returns>
            <remarks>Triples are Ordered by Subjects, Predicates and then Objects.  Triples are only partially orderable since the CompareTo methods on Nodes only define a partial ordering over Nodes</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Subject">
            <summary>
            Gets the Subject of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Predicate">
            <summary>
            Gets the Predicate of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Object">
            <summary>
            Gets the Object of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Graph">
            <summary>
            Gets the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.GraphUri">
            <summary>
            Gets the Uri of the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph Uri of the Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Context">
            <summary>
            Gets the Context Information for this Triple
            </summary>
            <remarks>Context may be null where no Context for the Triple has been defined</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Nodes">
            <summary>
            Gets an enumeration of the Nodes in the Triple
            </summary>
            <remarks>
            Returned as subject, predicate, object
            </remarks>
        </member>
        <member name="P:VDS.RDF.Triple.IsGroundTriple">
            <summary>
            Gets whether the Triple is a Ground Triple
            </summary>
            <remarks>
            <para>
            A <strong>Ground Triple</strong> is any Triple considered to state a single fixed fact.  In practise this means that the Triple does not contain any Blank Nodes.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Collides">
            <summary>
            Gets/Sets whether the Triple collides with other Triples in this Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.NodeCollection">
            <summary>
            Basic Node Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeCollection._nodes">
            <summary>
            Underlying storage of the Node Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeCollection._collisionNodes">
            <summary>
            Underlying storage of the Node Collection which Handles the extra Nodes that result from Hash Code Collision
            </summary>
        </member>
        <member name="M:VDS.RDF.NodeCollection.#ctor">
            <summary>
            Creates a new NodeCollection
            </summary>
        </member>
        <member name="M:VDS.RDF.NodeCollection.Contains(VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is in the Node Collection
            </summary>
            <param name="n">The Node to test</param>
            <returns>Returns True if the Node is already in the collection</returns>
        </member>
        <member name="M:VDS.RDF.NodeCollection.Add(VDS.RDF.INode)">
            <summary>
            Adds a new Node to the Collection
            </summary>
            <param name="n">Node to add</param>
        </member>
        <member name="M:VDS.RDF.NodeCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeCollection.Dispose">
            <summary>
            Disposes of a Node Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.NodeCollection.Count">
            <summary>
            Gets the Number of Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.NodeCollection.BlankNodes">
            <summary>
            Gets all the Blank Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.NodeCollection.LiteralNodes">
            <summary>
            Gets all the Literal Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.NodeCollection.UriNodes">
            <summary>
            Gets all the Uri Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.NodeCollection.GraphLiteralNodes">
            <summary>
            Gets all the Graph Literal Nodes in the Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.ThreadSafeNodeCollection">
            <summary>
            Thread Safe Node Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeNodeCollection.Add(VDS.RDF.INode)">
            <summary>
            Adds a new Node to the Collection
            </summary>
            <param name="n">Node to add</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeNodeCollection.Contains(VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is in the Node Collection
            </summary>
            <param name="n">The Node to test</param>
            <returns>Returns True if the Node is already in the collection</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeNodeCollection.Dispose">
            <summary>
            Disposes of a Node Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeNodeCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.ThreadSafeNodeCollection.BlankNodes">
            <summary>
            Gets all the Blank Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeNodeCollection.Count">
            <summary>
            Gets the Number of Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeNodeCollection.GraphLiteralNodes">
            <summary>
            Gets all the Graph Literal Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeNodeCollection.LiteralNodes">
            <summary>
            Gets all the Literal Nodes in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeNodeCollection.UriNodes">
            <summary>
            Gets all the Uri Nodes in the Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlRemoteEndpoint">
            <summary>
            A Class for connecting to a remote SPARQL Endpoint and executing Queries against it
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor">
            <summary>
            Empty Constructor for use by derived classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.String)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph Uri
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint Uri using the given Default Graph Uri
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri,System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri},System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultSet(System.String)">
            <summary>
            Makes a Query where the expected Result is a SparqlResultSet ie. SELECT and ASK Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>A Sparql Result Set</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultGraph(System.String)">
            <summary>
            Makes a Query where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>RDF Graph</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryRaw(System.String)">
            <summary>
            Makes a Query to a Sparql Endpoint and returns the raw Response
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryInternal(System.String,System.String)">
            <summary>
            Internal method which builds the Query Uri and executes it via GET/POST as appropriate
            </summary>
            <param name="sparqlQuery">Sparql Query</param>
            <param name="acceptHeader">Accept Header to use for the request</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.ExecuteQuery(System.Uri,System.String,System.String)">
            <summary>
            Internal Helper Method which executes the HTTP Requests against the Sparql Endpoint
            </summary>
            <param name="target">Uri to make Request to</param>
            <param name="postData">Data that is to be POSTed to the Endpoint in <strong>application/x-www-form-urlencoded</strong> format</param>
            <param name="accept">The Accept Header that should be used</param>
            <returns>HTTP Response</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Endpoint's Configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.DefaultGraphs">
            <summary>
            Gets the Default Graph URIs for Queries made to the SPARQL Endpoint
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.NamedGraphs">
            <summary>
            Gets the List of Named Graphs used in requests
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlRemoteEndpoint.AsyncQueryWithResultSet">
            <summary>
            Makes a Query where the expected Result is a SparqlResultSet ie. SELECT and ASK Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>A Sparql Result Set</returns>
            <remarks>Allows for implementation of asynchronous querying</remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlRemoteEndpoint.AsyncQueryWithResultGraph">
            <summary>
            Delegate for making a Query where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>RDF Graph</returns>
            <remarks>Allows for implementation of asynchronous querying</remarks>
        </member>
        <member name="T:VDS.RDF.Query.FederatedSparqlRemoteEndpoint">
            <summary>
            A Class for connecting to multiple remote SPARQL Endpoints and federating queries over them with the data merging done locally
            </summary>
            <remarks>
            <para>
            Queries are federated by executing multiple requesting simultaneously and asynchronously against the endpoints in question with the data then merged locally.  The merging process does not attempt to remove duplicate data it just naively merges the data.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.#ctor(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Creates a new Federated SPARQL Endpoint using a given Endpoint
            </summary>
            <param name="endpoint">Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.SparqlRemoteEndpoint})">
            <summary>
            Creates a new Federated SPARQL Endpoint using the given Endpoints
            </summary>
            <param name="endpoints">Endpoints</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new Federated SPARQL Endpoint by creating a new <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> for the given URI
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.#ctor(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new Federated SPARQL Endpoint by creating a <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> for each of the given URI
            </summary>
            <param name="endpointUris">Endpoint URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.AddEndpoint(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Adds a additional endpoint to be used by this endpoint
            </summary>
            <param name="endpoint">Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.AddEndpoint(System.Uri)">
            <summary>
            Adds an additional endpoint to be used by this endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.RemoveEndpoint(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Removes a given endpoint from this endpoint
            </summary>
            <param name="endpoint">Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.RemoveEndpoint(System.Uri)">
            <summary>
            Removes all endpoints with the given URI from this endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.QueryRaw(System.String)">
            <summary>
            Makes a Query to a Sparql Endpoint and returns the raw Response
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown if more than one endpoint is in use since for any federated endpoint which used more than one endpoint there is no logical/sensible way to combine the result streams</exception>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.QueryWithResultGraph(System.String)">
            <summary>
            Makes a Query where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>RDF Graph</returns>
            <remarks>
            <para>
            The query is executed by sending it federating it to all the endpoints this endpoint contains using simultaneous asychronous calls.  Once these calls complete the results are naivley merged together (no duplicate data removal) and returned as a single result.
            </para>
            <para>
            By default if any of the endpoints used return an error then the entire query will fail and an exception will be thrown, this behaviour can be overridden by setting the <see cref="P:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.IgnoreFailedRequests">IgnoreFailedRequests</see> property to be true in which case the result will be the merge of the results from all endpoints which successfully provided a result.
            </para>
            </remarks>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if any of the requests to the endpoints fail</exception>
            <exception cref="T:VDS.RDF.Query.RdfQueryTimeoutException">Thrown if not all the requests complete within the set timeout</exception>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.QueryWithResultSet(System.String)">
            <summary>
            Makes a Query where the expected Result is a SparqlResultSet ie. SELECT and ASK Queries
            </summary>
            <param name="sparqlQuery">Sparql Query String</param>
            <returns>A Sparql Result Set</returns>
            <remarks>
            <para>
            The query is executed by sending it federating it to all the endpoints this endpoint contains using simultaneous asychronous calls.  Once these calls complete the results are naivley merged together (no duplicate data removal) and returned as a single result.
            </para>
            <para>
            By default if any of the endpoints used return an error then the entire query will fail and an exception will be thrown, this behaviour can be overridden by setting the <see cref="P:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.IgnoreFailedRequests">IgnoreFailedRequests</see> property to be true in which case the result will be the merge of the results from all endpoints which successfully provided a result.
            </para>
            </remarks>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if any of the requests to the endpoints fail</exception>
            <exception cref="T:VDS.RDF.Query.RdfQueryTimeoutException">Thrown if not all the requests complete within the set timeout</exception>
        </member>
        <member name="M:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Endpoint's Configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.IgnoreFailedRequests">
            <summary>
            Gets/Sets whether a failed request on one endpoint should cause the entire request to fail
            </summary>
            <remarks>
            <para>
            By default if a request on any of the endpoint fails or times out then the entire request will fail
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.FederatedSparqlRemoteEndpoint.MaxSimultaneousRequests">
            <summary>
            Gets/Sets the maximum number of endpoints this endpoint will issue queries to at any one time
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.OrExpression">
            <summary>
            Class representing Conditional Or expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.OrExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Conditional Or Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.OrExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.OrExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.AndExpression">
            <summary>
            Class representing Conditional And expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AndExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Conditional And Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AndExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.AndExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NegationExpression">
            <summary>
            Class representing Negation Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NegationExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Negation Expression
            </summary>
            <param name="expr">Expression to Negate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NegationExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NegationExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.EqualsExpression">
            <summary>
            Class representing Relational Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.EqualsExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.EqualsExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.EqualsExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NotEqualsExpression">
            <summary>
            Class representing Relational Non-Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NotEqualsExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Non-Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NotEqualsExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NotEqualsExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.LessThanExpression">
            <summary>
            Class representing Relational Less Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Less Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.LessThanOrEqualToExpression">
            <summary>
            Class representing Relational Less Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Less Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanOrEqualToExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LessThanOrEqualToExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.GreaterThanExpression">
            <summary>
            Class representing Relational Greater Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Greater Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.GreaterThanOrEqualToExpression">
            <summary>
            Class representing Relational Greater Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Greater Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanOrEqualToExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.GreaterThanOrEqualToExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NullExpression">
            <summary>
            Represents a Null/Unknown Expression
            </summary>
            <remarks>
            <para>
            Used as a placeholder for expressions that cannot be parsed since the Uri of the function is not known and no registered <see cref="T:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory">ISparqlCustomExpressionFactory</see> is capable of turning it into a valid <see cref="T:VDS.RDF.Query.Expressions.ISparqlExpression">ISparqlExpression</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NullExpression.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets a Null since this expression represents Null or an Unknown expression (whose value cannot be evaluated)
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NullExpression.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.NullExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.NullExpression.Variables">
            <summary>
            Gets an Empty enumerable since a Null expression term doesn't use variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode">
            <summary>
            Possible Escape Handling Modes for the Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.Uri">
            <summary>
            Escaping for URIs (every escape but \" is valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiterals">
            <summary>
            Escaping for Quoted Literals (every escape but \&lt; is valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiteralsAlternate">
            <summary>
            Escaping for single Quoted Literals (every escape but \&lt; is valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QName">
            <summary>
            Escaping for QNames (only Unicode espaces are valid)
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.NativeSparqlHandlerConfiguration">
            <summary>
            Class for storing Native Sparql Handler Configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Web.Configuration.Query.NativeSparqlHandlerConfiguration.#ctor(System.Web.HttpContext,System.String,System.String)">
            <summary>
            Creates a new Native Sparql Handler Configuration object which loads all the relevant settings from the AppSettings section of the in-scope config file
            </summary>
            <param name="context">HTPP Context</param>
            <param name="cacheKey">Cache Key for this Handler</param>
            <param name="configPrefix">Configuration Variable Name Prefix for this Handler</param>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.NativeSparqlHandlerConfiguration.TripleStore">
            <summary>
            Gets the Natively Queryable Store object used to service requests
            </summary>
        </member>
        <member name="P:VDS.RDF.Web.Configuration.Query.NativeSparqlHandlerConfiguration.StoreType">
            <summary>
            Gets the type of Triple Store used
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.AllegroGraphConnector">
            <summary>
            Class for connecting to an AllegroGraph Store
            </summary>
            <remarks>
            <para>
            Connection to AllegroGraph is based on their new HTTP Protocol which is an extension of the <a href="http://www.openrdf.org/doc/sesame2/system/ch08.html">Sesame 2.0 HTTP Protocol</a>.  The specification for the AllegroGraph protocol can be found <a href="http://www.franz.com/agraph/support/documentation/current/new-http-server.html">here</a>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="catalogID">Catalog ID</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="catalogID">Catalog ID</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username for connecting to the Store</param>
            <param name="password">Password for connecting to the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.CreateStore(System.String)">
            <summary>
            Creates a new Store (if it doesn't exist) and switches the connector to use that Store
            </summary>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.IndexStore(System.Boolean)">
            <summary>
            Requests that AllegroGraph indexes the Store
            </summary>
            <param name="combineIndices">Whether existing Indices should be combined with the newly generated ones</param>
            <remarks>
            Setting <paramref name="CombineIndices"/> causes AllegroGraph to merge the new indices with existing indices which results in faster queries but may take significant extra time for the indexing to be done depending on the size of the Store.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.DeleteStore(System.String)">
            <summary>
            Requests that AllegroGraph deletes a Store
            </summary>
            <param name="storeID"></param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="T:VDS.RDF.Web.WildcardProtocolHandler">
            <summary>
            HTTP Handler for adding SPARQL Uniform HTTP Protocol for RDF Graph Management endpoints to ASP.Net applications
            </summary>
            <remarks>
            <para>
            Used to create a Protocol endpoint at a Base URL with any URL under this handled by this Handler
            </para>
            <para>
            This Handler is configured using the new Configuration API introduced in the 0.3.0 release.  This requires just one setting to be defined in the &lt;appSettings&gt; section of your Web.config file which points to a Configuration Graph like so:
            <code>&lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;</code>
            The Configuration Graph must then contain Triples like the following to specify a Protocol Endpoint:
            <code>
            &lt;dotnetrdf:/folder/protocol/*&gt; a dnr:HttpHandler ;
                                                 dnr:type "VDS.RDF.Web.WildcardProtocolHandler" ;
                                                 dnr:protocolProcessor _:proc .
                                            
            _:proc a dnr:SparqlHttpProtocolProcessor ;
                   dnr:type "VDS.RDF.Update.Protocol.LeviathanProtocolProcessor" ;
                   dnr:usingStore _:store .
                   
            _:store a dnr:TripleStore ;
                    dnr:type "VDS.RDF.TripleStore" .
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Web.WildcardProtocolHandler.LoadConfig(System.Web.HttpContext)">
            <summary>
            Loads the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Web.WildcardProtocolHandler.UpdateConfig(System.Web.HttpContext)">
            <summary>
            Updates the Handler Configuration
            </summary>
            <param name="context">HTTP Context</param>
        </member>
        <member name="T:VDS.RDF.Query.Filters.FilterApplicationMode">
            <summary>
            Indicates when a Filter is applied
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Filters.FilterApplicationMode.PreCommit">
            <summary>
            Filter is applied prior to Bindings being committed
            </summary>
            <remarks>
            Means the Filter operates over the temporary bindings
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Filters.FilterApplicationMode.PostCommit">
            <summary>
            Filter is applied after Bindings are committed
            </summary>
            <remarks>
            Means the Filter operates over the current set of 'valid' bindings
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService">
            <summary>
            Represents the Classify Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Classify Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService.Classify">
            <summary>
            Extracts the Graph which comprises the class hierarchy
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PelletQueryProcessor">
            <summary>
            A SPARQL Query Processor which processes queries by parsing them to the SPARQL Query Service of a Knowledge Base on a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.#ctor(VDS.RDF.Query.Inference.Pellet.PelletServer,System.String)">
            <summary>
            Creates a new Pellet Query Processor
            </summary>
            <param name="server">Pellet Server</param>
            <param name="kbName">Knowledge Base Name</param>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.#ctor(System.Uri,System.String)">
            <summary>
            Creates a new Pellet Query Processor
            </summary>
            <param name="serverUri">Pellet Server URI</param>
            <param name="kbName">Knowledge Base Name</param>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.IfElseFunction">
            <summary>
            Class representing the SPARQL IF ELSE function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IfElseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IF ELSE function
            </summary>
            <param name="condition">Condition</param>
            <param name="ifBranch">Expression to evaluate if condition evaluates to true</param>
            <param name="elseBranch">Expression to evalaute if condition evaluates to false/error</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IfElseFunction.Value(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IfElseFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the effective boolean value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.IfElseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.IfElseFunction.Variables">
            <summary>
            Gets the enumeration of variables used in the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ArqFunctionFactory">
            <summary>
            Expression Factory which generates ARQ Function expressions
            </summary>
            <remarks>
            <para>
            Designed to help provide feature parity with the ARQ query engine contained in Jena
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.ArqFunctionsNamespace">
            <summary>
            ARQ Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Max">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Min">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Pi">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.E">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.BNode">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.LocalName">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Namespace">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Substr">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Substring">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.StrJoin">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Sha1Sum">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Now">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ArqFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an ARQ Function expression if the function Uri correseponds to a supported ARQ Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Distinct">
            <summary>
            Represents a Distinct modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Distinct Modifier
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Distinct Modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Reduced">
            <summary>
            Represents a Reduced modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Reduced Modifier
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Reduced Modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.AllAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to true for all Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AllAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new All Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AllAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new All Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AllAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates true for every member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a false/error it will return false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AllAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.AnyAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to true for at least one of the Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AnyAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Any Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AnyAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Any Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AnyAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates true for any member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a true it will return true
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.AnyAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NoneAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to false/error for all Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NoneAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new None Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NoneAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new None Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NoneAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates false/error for every member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a true it will return false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.NoneAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.HashTable`2">
            <summary>
            A Hash Table for use as in-memory storage
            </summary>
            <typeparam name="TKey">Type of Keys</typeparam>
            <typeparam name="TValue">Type of Values</typeparam>
            <remarks>
            <para>
            Essentially a Dictionary which allows multiple values for each key
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.HashTable`2.#ctor">
            <summary>
            Crestes a new HashTable
            </summary>
            <remarks>
            Use this constructor if you expect to use this primarily as a dictionary i.e. there is a mostly 1:1 mapping of keys to values with minimal collisions
            </remarks>
        </member>
        <member name="M:VDS.RDF.HashTable`2.#ctor(System.Int32)">
            <summary>
            Creates a new HashTable where the initial capacity at each key is specified
            </summary>
            <param name="capacity">Initial Capacity at each Key</param>
            <remarks>
            Use this if you expect to use this as a true HashTable i.e. there is a 1:Many mapping of keys to values.  Choose a capcity value that seems reasonable for the data you expect to store.
            </remarks>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Add(`0,`1)">
            <summary>
            Adds an item to the Hash Table
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.HashTable`2.ContainsKey(`0)">
            <summary>
            Checks whether the given Key exists in the Hash Table
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Contains(`0,`1)">
            <summary>
            Checks whether the given Key Value pair exists in the Hash Table
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Remove(`0)">
            <summary>
            Removes everything with the given Key from the Hash Table
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Remove(`0,`1)">
            <summary>
            Removes the given Key Value pair from the Hash Table
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the first Value with the given Key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.TryGetValue(`0,`1,`1@)">
            <summary>
            Tries to get the actual instance of the given Key and Value from the Collection
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <param name="result">Actual Value from the Collection</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.GetValues(`0)">
            <summary>
            Gets all values with the given Key from the Hash Table
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a Key Value Pair to the Hash Table
            </summary>
            <param name="item">Key Value pair</param>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Clear">
            <summary>
            Clears the Hash Table
            </summary>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the given Key Value pair is in the Hash Table
            </summary>
            <param name="item">Key Value pair</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the Hash Table to an array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Index of the array to start copying into at</param>
        </member>
        <member name="M:VDS.RDF.HashTable`2.ValueCount(`0)">
            <summary>
            Gets the number of Values for a given Key
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a Key Value pair from the Hash Table
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.GetEnumerator">
            <summary>
            Gets the Enumerator for the Key Value pairs in the Hash Table
            </summary>
            <returns></returns>
            <remarks>
            If a Key has multiple values a pair for each value will be generated
            </remarks>
        </member>
        <member name="M:VDS.RDF.HashTable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Hash Table
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashTable`2.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>
            Gets the Enumerator for Values in the Hash Table
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.HashTable`2.Keys">
            <summary>
            Gets the Keys of the Hash Table
            </summary>
        </member>
        <member name="P:VDS.RDF.HashTable`2.Values">
            <summary>
            Gets all the values in the Hash Table
            </summary>
        </member>
        <member name="P:VDS.RDF.HashTable`2.Item(`0)">
            <summary>
            Gets the first value with the given key from the Hash Table
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.HashTable`2.Count">
            <summary>
            Gets the number of Values in the Hash Table
            </summary>
        </member>
        <member name="P:VDS.RDF.HashTable`2.KeyCount">
            <summary>
            Gets the number of Keys in the Hash Table
            </summary>
        </member>
        <member name="P:VDS.RDF.HashTable`2.IsReadOnly">
            <summary>
            Returns that the Hash Table is not read only
            </summary>
        </member>
        <member name="T:VDS.RDF.HashSlot`1">
            <summary>
            Represents a slot in the Hash Table
            </summary>
            <typeparam name="T">Type of Values stored in the Slot</typeparam>
            <remarks>
            Hash Slots may contain duplicate values
            </remarks>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.#ctor(`0)">
            <summary>
            Creates a new Hash Slot which contains the given Value
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.#ctor(`0,System.Int32)">
            <summary>
            Creates a new Hash Slot which contains the given Value and has the given initial capacity
            </summary>
            <param name="value">Value</param>
            <param name="capacity">Initial Capacity of Slot</param>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.GetEnumerator">
            <summary>
            Gets the Enumerator of the Values in the Slot
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator of the Values in the Slot
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.Clear">
            <summary>
            Clears the contents of the Hash Slot
            </summary>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.Contains(`0)">
            <summary>
            Checks whether the Hash Slot contains a given Value
            </summary>
            <param name="item">Item to look for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of the Hash Slot to an array
            </summary>
            <param name="array">Array to copy to</param>
            <param name="arrayIndex">Index of the array at which to start copying data in</param>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.Remove(`0)">
            <summary>
            Removes an Item from the Hash Slot
            </summary>
            <param name="item">Value to remove</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HashSlot`1.Add(`0)">
            <summary>
            Adds an Item to the Hash Slot
            </summary>
            <param name="item">Value to add</param>
        </member>
        <member name="P:VDS.RDF.HashSlot`1.Count">
            <summary>
            Gets the Count of Values in the Hash Slot
            </summary>
        </member>
        <member name="P:VDS.RDF.HashSlot`1.IsReadOnly">
            <summary>
            Returns that a Hash Slot is not read only
            </summary>
        </member>
        <member name="T:VDS.RDF.NativeTripleStore">
            <summary>
            Class for representing an arbitrary Store which can be queried over for which a <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see> is provided
            </summary>
            <remarks>
            <para>
            No data is automatically loaded into this class when it is instantiated, it acts as a queryable view on some arbitrary Store accessed via some <see cref="T:VDS.RDF.Storage.IQueryableGenericIOManager">IQueryableGenericIOManager</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.#ctor(VDS.RDF.Storage.IQueryableGenericIOManager)">
            <summary>
            Creates a new instance of the Native Triple Store
            </summary>
            <param name="manager">Manager for the Store you want to query</param>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a Sparql Query against the underlying Store
            </summary>
            <param name="query">Sparql Query</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">The Query Results are returned in an unexpected format</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">There is a problem accessing the underlying store</exception>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.Dispose">
            <summary>
            Disposes of a Native Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes a SPARQL Update on the Store
            </summary>
            <param name="update">SPARQL Update</param>
            <remarks>
            <para>
            If the underlying Manager is an <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> then the managers own Update implementation will be used, otherwise dotNetRDF's approximated implementation for generic stores will be used.  In the case of approximation exact feature support will vary depending on the underlying manager being used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a SPARQL Update on the Store
            </summary>
            <param name="update">SPARQL Update Command</param>
            <remarks>
            <para>
            If the underlying Manager is an <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> then the managers own Update implementation will be used, otherwise dotNetRDF's approximated implementation for generic stores will be used.  In the case of approximation exact feature support will vary depending on the underlying manager being used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.NativeTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of SPARQL Update commands on the Store
            </summary>
            <param name="updates">SPARQL Update Commands</param>
            <remarks>
            <para>
            If the underlying Manager is an <see cref="T:VDS.RDF.Storage.IUpdateableGenericIOManager">IUpdateableGenericIOManager</see> then the managers own Update implementation will be used, otherwise dotNetRDF's approximated implementation for generic stores will be used.  In the case of approximation exact feature support will vary depending on the underlying manager being used.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.WebDemandTripleStore">
            <summary>
            Class for representing Triple Stores which are collections of RDF Graphs
            </summary>
            <remarks>
            The 'Web Demand' Triple Store is a Triple Store which automatically retrieves Graphs from the Web based on the URIs of Graphs that you ask it for
            </remarks>
        </member>
        <member name="M:VDS.RDF.WebDemandTripleStore.#ctor(System.Uri)">
            <summary>
            Creates an Web Demand Triple Store
            </summary>
            <param name="defaultGraphUri">A Uri for the Default Graph which should be loaded from the Web as the initial Graph</param>
        </member>
        <member name="M:VDS.RDF.WebDemandTripleStore.#ctor(System.String)">
            <summary>
            Creates an Web Demand Triple Store
            </summary>
            <param name="defaultGraphFile">A Filename for the Default Graph which should be loaded from a local File as the initial Graph</param>
        </member>
        <member name="M:VDS.RDF.WebDemandTripleStore.#ctor">
            <summary>
            Creates a new Web Demand Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.WebDemandGraphCollection">
            <summary>
            A Graph Collection where Graphs can be loaded on-demand from the Web as needed
            </summary>
        </member>
        <member name="F:VDS.RDF.WebDemandGraphCollection._store">
            <summary>
            Reference back to the Store that this is a GraphCollection for
            </summary>
        </member>
        <member name="M:VDS.RDF.WebDemandGraphCollection.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new Web Demand Graph Collection which loads Graphs from the Web on demand
            </summary>
            <param name="store">Store this is a Graph Collection for (may be null if not associated with a Store)</param>
        </member>
        <member name="M:VDS.RDF.WebDemandGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection.  If it doesn't but is in the backing Store it will be loaded into the Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WebDemandGraphCollection.Dispose">
            <summary>
            Disposes of a On Demand Graph Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ReasonerFactory">
            <summary>
            Factory class for producing Reasoners from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ReasonerFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Reasoner based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ReasonerFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlJsonWriter">
            <summary>
            Class for saving Sparql Result Sets to the Sparql Results Json Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.Save(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Saves the Result Set to the given File in the Sparql Results XML Format
            </summary>
            <param name="results">Result Set to save</param>
            <param name="filename">File to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream in the Sparql Results XML Format
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Internal method which generates the Sparql Query Results Json output
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="T:VDS.RDF.NamespaceChanged">
            <summary>
            Delegate Type for the Events of the Namespace Mapper
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="T:VDS.RDF.NamespaceMapper">
            <summary>
            Class for representing Mappings between Prefixes and Namespace URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.RDF">
            <summary>
            Constant Uri for the RDF Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.RDFS">
            <summary>
            Constant Uri for the RDF Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.XMLSCHEMA">
            <summary>
            Constant Uri for the XML Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.OWL">
            <summary>
            Constant Uri for the OWL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper._uris">
            <summary>
            Mapping of Prefixes to URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper._prefixes">
            <summary>
            Mapping of URIs to Prefixes
            </summary>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor">
            <summary>
            Constructs a new Namespace Map
            </summary>
            <remarks>The Prefixes rdf, rdfs and xsd are automatically defined</remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor(System.Boolean)">
            <summary>
            Constructs a new Namespace Map which is optionally empty
            </summary>
            <param name="empty">Whether the Namespace Map should be empty, if set to false the Prefixes rdf, rdfs and xsd are automatically defined</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor(VDS.RDF.NamespaceMapper)">
            <summary>
            Constructs a new Namespace Map which is based on an existing map
            </summary>
            <param name="nsmapper"></param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Returns the Prefix associated with the given Base Uri
            </summary>
            <param name="uri">The Base Uri to lookup the Prefix for</param>
            <returns>String prefix for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Returns the Uri associated with the given Base Uri
            </summary>
            <param name="prefix">The Prefix to lookup the Base Uri for</param>
            <returns>Base Uri for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the NamespaceMapper
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace from the NamespaceMapper
            </summary>
            <param name="prefix">Namespace Prefix of the Namespace to remove</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.HasNamespace(System.String)">
            <summary>
            Method which checks whether a given Namespace Prefix is defined
            </summary>
            <param name="prefix">Prefix to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Clear">
            <summary>
            Internal Only method which allows the Namespace Map to be cleared
            </summary>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter qname will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Import(VDS.RDF.NamespaceMapper)">
            <summary>
            Imports the contents of another Namespace Map into this Namespace Map
            </summary>
            <param name="nsmap">Namespace Map to import</param>
            <remarks>
            Prefixes in the imported Map which are already defined in this Map are ignored, this may change in future releases.
            </remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceAdded Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceModified Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceRemoved Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Dispose">
            <summary>
            Disposes of a Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.NamespaceMapper.Prefixes">
            <summary>
            Gets a Enumerator of all the Prefixes
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceAdded">
            <summary>
            Event which is raised when a Namespace is Added
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceModified">
            <summary>
            Event which is raised when a Namespace is Modified
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceRemoved">
            <summary>
            Event which is raised when a Namespace is Removed
            </summary>
        </member>
        <member name="T:VDS.RDF.QNameOutputMapper">
            <summary>
            Class for representing Mappings from URIs to QNames
            </summary>
            <remarks>
            Used primarily in outputting RDF syntax
            </remarks>
        </member>
        <member name="F:VDS.RDF.QNameOutputMapper._mapping">
            <summary>
            Mapping of URIs to QNames
            </summary>
        </member>
        <member name="F:VDS.RDF.QNameOutputMapper._nextNamespaceID">
            <summary>
            Next available Temporary Namespace ID
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.#ctor(VDS.RDF.NamespaceMapper)">
            <summary>
            Creates a new QName Output Mapper using the given Namespace Map
            </summary>
            <param name="nsmapper">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.#ctor">
            <summary>
            Creates a new QName Output Mapper which has an empty Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter qname will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.ReduceToQName(System.String,System.String@,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName and issues a Temporary Namespace if required
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <param name="tempNamespace">The Temporary Namespace issued (if any)</param>
            <returns></returns>
            <remarks>
            <para>
            This function will always returns a possible QName for the URI if the format of the URI permits it.  It doesn't guarentee that the QName will be valid for the syntax it is being written to - it is up to implementers of writers to validate the QNames returned.
            </para>
            <para>
            Where necessary a Temporary Namespace will be issued and the <paramref name="tempNamespace">tempNamespace</paramref> parameter will be set to the prefix of the new temporary namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.AddToCache(System.Int32,VDS.RDF.QNameMapping)">
            <summary>
            Adds a URI to QName Mapping to the Cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.GetNextTemporaryNamespacePrefix">
            <summary>
            Gets the next available Temporary Namespace ID
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ThreadSafeQNameOutputMapper">
            <summary>
            Thread Safe version of the <see cref="T:VDS.RDF.QNameOutputMapper">QNameOutputMapper</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.#ctor(VDS.RDF.NamespaceMapper)">
            <summary>
            Creates a new Thread Safe QName Output Mapper
            </summary>
            <param name="nsmapper">Namespace Mapper</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.AddToCache(System.Int32,VDS.RDF.QNameMapping)">
            <summary>
            Adds a QName Mapping to the Cache in a Thread Safe way
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the QName Output Mapper
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="T:VDS.RDF.QNameMapping">
            <summary>
            Represents a mapping from a URI to a QName
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameMapping.#ctor(System.String)">
            <summary>
            Creates a new QName Mapping
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.QNameMapping.ToString">
            <summary>
            Gets the String representation of the URI
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.QNameMapping.Equals(System.Object)">
            <summary>
            Checks whether this is equal to another Object
            </summary>
            <param name="obj">Object to test against</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.QNameMapping.Uri">
            <summary>
            URI this is a mapping for
            </summary>
        </member>
        <member name="P:VDS.RDF.QNameMapping.QName">
            <summary>
            QName this URI maps to
            </summary>
        </member>
        <member name="T:VDS.RDF.NamespaceDoc">
            <summary>
            <para>
            Top Level Namespace for the <strong>dotNetRDF Library</strong> which embodies a simple but powerful API for manipulating RDF.   
            </para>
            <para>
            Specific Namespaces within the Hierarchy provide <see cref="N:VDS.RDF.Parsing">Parsing</see>, <see cref="N:VDS.RDF.Writing">Serialization</see> and <see cref="N:VDS.RDF.Translation">Translation</see> functionality along with a host of related classes to support these functions.
            </para>
            <para>
            Support for querying RDF is provided in the <see cref="N:VDS.RDF.Query">Query</see> namespace which includes SPARQL Query, limited reasoning support in the <see cref="N:VDS.RDF.Query.Inference">Query.Inference</see> namespace and a Pellet client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Query.Inference.Pellet</see> namespace.
            </para>
            <para>
            Support for updating RDF based on the SPARQL 1.1 Update and Uniform HTTP Protocol for RDF Graph Management is provided in the <see cref="N:VDS.RDF.Update">Update</see> and <see cref="N:VDS.RDF.Update.Protocol">Update.Protocol</see> namespaces.
            </para>
            <para>For communicating with arbitrary Triple Stores we have a dedicated <see cref="N:VDS.RDF.Storage">Storage</see> namespace.  As of this release we support the following Triple Stores:
            <ul>
                <li>AllegroGraph</li>
                <li>4store</li>
                <li>Joseki</li>
                <li>Any Sesame HTTP Protocl compliant store</li>
                <li>Any SPARQL Uniform HTTP Protocol for RDF Graph Management compliant stores</li>
                <li>Talis Platform</li>
                <li>Virtuoso</li>
            </ul>
            There is also support for using SQL backed stores (only recommended for small scale testing and development) and a couple of other forms of read-only store namely RDF dataset files and SPARQL query endpoints.
            </para>
            <para>
            For those building ASP.Net based websites the <see cref="N:VDS.RDF.Web">Web</see> namespace is dedicated to providing classes for integrating RDF into ASP.Net applications.  If you've used dotNetRDF previously for ASP.Net applications please be aware that most of the existing classes are now deprecated in favour of new classes which take advantage of the new Configuration API.
            </para>
            <para>
            There is also a fairly new and experimental <see cref="N:VDS.RDF.Ontology">Ontology</see> namespace which provides a more resource and ontology centric API for working with RDF which was introduced in the 0.2.2 release
            </para>
            <h4>Configuration</h4>
            <para>
            As of the 0.3.0 release we introduced a new <see cref="N:VDS.RDF.Configuration">Configuration</see> API which provides for encoding configuration in RDF Graphs.  This configuration system has been used as part of a complete refresh of the ASP.Net support as it allows for much more expressive and flexible configurations than were previously possible.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.
            </para>
            <h4>Notes</h4>
            <para>
            Currently dotNetRDF is still considered to be in Alpha, this means it may not be suitable for production scenarios and that the API is subject to change in subsequent releases should we feel it necessary.  As it is an Alpha release users should be aware that the software will not be bug free.  While we continually work to improve the quality of this library and to eliminate bugs as we find them we are at the same time attempting to enhance the library by adding more functionality so it is inevitable that some bugs will persist.  Please help us improve this library by emailing us when you find a bug, you can use the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">Bug Reports list</a> to report bugs, the <a href="mailto:dotnetrdf-support@lists.sourceforge.net">Support list</a> to ask questions and the <a href="mailto:dotnetrdf-develop@lists.sourceforge.net">Developer list</a> to request new features or discuss development plans (all these are SourceForge mailing lists which require subscription).
            </para>
            <para>
            The 0.3.0 release makes very few breaking API changes compared to the 0.2.x API and it is planned that the API should continue to remain relatively stable other than the introduction of new features and the removal of the now deprecated older ASP.Net classes.  Further 0.3.x releases will focus on bringing continued improvements in the ASP.Net support and increased support for reasoning.
            </para>
            <para>
            We provide a Mono build of dotNetRDF (<em>dotNetRDF.Mono.dll</em>) which is currently targeted at Mono 2.6 - this port is highly experimental and has received little/no testing.  There are some known incompatabilities with Mono mostly regarding the 3rd party libraries that dotNetRDF uses - Virtuoso and MySQL support is likely not to function under Mono.  As far as we are aware all other features should work normally, in terms of roadmap the Mono build is not our main priority currently and we will conduct full testing of the Mono build in the future and make an announcement once we consider that build to be stable or have had time to adapt the build appropriately.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration Classes which are used for dynamic loading of Configuration serialized as RDF Graphs.
            </para>
            <para>
            As of the 0.3.0 release we introduced this new API which provides for encoding configuration in RDF Graphs.  This configuration system has been used as part of a complete refresh of the ASP.Net support as it allows for much more expressive and flexible configurations than were previously possible.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.NamespaceDoc">
            <summary>
            <para>
            The Ontology Namespace is based upon <a href="http://jena.sourceforge.net/ontology/">Jena's Ontology API</a> and is an experimental part of the library.  It allows for a more resource-centric way of manipulating RDF graphs within the dotNetRDF API.
            </para>
            <para>
            The <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> is the base class of resources and allows for the retrieval and manipulation of various common properties of a resource.  More specialised classes like <see cref="T:VDS.RDF.Ontology.OntologyClass">OntologyClass</see> and <see cref="T:VDS.RDF.Ontology.OntologyProperty">OntologyProperty</see> are used to work with classes and properties etc.
            </para>
            <para>
            One key feature of this new part of the API is the <see cref="T:VDS.RDF.Ontology.ReasonerGraph">ReasonerGraph</see> which allows you to wrap an existing Graph with a reasoner to get a unified view over the original Triples and materialised inferences without modifying your original Graph.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parsing Classes and variety of supporting Classes.
            </para>
            <para>
            Classes here are primarily implementations of <see cref="!:ITokeniser">ITokeniser</see> and <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> with some implementations of <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> and a few other specialised classes.
            </para>
            <para>
            Has child namespaces <see cref="N:VDS.RDF.Parsing.Events">Events</see> and <see cref="N:VDS.RDF.Parsing.Tokens">Tokens</see> for supporting Event and Token based Parsing.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parser Context classes, these are classes that are used internally by parsers to store their state.  This allows parsers to be safely used in a multi-threaded scenario since the parsing of one Graph/Store cannot affect the parsing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.NamespaceDoc">
            <summary>
            Namespace for Event classes which are used to support Event Based parsing of RDF syntaxes
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NamespaceDoc">
            <summary>
            Namespace for Token classes which are used to support Token Based parsing of RDF syntaxes
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.NamespaceDoc">
            <summary>
            <para>
            Namespace for Query Classes which provide Querying capabilities on RDF Graphs
            </para>
            <para>
            Query capabilities are provided for two forms of Query:
            <ol>
                <li>Basic Graph pattern matching which is implemented via the <see cref="!:ISelector">ISelector</see> interface</li>
                <li>Sparql Queries
                    <ul>
                        <li>Full SPARQL over local in-memory Triple Stores</li>
                        <li>Full SPARQL over remote endpoints</li>
                    </ul>
                </li>
            </ol>
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NamespaceDoc">
            <summary>
            <para>
            Namespace for Aggregate classes which implement Aggregate functions for SPARQL
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model the mapping of SPARQL queries into the SPARQL Algebra.  This namespace is a key component of the new <strong>Leviathan</strong> SPARQL engine introduced in the 0.2.x builds of dotNetRDF
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes which implement algorithms for executing DESCRIBE queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing all the classes related to the execution of expressions in SPARQL queries.  Any valid expression should be able to be modelled and executed using these clases.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing Expression classes which model functions in SPARQL expressions
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes pertaining to the filtering of the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to apply GROUP BY clauses to SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.NamespaceDoc">
            <summary>
            <para>
            Namespace for Inference Classes which provide Inferencing capabilities on RDF - these features are currently experimental and may not work as expected.
            </para>
            <para>
            Classes which implement reasoning must implement the <see cref="T:VDS.RDF.Query.Inference.IInferenceEngine">IInferenceEngine</see> interface, these can then be attached to classes which implement the <see cref="T:VDS.RDF.IInferencingTripleStore">IInferencingTripleStore</see> interface or they can be used to apply inference to any <see cref="T:VDS.RDF.IGraph">IGraph</see> implementation with the inferred Triples optionally output to a separate Graph.
            </para>
            <para>
            OWL reasoning currently has extremely limited support, we provide a Pellet client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Pellet</see> namespace which can be used to connect to a Pellet Server but that currently only provides reasoning on external knowledge bases on the Pellet Server
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides a client for interacting with a Pellet Server
            </para>
            <para>
            Due to Pellet Server being a relatively new product it is currently only possible to reason over external knowledge bases on a Pellet Server and not to use Pellet to reason over in-memory data.  As Pellet Server is updated in the future this client will be updated to take advantage of those updates and to eventually provide for in-memory reasoning.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides classes which represent the Services offered by a Pellet Server knowledge base
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to order the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model property paths in SPARQL, they can be used to both represent and evaluate a property path as part of a SPARQL query.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.NamespaceDoc">
            <summary>
            Namespace for Pattern Classes that are used in the Graph and Triple matching process for executing SPARQL queries on <see cref="T:VDS.RDF.IInMemoryQueryableStore">IInMemoryQueryableStore</see> objects
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.NamespaceDoc">
            <summary>
            <para>
            Namespace for Storage Classes which provide support for using arbitrary backing Stores
            </para>
            <para>
            There are two main kinds of Store supported:
            <ol>
                <li>SQL Database based Stores as backing storage for RDF using classes such as <see cref="T:VDS.RDF.SqlGraph">SqlGraph</see> with implementations of the <see cref="T:VDS.RDF.Storage.ISqlIOManager">ISqlIOManager</see> interface.</li>
                <li>Arbitrary Stores as backing storage using classes such as <see cref="T:VDS.RDF.StoreGraph">StoreGraph</see> with implementations of the <see cref="T:VDS.RDF.Storage.IGenericIOManager">IGenericIOManager</see> interface.</li>
            </ol>
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Params.NamespaceDoc">
            <summary>
            Namespace for Parameter Classes which provide Parameter information to <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> and <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Translation.NamespaceDoc">
            <summary>
            <para>
            Namespace for Translation Classes which provide the ability to translate RDF directly from one format to another
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.NamespaceDoc">
            <summary>
            <para>
            Namespace for performing updates on Triple Stores using SPARQL Update
            </para>
            <para>
            This is a new part of the API introduced in the 0.3.0 release and adds support for using SPARQL to update Triple Stores.  SPARQL Update is part of the new SPARQL 1.1 standard and provides syntax for inserting, modifying and deleting data as well as managing graphs in a store.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes which model SPARQL Update Commands.  These can be used both to represent SPARQL Updates and to execute them over in-memory stores.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.NamespaceDoc">
            <summary>
            <para>
            Namespaces containing classes which implement the SPARQL Uniform HTTP Protocol for RDF Graph Management
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.NamespaceDoc">
            <summary>
            <para>
            Namespace for Classes designed to aid the deployment of Linked Data, SPARQL Endpoints and other Semantic Web technologies as part of ASP.Net web applications.
            </para>
            <para>
            As of the 0.3.0 release the ASP.Net support has been heavily rewritten, as opposed to the previous system which required many &lt;appSettings&gt; defining the new system now requires only 1 &lt;appSetting&gt; like so:
            <code>
            &lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;
            </code>
            This setting provides a pointer to an RDF configuration graph that uses the <a href="http://www.dotnetrdf.org/configuration#">Configuration Vocabulary</a> to express the configuration of HTTP Handlers for your ASP.Net application.  We also now provide a command line tool <a href="http://www.dotnetrdf.org/content.asp?pageID=rdfWedDeploy">rdfWebDeploy</a> which can be used to automate the testing and deployment of this configuration.  See documentation on the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">Configuration API</a> for more detail.  Individual handler documentation gives basic examples of Handler configurations.
            </para>
            <para>
            <strong>Note: </strong> As can be seen the old ASP.Net handlers have now all been marked as obsolete, they are left in the library currently to provide compatability with existing applications but we strongly recommend that applications using these migrate to the new Handlers and all new development should use the new Handlers.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for HTTP Handlers provided as part of the <strong>Web</strong> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writing Classes which provide the means to Serialize RDF Graphs as concrete RDF syntaxes or graphical representations.
            </para>
            <para>
            Also contains classes that can be used to save Graphs and Triple Stores to arbitrary database backed storage using classes from the <see cref="N:VDS.RDF.Storage">Storage</see> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writer Context classes, these are classes that are used internally by writers to store their state.  This allows writers to be safely used in a multi-threaded scenario since the writing of one Graph/Store cannot affect the writing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.NodeType">
            <summary>
            Node Type Values
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Blank">
            <summary>
            A Blank Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Uri">
            <summary>
            A Uri Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Literal">
            <summary>
            A Literal Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.GraphLiteral">
            <summary>
            A Graph Literal Node
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.CommentIgnoringJsonTextReader">
            <summary>
            A subclass of <see cref="T:Newtonsoft.Json.JsonTextReader">JsonTextReader</see> which automatically ignores all comments
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.CommentIgnoringJsonTextReader.Read">
            <summary>
            Reads the next non-comment Token if one is available
            </summary>
            <returns>True if a Token was read, False otherwise</returns>
        </member>
    </members>
</doc>
